{
  "data": [
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "How can we categorize errors?",
              "id": 2180,
              "answers": [
                {
                  "answer_id": 2185,
                  "document_id": 43,
                  "question_id": 2180,
                  "text": "into two major categories: *recoverable* and *unrecoverable*",
                  "answer_start": 459,
                  "answer_end": 519,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What could be an example of recoverable error?",
              "id": 2181,
              "answers": [
                {
                  "answer_id": 2186,
                  "document_id": 43,
                  "question_id": 2181,
                  "text": "*file not found* error",
                  "answer_start": 563,
                  "answer_end": 585,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What should I do with a recoverable error?",
              "id": 2182,
              "answers": [
                {
                  "answer_id": 2187,
                  "document_id": 43,
                  "question_id": 2182,
                  "text": "we most\nlikely just want to report the problem to the user and retry the operation",
                  "answer_start": 587,
                  "answer_end": 669,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is an example of unrecoverable error?",
              "id": 2183,
              "answers": [
                {
                  "answer_id": 2188,
                  "document_id": 43,
                  "question_id": 2183,
                  "text": "trying to access a\nlocation beyond the end of an array",
                  "answer_start": 726,
                  "answer_end": 780,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Does Rust language contain exceptions?",
              "id": 2184,
              "answers": [
                {
                  "answer_id": 2189,
                  "document_id": 43,
                  "question_id": 2184,
                  "text": "Rust doesn’t have\nexceptions",
                  "answer_start": 968,
                  "answer_end": 996,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What should be used to handle recoverable error?",
              "id": 2185,
              "answers": [
                {
                  "answer_id": 2190,
                  "document_id": 43,
                  "question_id": 2185,
                  "text": "`Result‹T, E>`",
                  "answer_start": 1023,
                  "answer_end": 1037,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What should be used for unrecoverable errors?",
              "id": 2186,
              "answers": [
                {
                  "answer_id": 2191,
                  "document_id": 43,
                  "question_id": 2186,
                  "text": "`panic!` macro",
                  "answer_start": 1069,
                  "answer_end": 1083,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How does 'panic!' macro work?",
              "id": 2187,
              "answers": [
                {
                  "answer_id": 2192,
                  "document_id": 43,
                  "question_id": 2187,
                  "text": "stops execution when the program encounters an\nunrecoverable error",
                  "answer_start": 1089,
                  "answer_end": 1155,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "# Error Handling\n\nErrors are a fact of life in software, so Rust has a number of features for\nhandling situations in which something goes wrong. In many cases, Rust requires\nyou to acknowledge the possibility of an error and take some action before your\ncode will compile. This requirement makes your program more robust by ensuring\nthat you’ll discover errors and handle them appropriately before you’ve\ndeployed your code to production!\n\nRust groups errors into two major categories: *recoverable* and *unrecoverable*\nerrors. For a recoverable error, such as a *file not found* error, we most\nlikely just want to report the problem to the user and retry the operation.\nUnrecoverable errors are always symptoms of bugs, like trying to access a\nlocation beyond the end of an array, and so we want to immediately stop the\nprogram.\n\nMost languages don’t distinguish between these two kinds of errors and handle\nboth in the same way, using mechanisms such as exceptions. Rust doesn’t have\nexceptions. Instead, it has the type `Result<T, E>` for recoverable errors and\nthe `panic!` macro that stops execution when the program encounters an\nunrecoverable error. This chapter covers calling `panic!` first and then talks\nabout returning `Result<T, E>` values. Additionally, we’ll explore\nconsiderations when deciding whether to try to recover from an error or to stop\nexecution.\n",
          "document_id": 43
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What happens when 'panic' occur?",
              "id": 2003,
              "answers": [
                {
                  "answer_id": 2003,
                  "document_id": 44,
                  "question_id": 2003,
                  "text": "print a failure message, unwind, clean up the stack, and quit",
                  "answer_start": 432,
                  "answer_end": 493,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I display stack trace?",
              "id": 2004,
              "answers": [
                {
                  "answer_id": 2004,
                  "document_id": 44,
                  "question_id": 2004,
                  "text": "Via an\nenvironment variable, you can also have Rust display the call stack when a\npanic occurs to make it easier to track down the source of the panic.",
                  "answer_start": 495,
                  "answer_end": 646,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I terminate program when and provide feedback to the caller?",
              "id": 2005,
              "answers": [
                {
                  "answer_id": 2005,
                  "document_id": 44,
                  "question_id": 2005,
                  "text": "by taking an action that causes our code to panic (such as\naccessing an array past the end) or by explicitly calling the `panic!` macro.",
                  "answer_start": 217,
                  "answer_end": 353,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What will happen when I try to read an elements with unexisting index?",
              "id": 2139,
              "answers": [
                {
                  "answer_id": 2144,
                  "document_id": 44,
                  "question_id": 2139,
                  "text": "Rust will stop execution and refuse to\ncontinue",
                  "answer_start": 4292,
                  "answer_end": 4339,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to get backtrace of an error?",
              "id": 2140,
              "answers": [
                {
                  "answer_id": 2145,
                  "document_id": 44,
                  "question_id": 2140,
                  "text": " set the `RUST_BACKTRACE`\nenvironment variable",
                  "answer_start": 4571,
                  "answer_end": 4617,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is a backtrace?",
              "id": 2141,
              "answers": [
                {
                  "answer_id": 2146,
                  "document_id": 44,
                  "question_id": 2141,
                  "text": "a list of all the functions that have been called to\nget to this point",
                  "answer_start": 4699,
                  "answer_end": 4769,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to enable debug symbols?",
              "id": 2142,
              "answers": [
                {
                  "answer_id": 2147,
                  "document_id": 44,
                  "question_id": 2142,
                  "text": "`cargo build` or `cargo run` without the `--release` flag",
                  "answer_start": 7308,
                  "answer_end": 7365,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is buffer overread?",
              "id": 2143,
              "answers": [
                {
                  "answer_id": 2148,
                  "document_id": 44,
                  "question_id": 2143,
                  "text": "You might get whatever is at the location in memory that would\ncorrespond to that element in the data structure, even though the memory\ndoesn’t belong to that structure",
                  "answer_start": 3779,
                  "answer_end": 3947,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Unrecoverable Errors with `panic!`\n\nSometimes, bad things happen in your code, and there’s nothing you can do about\nit. In these cases, Rust has the `panic!` macro. There are two ways to cause a\npanic in practice: by taking an action that causes our code to panic (such as\naccessing an array past the end) or by explicitly calling the `panic!` macro.\nIn both cases, we cause a panic in our program. By default, these panics will\nprint a failure message, unwind, clean up the stack, and quit. Via an\nenvironment variable, you can also have Rust display the call stack when a\npanic occurs to make it easier to track down the source of the panic.\n\n> ### Unwinding the Stack or Aborting in Response to a Panic\n>\n> By default, when a panic occurs, the program starts *unwinding*, which\n> means Rust walks back up the stack and cleans up the data from each function\n> it encounters. However, this walking back and cleanup is a lot of work. Rust,\n> therefore, allows you to choose the alternative of immediately *aborting*,\n> which ends the program without cleaning up.\n>\n> Memory that the program was using will then need to be cleaned\n> up by the operating system. If in your project you need to make the resulting\n> binary as small as possible, you can switch from unwinding to aborting upon a\n> panic by adding `panic = 'abort'` to the appropriate `[profile]` sections in\n> your *Cargo.toml* file. For example, if you want to abort on panic in release\n> mode, add this:\n>\n> ```toml\n> [profile.release]\n> panic = 'abort'\n> ```\n\nLet’s try calling `panic!` in a simple program:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic,panics\n{{#rustdoc_include ../listings/ch09-error-handling/no-listing-01-panic/src/main.rs}}\n```\n\nWhen you run the program, you’ll see something like this:\n\n```console\n{{#include ../listings/ch09-error-handling/no-listing-01-panic/output.txt}}\n```\n\nThe call to `panic!` causes the error message contained in the last two lines.\nThe first line shows our panic message and the place in our source code where\nthe panic occurred: *src/main.rs:2:5* indicates that it’s the second line,\nfifth character of our *src/main.rs* file.\n\nIn this case, the line indicated is part of our code, and if we go to that\nline, we see the `panic!` macro call. In other cases, the `panic!` call might\nbe in code that our code calls, and the filename and line number reported by\nthe error message will be someone else’s code where the `panic!` macro is\ncalled, not the line of our code that eventually led to the `panic!` call. We\ncan use the backtrace of the functions the `panic!` call came from to figure\nout the part of our code that is causing the problem. We’ll discuss backtraces\nin more detail next.\n\n### Using a `panic!` Backtrace\n\nLet’s look at another example to see what it’s like when a `panic!` call comes\nfrom a library because of a bug in our code instead of from our code calling\nthe macro directly. Listing 9-1 has some code that attempts to access an\nindex in a vector beyond the range of valid indexes.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic,panics\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-01/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 9-1: Attempting to access an element beyond the\nend of a vector, which will cause a call to `panic!`</span>\n\nHere, we’re attempting to access the 100th element of our vector (which is at\nindex 99 because indexing starts at zero), but the vector has only 3 elements.\nIn this situation, Rust will panic. Using `[]` is supposed to return an\nelement, but if you pass an invalid index, there’s no element that Rust could\nreturn here that would be correct.\n\nIn C, attempting to read beyond the end of a data structure is undefined\nbehavior. You might get whatever is at the location in memory that would\ncorrespond to that element in the data structure, even though the memory\ndoesn’t belong to that structure. This is called a *buffer overread* and can\nlead to security vulnerabilities if an attacker is able to manipulate the index\nin such a way as to read data they shouldn’t be allowed to that is stored after\nthe data structure.\n\nTo protect your program from this sort of vulnerability, if you try to read an\nelement at an index that doesn’t exist, Rust will stop execution and refuse to\ncontinue. Let’s try it and see:\n\n```console\n{{#include ../listings/ch09-error-handling/listing-09-01/output.txt}}\n```\n\nThis error points at line 4 of our `main.rs` where we attempt to access index\n99. The next note line tells us that we can set the `RUST_BACKTRACE`\nenvironment variable to get a backtrace of exactly what happened to cause the\nerror. A *backtrace* is a list of all the functions that have been called to\nget to this point. Backtraces in Rust work as they do in other languages: the\nkey to reading the backtrace is to start from the top and read until you see\nfiles you wrote. That’s the spot where the problem originated. The lines above\nthat spot are code that your code has called; the lines below are code that\ncalled your code. These before-and-after lines might include core Rust code,\nstandard library code, or crates that you’re using. Let’s try getting a\nbacktrace by setting the `RUST_BACKTRACE` environment variable to any value\nexcept 0. Listing 9-2 shows output similar to what you’ll see.\n\n<!-- manual-regeneration\ncd listings/ch09-error-handling/listing-09-01\nRUST_BACKTRACE=1 cargo run\ncopy the backtrace output below\ncheck the backtrace number mentioned in the text below the listing\n-->\n\n```console\n$ RUST_BACKTRACE=1 cargo run\nthread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5\nstack backtrace:\n   0: rust_begin_unwind\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5\n   1: core::panicking::panic_fmt\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14\n   2: core::panicking::panic_bounds_check\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5\n   3: <usize as core::slice::index::SliceIndex<[T]>>::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10\n   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9\n   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9\n   6: panic::main\n             at ./src/main.rs:4:5\n   7: core::ops::function::FnOnce::call_once\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n```\n\n<span class=\"caption\">Listing 9-2: The backtrace generated by a call to\n`panic!` displayed when the environment variable `RUST_BACKTRACE` is set</span>\n\nThat’s a lot of output! The exact output you see might be different depending\non your operating system and Rust version. In order to get backtraces with this\ninformation, debug symbols must be enabled. Debug symbols are enabled by\ndefault when using `cargo build` or `cargo run` without the `--release` flag,\nas we have here.\n\nIn the output in Listing 9-2, line 6 of the backtrace points to the line in our\nproject that’s causing the problem: line 4 of *src/main.rs*. If we don’t want\nour program to panic, we should start our investigation at the location pointed\nto by the first line mentioning a file we wrote. In Listing 9-1, where we\ndeliberately wrote code that would panic, the way to fix the panic is to not\nrequest an element beyond the range of the vector indexes. When your code\npanics in the future, you’ll need to figure out what action the code is taking\nwith what values to cause the panic and what the code should do instead.\n\nWe’ll come back to `panic!` and when we should and should not use `panic!` to\nhandle error conditions in the [“To `panic!` or Not to\n`panic!`”][to-panic-or-not-to-panic]<!-- ignore --> section later in this\nchapter. Next, we’ll look at how to recover from an error using `Result`.\n\n[to-panic-or-not-to-panic]:\nch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic\n",
          "document_id": 44
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "When can I use 'result' instead of 'panic'?",
              "id": 2006,
              "answers": [
                {
                  "answer_id": 2006,
                  "document_id": 45,
                  "question_id": 2006,
                  "text": "For example, if you try to open a file and that\noperation fails because the file doesn’t exist, you might want to create the\nfile instead of terminating the process",
                  "answer_start": 210,
                  "answer_end": 374,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does 'T' mean in generics?",
              "id": 2008,
              "answers": [
                {
                  "answer_id": 2008,
                  "document_id": 45,
                  "question_id": 2008,
                  "text": "`T` represents\nthe type of the value that will be returned in a success case within the `Ok`\nvariant,",
                  "answer_start": 761,
                  "answer_end": 862,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does 'E' mean in generics?",
              "id": 2009,
              "answers": [
                {
                  "answer_id": 2009,
                  "document_id": 45,
                  "question_id": 2009,
                  "text": " `E` represents the type of the error that will be returned in a\nfailure case within the `Err`",
                  "answer_start": 866,
                  "answer_end": 960,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "When the fact that 'result' uses generics can be useful?",
              "id": 2010,
              "answers": [
                {
                  "answer_id": 2010,
                  "document_id": 45,
                  "question_id": 2010,
                  "text": "we can use the `Result` type and the functions defined on it in\nmany different situations where the successful value and error value we want to\nreturn may differ.",
                  "answer_start": 1022,
                  "answer_end": 1184,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What type 'File::open' returns for Err variant?",
              "id": 2144,
              "answers": [
                {
                  "answer_id": 2149,
                  "document_id": 45,
                  "question_id": 2144,
                  "text": "io::Error",
                  "answer_start": 4964,
                  "answer_end": 4973,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to check the type of error?",
              "id": 2145,
              "answers": [
                {
                  "answer_id": 2150,
                  "document_id": 45,
                  "question_id": 2145,
                  "text": "error.kind()",
                  "answer_start": 5566,
                  "answer_end": 5578,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does expect method of Result do?",
              "id": 2146,
              "answers": [
                {
                  "answer_id": 2151,
                  "document_id": 45,
                  "question_id": 2146,
                  "text": "lets us also choose the `panic!` error message",
                  "answer_start": 8640,
                  "answer_end": 8686,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is error propagating?",
              "id": 2147,
              "answers": [
                {
                  "answer_id": 2152,
                  "document_id": 45,
                  "question_id": 2147,
                  "text": "instead of\nhandling the error within the function itself, you can return the error to the\ncalling code so that it can decide what to do",
                  "answer_start": 9979,
                  "answer_end": 10114,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Where The `?` Operator Can Be Used",
              "id": 2148,
              "answers": [
                {
                  "answer_id": 2153,
                  "document_id": 45,
                  "question_id": 2148,
                  "text": "The `?` operator can only be used in functions whose return type is compatible\nwith the value the `?` is used on.",
                  "answer_start": 19085,
                  "answer_end": 19198,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the purpose of unwrap method of Result?",
              "id": 2149,
              "answers": [
                {
                  "answer_id": 2154,
                  "document_id": 45,
                  "question_id": 2149,
                  "text": "If the `Result` value is the `Ok` variant, `unwrap` will return\nthe value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` will\ncall the `panic!` macro for us.",
                  "answer_start": 7800,
                  "answer_end": 7974,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Recoverable Errors with `Result`\n\nMost errors aren’t serious enough to require the program to stop entirely.\nSometimes, when a function fails, it’s for a reason that you can easily\ninterpret and respond to. For example, if you try to open a file and that\noperation fails because the file doesn’t exist, you might want to create the\nfile instead of terminating the process.\n\nRecall from [“Handling Potential Failure with `Result`”][handle_failure]<!--\nignore --> in Chapter 2 that the `Result` enum is defined as having two\nvariants, `Ok` and `Err`, as follows:\n\n```rust\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\nThe `T` and `E` are generic type parameters: we’ll discuss generics in more\ndetail in Chapter 10. What you need to know right now is that `T` represents\nthe type of the value that will be returned in a success case within the `Ok`\nvariant, and `E` represents the type of the error that will be returned in a\nfailure case within the `Err` variant. Because `Result` has these generic type\nparameters, we can use the `Result` type and the functions defined on it in\nmany different situations where the successful value and error value we want to\nreturn may differ.\n\nLet’s call a function that returns a `Result` value because the function could\nfail. In Listing 9-3 we try to open a file.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 9-3: Opening a file</span>\n\nThe return type of `File::open` is a `Result<T, E>`. The generic parameter `T`\nhas been filled in by the implementation of `File::open` with the type of the\nsuccess value, `std::fs::File`, which is a file handle. The type of `E` used in\nthe error value is `std::io::Error`. This return type means the call to\n`File::open` might succeed and return a file handle that we can read from or\nwrite to. The function call also might fail: for example, the file might not\nexist, or we might not have permission to access the file. The `File::open`\nfunction needs to have a way to tell us whether it succeeded or failed and at\nthe same time give us either the file handle or error information. This\ninformation is exactly what the `Result` enum conveys.\n\nIn the case where `File::open` succeeds, the value in the variable\n`greeting_file_result` will be an instance of `Ok` that contains a file handle.\nIn the case where it fails, the value in `greeting_file_result` will be an\ninstance of `Err` that contains more information about the kind of error that\nhappened.\n\nWe need to add to the code in Listing 9-3 to take different actions depending\non the value `File::open` returns. Listing 9-4 shows one way to handle the\n`Result` using a basic tool, the `match` expression that we discussed in\nChapter 6.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 9-4: Using a `match` expression to handle the\n`Result` variants that might be returned</span>\n\nNote that, like the `Option` enum, the `Result` enum and its variants have been\nbrought into scope by the prelude, so we don’t need to specify `Result::`\nbefore the `Ok` and `Err` variants in the `match` arms.\n\nWhen the result is `Ok`, this code will return the inner `file` value out of\nthe `Ok` variant, and we then assign that file handle value to the variable\n`greeting_file`. After the `match`, we can use the file handle for reading or\nwriting.\n\nThe other arm of the `match` handles the case where we get an `Err` value from\n`File::open`. In this example, we’ve chosen to call the `panic!` macro. If\nthere’s no file named *hello.txt* in our current directory and we run this\ncode, we’ll see the following output from the `panic!` macro:\n\n```console\n{{#include ../listings/ch09-error-handling/listing-09-04/output.txt}}\n```\n\nAs usual, this output tells us exactly what has gone wrong.\n\n### Matching on Different Errors\n\nThe code in Listing 9-4 will `panic!` no matter why `File::open` failed.\nHowever, we want to take different actions for different failure reasons: if\n`File::open` failed because the file doesn’t exist, we want to create the file\nand return the handle to the new file. If `File::open` failed for any other\nreason—for example, because we didn’t have permission to open the file—we still\nwant the code to `panic!` in the same way as it did in Listing 9-4. For this we\nadd an inner `match` expression, shown in Listing 9-5.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n<!-- ignore this test because otherwise it creates hello.txt which causes other\ntests to fail lol -->\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-05/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 9-5: Handling different kinds of errors in\ndifferent ways</span>\n\nThe type of the value that `File::open` returns inside the `Err` variant is\n`io::Error`, which is a struct provided by the standard library. This struct\nhas a method `kind` that we can call to get an `io::ErrorKind` value. The enum\n`io::ErrorKind` is provided by the standard library and has variants\nrepresenting the different kinds of errors that might result from an `io`\noperation. The variant we want to use is `ErrorKind::NotFound`, which indicates\nthe file we’re trying to open doesn’t exist yet. So we match on\n`greeting_file_result`, but we also have an inner match on `error.kind()`.\n\nThe condition we want to check in the inner match is whether the value returned\nby `error.kind()` is the `NotFound` variant of the `ErrorKind` enum. If it is,\nwe try to create the file with `File::create`. However, because `File::create`\ncould also fail, we need a second arm in the inner `match` expression. When the\nfile can’t be created, a different error message is printed. The second arm of\nthe outer `match` stays the same, so the program panics on any error besides\nthe missing file error.\n\n> ### Alternatives to Using `match` with `Result<T, E>`\n>\n> That’s a lot of `match`! The `match` expression is very useful but also very\n> much a primitive. In Chapter 13, you’ll learn about closures, which are used\n> with many of the methods defined on `Result<T, E>`. These methods can be more\n> concise than using `match` when handling `Result<T, E>` values in your code.\n>\n> For example, here’s another way to write the same logic as shown in Listing\n> 9-5, this time using closures and the `unwrap_or_else` method:\n>\n> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->\n>\n> ```rust,ignore\n> use std::fs::File;\n> use std::io::ErrorKind;\n>\n> fn main() {\n>     let greeting_file = File::open(\"hello.txt\").unwrap_or_else(|error| {\n>         if error.kind() == ErrorKind::NotFound {\n>             File::create(\"hello.txt\").unwrap_or_else(|error| {\n>                 panic!(\"Problem creating the file: {:?}\", error);\n>             })\n>         } else {\n>             panic!(\"Problem opening the file: {:?}\", error);\n>         }\n>     });\n> }\n> ```\n>\n> Although this code has the same behavior as Listing 9-5, it doesn’t contain\n> any `match` expressions and is cleaner to read. Come back to this example\n> after you’ve read Chapter 13, and look up the `unwrap_or_else` method in the\n> standard library documentation. Many more of these methods can clean up huge\n> nested `match` expressions when you’re dealing with errors.\n\n### Shortcuts for Panic on Error: `unwrap` and `expect`\n\nUsing `match` works well enough, but it can be a bit verbose and doesn’t always\ncommunicate intent well. The `Result<T, E>` type has many helper methods\ndefined on it to do various, more specific tasks. The `unwrap` method is a\nshortcut method implemented just like the `match` expression we wrote in\nListing 9-4. If the `Result` value is the `Ok` variant, `unwrap` will return\nthe value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` will\ncall the `panic!` macro for us. Here is an example of `unwrap` in action:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic\n{{#rustdoc_include ../listings/ch09-error-handling/no-listing-04-unwrap/src/main.rs}}\n```\n\nIf we run this code without a *hello.txt* file, we’ll see an error message from\nthe `panic!` call that the `unwrap` method makes:\n\n<!-- manual-regeneration\ncd listings/ch09-error-handling/no-listing-04-unwrap\ncargo run\ncopy and paste relevant text\n-->\n\n```text\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {\ncode: 2, kind: NotFound, message: \"No such file or directory\" }',\nsrc/main.rs:4:49\n```\n\nSimilarly, the `expect` method lets us also choose the `panic!` error message.\nUsing `expect` instead of `unwrap` and providing good error messages can convey\nyour intent and make tracking down the source of a panic easier. The syntax of\n`expect` looks like this:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic\n{{#rustdoc_include ../listings/ch09-error-handling/no-listing-05-expect/src/main.rs}}\n```\n\nWe use `expect` in the same way as `unwrap`: to return the file handle or call\nthe `panic!` macro. The error message used by `expect` in its call to `panic!`\nwill be the parameter that we pass to `expect`, rather than the default\n`panic!` message that `unwrap` uses. Here’s what it looks like:\n\n<!-- manual-regeneration\ncd listings/ch09-error-handling/no-listing-05-expect\ncargo run\ncopy and paste relevant text\n-->\n\n```text\nthread 'main' panicked at 'hello.txt should be included in this project: Os {\ncode: 2, kind: NotFound, message: \"No such file or directory\" }',\nsrc/main.rs:5:10\n```\n\nIn production-quality code, most Rustaceans choose `expect` rather than\n`unwrap` and give more context about why the operation is expected to always\nsucceed. That way, if your assumptions are ever proven wrong, you have more\ninformation to use in debugging.\n\n### Propagating Errors\n\nWhen a function’s implementation calls something that might fail, instead of\nhandling the error within the function itself, you can return the error to the\ncalling code so that it can decide what to do. This is known as *propagating*\nthe error and gives more control to the calling code, where there might be more\ninformation or logic that dictates how the error should be handled than what\nyou have available in the context of your code.\n\nFor example, Listing 9-6 shows a function that reads a username from a file. If\nthe file doesn’t exist or can’t be read, this function will return those errors\nto the code that called the function.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile panics. We do want to include it for reader experimentation purposes, but\ndon't want to include it for rustdoc testing purposes. -->\n\n```rust\n{{#include ../listings/ch09-error-handling/listing-09-06/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 9-6: A function that returns errors to the\ncalling code using `match`</span>\n\nThis function can be written in a much shorter way, but we’re going to start by\ndoing a lot of it manually in order to explore error handling; at the end,\nwe’ll show the shorter way. Let’s look at the return type of the function\nfirst: `Result<String, io::Error>`. This means the function is returning a\nvalue of the type `Result<T, E>` where the generic parameter `T` has been\nfilled in with the concrete type `String`, and the generic type `E` has been\nfilled in with the concrete type `io::Error`.\n\nIf this function succeeds without any problems, the code that calls this\nfunction will receive an `Ok` value that holds a `String`—the username that\nthis function read from the file. If this function encounters any problems, the\ncalling code will receive an `Err` value that holds an instance of `io::Error`\nthat contains more information about what the problems were. We chose\n`io::Error` as the return type of this function because that happens to be the\ntype of the error value returned from both of the operations we’re calling in\nthis function’s body that might fail: the `File::open` function and the\n`read_to_string` method.\n\nThe body of the function starts by calling the `File::open` function. Then we\nhandle the `Result` value with a `match` similar to the `match` in Listing 9-4.\nIf `File::open` succeeds, the file handle in the pattern variable `file`\nbecomes the value in the mutable variable `username_file` and the function\ncontinues. In the `Err` case, instead of calling `panic!`, we use the `return`\nkeyword to return early out of the function entirely and pass the error value\nfrom `File::open`, now in the pattern variable `e`, back to the calling code as\nthis function’s error value.\n\nSo if we have a file handle in `username_file`, the function then creates a new\n`String` in variable `username` and calls the `read_to_string` method on\nthe file handle in `username_file` to read the contents of the file into\n`username`. The `read_to_string` method also returns a `Result` because it\nmight fail, even though `File::open` succeeded. So we need another `match` to\nhandle that `Result`: if `read_to_string` succeeds, then our function has\nsucceeded, and we return the username from the file that’s now in `username`\nwrapped in an `Ok`. If `read_to_string` fails, we return the error value in the\nsame way that we returned the error value in the `match` that handled the\nreturn value of `File::open`. However, we don’t need to explicitly say\n`return`, because this is the last expression in the function.\n\nThe code that calls this code will then handle getting either an `Ok` value\nthat contains a username or an `Err` value that contains an `io::Error`. It’s\nup to the calling code to decide what to do with those values. If the calling\ncode gets an `Err` value, it could call `panic!` and crash the program, use a\ndefault username, or look up the username from somewhere other than a file, for\nexample. We don’t have enough information on what the calling code is actually\ntrying to do, so we propagate all the success or error information upward for\nit to handle appropriately.\n\nThis pattern of propagating errors is so common in Rust that Rust provides the\nquestion mark operator `?` to make this easier.\n\n#### A Shortcut for Propagating Errors: the `?` Operator\n\nListing 9-7 shows an implementation of `read_username_from_file` that has the\nsame functionality as in Listing 9-6, but this implementation uses the\n`?` operator.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile panics. We do want to include it for reader experimentation purposes, but\ndon't want to include it for rustdoc testing purposes. -->\n\n```rust\n{{#include ../listings/ch09-error-handling/listing-09-07/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 9-7: A function that returns errors to the\ncalling code using the `?` operator</span>\n\nThe `?` placed after a `Result` value is defined to work in almost the same way\nas the `match` expressions we defined to handle the `Result` values in Listing\n9-6. If the value of the `Result` is an `Ok`, the value inside the `Ok` will\nget returned from this expression, and the program will continue. If the value\nis an `Err`, the `Err` will be returned from the whole function as if we had\nused the `return` keyword so the error value gets propagated to the calling\ncode.\n\nThere is a difference between what the `match` expression from Listing 9-6 does\nand what the `?` operator does: error values that have the `?` operator called\non them go through the `from` function, defined in the `From` trait in the\nstandard library, which is used to convert values from one type into another.\nWhen the `?` operator calls the `from` function, the error type received is\nconverted into the error type defined in the return type of the current\nfunction. This is useful when a function returns one error type to represent\nall the ways a function might fail, even if parts might fail for many different\nreasons.\n\nFor example, we could change the `read_username_from_file` function in Listing\n9-7 to return a custom error type named `OurError` that we define. If we also\ndefine `impl From<io::Error> for OurError` to construct an instance of\n`OurError` from an `io::Error`, then the `?` operator calls in the body of\n`read_username_from_file` will call `from` and convert the error types without\nneeding to add any more code to the function.\n\nIn the context of Listing 9-7, the `?` at the end of the `File::open` call will\nreturn the value inside an `Ok` to the variable `username_file`. If an error\noccurs, the `?` operator will return early out of the whole function and give\nany `Err` value to the calling code. The same thing applies to the `?` at the\nend of the `read_to_string` call.\n\nThe `?` operator eliminates a lot of boilerplate and makes this function’s\nimplementation simpler. We could even shorten this code further by chaining\nmethod calls immediately after the `?`, as shown in Listing 9-8.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile panics. We do want to include it for reader experimentation purposes, but\ndon't want to include it for rustdoc testing purposes. -->\n\n```rust\n{{#include ../listings/ch09-error-handling/listing-09-08/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 9-8: Chaining method calls after the `?`\noperator</span>\n\nWe’ve moved the creation of the new `String` in `username` to the beginning of\nthe function; that part hasn’t changed. Instead of creating a variable\n`username_file`, we’ve chained the call to `read_to_string` directly onto the\nresult of `File::open(\"hello.txt\")?`. We still have a `?` at the end of the\n`read_to_string` call, and we still return an `Ok` value containing `username`\nwhen both `File::open` and `read_to_string` succeed rather than returning\nerrors. The functionality is again the same as in Listing 9-6 and Listing 9-7;\nthis is just a different, more ergonomic way to write it.\n\nListing 9-9 shows a way to make this even shorter using `fs::read_to_string`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile panics. We do want to include it for reader experimentation purposes, but\ndon't want to include it for rustdoc testing purposes. -->\n\n```rust\n{{#include ../listings/ch09-error-handling/listing-09-09/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 9-9: Using `fs::read_to_string` instead of\nopening and then reading the file</span>\n\nReading a file into a string is a fairly common operation, so the standard\nlibrary provides the convenient `fs::read_to_string` function that opens the\nfile, creates a new `String`, reads the contents of the file, puts the contents\ninto that `String`, and returns it. Of course, using `fs::read_to_string`\ndoesn’t give us the opportunity to explain all the error handling, so we did it\nthe longer way first.\n\n#### Where The `?` Operator Can Be Used\n\nThe `?` operator can only be used in functions whose return type is compatible\nwith the value the `?` is used on. This is because the `?` operator is defined\nto perform an early return of a value out of the function, in the same manner\nas the `match` expression we defined in Listing 9-6. In Listing 9-6, the\n`match` was using a `Result` value, and the early return arm returned an\n`Err(e)` value. The return type of the function has to be a `Result` so that\nit’s compatible with this `return`.\n\nIn Listing 9-10, let’s look at the error we’ll get if we use the `?` operator\nin a `main` function with a return type incompatible with the type of the value\nwe use `?` on:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-10/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 9-10: Attempting to use the `?` in the `main`\nfunction that returns `()` won’t compile</span>\n\nThis code opens a file, which might fail. The `?` operator follows the `Result`\nvalue returned by `File::open`, but this `main` function has the return type of\n`()`, not `Result`. When we compile this code, we get the following error\nmessage:\n\n```console\n{{#include ../listings/ch09-error-handling/listing-09-10/output.txt}}\n```\n\nThis error points out that we’re only allowed to use the `?` operator in a\nfunction that returns `Result`, `Option`, or another type that implements\n`FromResidual`.\n\nTo fix the error, you have two choices. One choice is to change the return type\nof your function to be compatible with the value you’re using the `?` operator\non as long as you have no restrictions preventing that. The other technique is\nto use a `match` or one of the `Result<T, E>` methods to handle the `Result<T,\nE>` in whatever way is appropriate.\n\nThe error message also mentioned that `?` can be used with `Option<T>` values\nas well. As with using `?` on `Result`, you can only use `?` on `Option` in a\nfunction that returns an `Option`. The behavior of the `?` operator when called\non an `Option<T>` is similar to its behavior when called on a `Result<T, E>`:\nif the value is `None`, the `None` will be returned early from the function at\nthat point. If the value is `Some`, the value inside the `Some` is the\nresulting value of the expression and the function continues. Listing 9-11 has\nan example of a function that finds the last character of the first line in the\ngiven text:\n\n```rust\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-11/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 9-11: Using the `?` operator on an `Option<T>`\nvalue</span>\n\nThis function returns `Option<char>` because it’s possible that there is a\ncharacter there, but it’s also possible that there isn’t. This code takes the\n`text` string slice argument and calls the `lines` method on it, which returns\nan iterator over the lines in the string. Because this function wants to\nexamine the first line, it calls `next` on the iterator to get the first value\nfrom the iterator. If `text` is the empty string, this call to `next` will\nreturn `None`, in which case we use `?` to stop and return `None` from\n`last_char_of_first_line`. If `text` is not the empty string, `next` will\nreturn a `Some` value containing a string slice of the first line in `text`.\n\nThe `?` extracts the string slice, and we can call `chars` on that string slice\nto get an iterator of its characters. We’re interested in the last character in\nthis first line, so we call `last` to return the last item in the iterator.\nThis is an `Option` because it’s possible that the first line is the empty\nstring, for example if `text` starts with a blank line but has characters on\nother lines, as in `\"\\nhi\"`. However, if there is a last character on the first\nline, it will be returned in the `Some` variant. The `?` operator in the middle\ngives us a concise way to express this logic, allowing us to implement the\nfunction in one line. If we couldn’t use the `?` operator on `Option`, we’d\nhave to implement this logic using more method calls or a `match` expression.\n\nNote that you can use the `?` operator on a `Result` in a function that returns\n`Result`, and you can use the `?` operator on an `Option` in a function that\nreturns `Option`, but you can’t mix and match. The `?` operator won’t\nautomatically convert a `Result` to an `Option` or vice versa; in those cases,\nyou can use methods like the `ok` method on `Result` or the `ok_or` method on\n`Option` to do the conversion explicitly.\n\nSo far, all the `main` functions we’ve used return `()`. The `main` function is\nspecial because it’s the entry and exit point of executable programs, and there\nare restrictions on what its return type can be for the programs to behave as\nexpected.\n\nLuckily, `main` can also return a `Result<(), E>`. Listing 9-12 has the\ncode from Listing 9-10 but we’ve changed the return type of `main` to be\n`Result<(), Box<dyn Error>>` and added a return value `Ok(())` to the end. This\ncode will now compile:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-12/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 9-12: Changing `main` to return `Result<(), E>`\nallows the use of the `?` operator on `Result` values</span>\n\nThe `Box<dyn Error>` type is a *trait object*, which we’ll talk about in the\n[“Using Trait Objects that Allow for Values of Different\nTypes”][trait-objects]<!-- ignore --> section in Chapter 17. For now, you can\nread `Box<dyn Error>` to mean “any kind of error.” Using `?` on a `Result`\nvalue in a `main` function with the error type `Box<dyn Error>` is allowed,\nbecause it allows any `Err` value to be returned early. Even though the body of\nthis `main` function will only ever return errors of type `std::io::Error`, by\nspecifying `Box<dyn Error>`, this signature will continue to be correct even if\nmore code that returns other errors is added to the body of `main`.\n\nWhen a `main` function returns a `Result<(), E>`, the executable will\nexit with a value of `0` if `main` returns `Ok(())` and will exit with a\nnonzero value if `main` returns an `Err` value. Executables written in C return\nintegers when they exit: programs that exit successfully return the integer\n`0`, and programs that error return some integer other than `0`. Rust also\nreturns integers from executables to be compatible with this convention.\n\nThe `main` function may return any types that implement [the\n`std::process::Termination` trait][termination]<!-- ignore -->, which contains\na function `report` that returns an `ExitCode`. Consult the standard library\ndocumentation for more information on implementing the `Termination` trait for\nyour own types.\n\nNow that we’ve discussed the details of calling `panic!` or returning `Result`,\nlet’s return to the topic of how to decide which is appropriate to use in which\ncases.\n\n[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result\n[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[termination]: ../std/process/trait.Termination.html\n",
          "document_id": 45
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "When is it better to use panic instead of result?",
              "id": 2019,
              "answers": [
                {
                  "answer_id": 2019,
                  "document_id": 46,
                  "question_id": 2019,
                  "text": "In situations such as examples, prototype code, and tests, it’s more\nappropriate to write code that panics instead of returning a `Result`",
                  "answer_start": 804,
                  "answer_end": 942,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "When should I call 'panic'?",
              "id": 2021,
              "answers": [
                {
                  "answer_id": 2022,
                  "document_id": 46,
                  "question_id": 2021,
                  "text": "You could call `panic!`\nfor any error situation, whether there’s a possible way to recover or not, but\nthen you’re making the decision that a situation is unrecoverable on behalf of\nthe calling code",
                  "answer_start": 168,
                  "answer_end": 366,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "When is it better to use result instead of panic?",
              "id": 2022,
              "answers": [
                {
                  "answer_id": 2023,
                  "document_id": 46,
                  "question_id": 2022,
                  "text": "The calling code could choose to attempt to recover in a\nway that’s appropriate for its situation, or it could decide that an `Err`\nvalue in this case is unrecoverable, so it can call `panic!` and turn your\nrecoverable error into an unrecoverable one.",
                  "answer_start": 447,
                  "answer_end": 698,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "When should I call 'result'?",
              "id": 2023,
              "answers": [
                {
                  "answer_id": 2024,
                  "document_id": 46,
                  "question_id": 2023,
                  "text": "Therefore, returning `Result` is a\ngood default choice when you’re defining a function that might fail.",
                  "answer_start": 699,
                  "answer_end": 802,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is a bad state?",
              "id": 2024,
              "answers": [
                {
                  "answer_id": 2025,
                  "document_id": 46,
                  "question_id": 2024,
                  "text": "a *bad state* is when some\nassumption, guarantee, contract, or invariant has been broken, such as when\ninvalid values, contradictory values, or missing values are passed to your\ncode",
                  "answer_start": 3951,
                  "answer_end": 4133,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What can be an example of bad state error?",
              "id": 2025,
              "answers": [
                {
                  "answer_id": 2027,
                  "document_id": 46,
                  "question_id": 2025,
                  "text": "invalid values, contradictory values, or missing values are passed to your\ncode",
                  "answer_start": 4054,
                  "answer_end": 4133,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What should I do when someone passes wrong parameters to function?",
              "id": 2026,
              "answers": [
                {
                  "answer_id": 2029,
                  "document_id": 46,
                  "question_id": 2026,
                  "text": "it’s\nbest to return an error if you can so the user of the library can decide what\nthey want to do in that case. However, in cases where continuing could be\ninsecure or harmful, the best choice might be to call `panic!` and alert the\nperson using your library to the bug in their code so they can fix it during\ndevelopment.",
                  "answer_start": 4754,
                  "answer_end": 5077,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is an example of situation when it is better to use 'result' instead of 'panic'?",
              "id": 2027,
              "answers": [
                {
                  "answer_id": 2030,
                  "document_id": 46,
                  "question_id": 2027,
                  "text": "a parser being given malformed\ndata or an HTTP request returning a status that indicates you have hit a rate\nlimit.",
                  "answer_start": 5369,
                  "answer_end": 5484,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why should I validate parameters passed to the function?",
              "id": 2028,
              "answers": [
                {
                  "answer_id": 2031,
                  "document_id": 46,
                  "question_id": 2028,
                  "text": "This is mostly for safety reasons:\nattempting to operate on invalid data can expose your code to vulnerabilities.",
                  "answer_start": 5815,
                  "answer_end": 5928,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the most common example of calling 'panic'?",
              "id": 2029,
              "answers": [
                {
                  "answer_id": 2032,
                  "document_id": 46,
                  "question_id": 2029,
                  "text": "if you attempt\nan out-of-bounds memory access: trying to access memory that doesn’t belong to\nthe current data structure is a common security problem",
                  "answer_start": 5993,
                  "answer_end": 6142,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What could happen when I'm trying to access memory not belonging to current data structure?",
              "id": 2030,
              "answers": [
                {
                  "answer_id": 2033,
                  "document_id": 46,
                  "question_id": 2030,
                  "text": "This is the main reason the standard library will call `panic!`",
                  "answer_start": 5929,
                  "answer_end": 5992,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does a 'contract' mean in terms of function?",
              "id": 2031,
              "answers": [
                {
                  "answer_id": 2034,
                  "document_id": 46,
                  "question_id": 2031,
                  "text": "their behavior is only guaranteed if the inputs meet particular\nrequirements",
                  "answer_start": 6178,
                  "answer_end": 6254,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What should be done when fuction contract is violated?",
              "id": 2032,
              "answers": [
                {
                  "answer_id": 2035,
                  "document_id": 46,
                  "question_id": 2032,
                  "text": "Panicking when the contract is violated makes sense because a\ncontract violation always indicates a caller-side bug and it’s not a kind of\nerror you want the calling code to have to explicitly handle. In fact, there’s\nno reasonable way for calling code to recover; the calling *programmers* need\nto fix the code.",
                  "answer_start": 6256,
                  "answer_end": 6568,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## To `panic!` or Not to `panic!`\n\nSo how do you decide when you should call `panic!` and when you should return\n`Result`? When code panics, there’s no way to recover. You could call `panic!`\nfor any error situation, whether there’s a possible way to recover or not, but\nthen you’re making the decision that a situation is unrecoverable on behalf of\nthe calling code. When you choose to return a `Result` value, you give the\ncalling code options. The calling code could choose to attempt to recover in a\nway that’s appropriate for its situation, or it could decide that an `Err`\nvalue in this case is unrecoverable, so it can call `panic!` and turn your\nrecoverable error into an unrecoverable one. Therefore, returning `Result` is a\ngood default choice when you’re defining a function that might fail.\n\nIn situations such as examples, prototype code, and tests, it’s more\nappropriate to write code that panics instead of returning a `Result`. Let’s\nexplore why, then discuss situations in which the compiler can’t tell that\nfailure is impossible, but you as a human can. The chapter will conclude with\nsome general guidelines on how to decide whether to panic in library code.\n\n### Examples, Prototype Code, and Tests\n\nWhen you’re writing an example to illustrate some concept, also including robust\nerror-handling code can make the example less clear. In\nexamples, it’s understood that a call to a method like `unwrap` that could\npanic is meant as a placeholder for the way you’d want your application to\nhandle errors, which can differ based on what the rest of your code is doing.\n\nSimilarly, the `unwrap` and `expect` methods are very handy when prototyping,\nbefore you’re ready to decide how to handle errors. They leave clear markers in\nyour code for when you’re ready to make your program more robust.\n\nIf a method call fails in a test, you’d want the whole test to fail, even if\nthat method isn’t the functionality under test. Because `panic!` is how a test\nis marked as a failure, calling `unwrap` or `expect` is exactly what should\nhappen.\n\n### Cases in Which You Have More Information Than the Compiler\n\nIt would also be appropriate to call `unwrap` or `expect` when you have some\nother logic that ensures the `Result` will have an `Ok` value, but the logic\nisn’t something the compiler understands. You’ll still have a `Result` value\nthat you need to handle: whatever operation you’re calling still has the\npossibility of failing in general, even though it’s logically impossible in\nyour particular situation. If you can ensure by manually inspecting the code\nthat you’ll never have an `Err` variant, it’s perfectly acceptable to call\n`unwrap`, and even better to document the reason you think you’ll never have an\n`Err` variant in the `expect` text. Here’s an example:\n\n```rust\n{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}\n```\n\nWe’re creating an `IpAddr` instance by parsing a hardcoded string. We can see\nthat `127.0.0.1` is a valid IP address, so it’s acceptable to use `expect`\nhere. However, having a hardcoded, valid string doesn’t change the return type\nof the `parse` method: we still get a `Result` value, and the compiler will\nstill make us handle the `Result` as if the `Err` variant is a possibility\nbecause the compiler isn’t smart enough to see that this string is always a\nvalid IP address. If the IP address string came from a user rather than being\nhardcoded into the program and therefore *did* have a possibility of failure,\nwe’d definitely want to handle the `Result` in a more robust way instead.\nMentioning the assumption that this IP address is hardcoded will prompt us to\nchange `expect` to better error handling code if in the future, we need to get\nthe IP address from some other source instead.\n\n### Guidelines for Error Handling\n\nIt’s advisable to have your code panic when it’s possible that your code\ncould end up in a bad state. In this context, a *bad state* is when some\nassumption, guarantee, contract, or invariant has been broken, such as when\ninvalid values, contradictory values, or missing values are passed to your\ncode—plus one or more of the following:\n\n* The bad state is something that is unexpected, as opposed to something that\n  will likely happen occasionally, like a user entering data in the wrong\n  format.\n* Your code after this point needs to rely on not being in this bad state,\n  rather than checking for the problem at every step.\n* There’s not a good way to encode this information in the types you use. We’ll\n  work through an example of what we mean in the [“Encoding States and Behavior\n  as Types”][encoding]<!-- ignore --> section of Chapter 17.\n\nIf someone calls your code and passes in values that don’t make sense, it’s\nbest to return an error if you can so the user of the library can decide what\nthey want to do in that case. However, in cases where continuing could be\ninsecure or harmful, the best choice might be to call `panic!` and alert the\nperson using your library to the bug in their code so they can fix it during\ndevelopment. Similarly, `panic!` is often appropriate if you’re calling\nexternal code that is out of your control and it returns an invalid state that\nyou have no way of fixing.\n\nHowever, when failure is expected, it’s more appropriate to return a `Result`\nthan to make a `panic!` call. Examples include a parser being given malformed\ndata or an HTTP request returning a status that indicates you have hit a rate\nlimit. In these cases, returning a `Result` indicates that failure is an\nexpected possibility that the calling code must decide how to handle.\n\nWhen your code performs an operation that could put a user at risk if it’s\ncalled using invalid values, your code should verify the values are valid first\nand panic if the values aren’t valid. This is mostly for safety reasons:\nattempting to operate on invalid data can expose your code to vulnerabilities.\nThis is the main reason the standard library will call `panic!` if you attempt\nan out-of-bounds memory access: trying to access memory that doesn’t belong to\nthe current data structure is a common security problem. Functions often have\n*contracts*: their behavior is only guaranteed if the inputs meet particular\nrequirements. Panicking when the contract is violated makes sense because a\ncontract violation always indicates a caller-side bug and it’s not a kind of\nerror you want the calling code to have to explicitly handle. In fact, there’s\nno reasonable way for calling code to recover; the calling *programmers* need\nto fix the code. Contracts for a function, especially when a violation will\ncause a panic, should be explained in the API documentation for the function.\n\nHowever, having lots of error checks in all of your functions would be verbose\nand annoying. Fortunately, you can use Rust’s type system (and thus the type\nchecking done by the compiler) to do many of the checks for you. If your\nfunction has a particular type as a parameter, you can proceed with your code’s\nlogic knowing that the compiler has already ensured you have a valid value. For\nexample, if you have a type rather than an `Option`, your program expects to\nhave *something* rather than *nothing*. Your code then doesn’t have to handle\ntwo cases for the `Some` and `None` variants: it will only have one case for\ndefinitely having a value. Code trying to pass nothing to your function won’t\neven compile, so your function doesn’t have to check for that case at runtime.\nAnother example is using an unsigned integer type such as `u32`, which ensures\nthe parameter is never negative.\n\n### Creating Custom Types for Validation\n\nLet’s take the idea of using Rust’s type system to ensure we have a valid value\none step further and look at creating a custom type for validation. Recall the\nguessing game in Chapter 2 in which our code asked the user to guess a number\nbetween 1 and 100. We never validated that the user’s guess was between those\nnumbers before checking it against our secret number; we only validated that\nthe guess was positive. In this case, the consequences were not very dire: our\noutput of “Too high” or “Too low” would still be correct. But it would be a\nuseful enhancement to guide the user toward valid guesses and have different\nbehavior when a user guesses a number that’s out of range versus when a user\ntypes, for example, letters instead.\n\nOne way to do this would be to parse the guess as an `i32` instead of only a\n`u32` to allow potentially negative numbers, and then add a check for the\nnumber being in range, like so:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}\n```\n\nThe `if` expression checks whether our value is out of range, tells the user\nabout the problem, and calls `continue` to start the next iteration of the loop\nand ask for another guess. After the `if` expression, we can proceed with the\ncomparisons between `guess` and the secret number knowing that `guess` is\nbetween 1 and 100.\n\nHowever, this is not an ideal solution: if it was absolutely critical that the\nprogram only operated on values between 1 and 100, and it had many functions\nwith this requirement, having a check like this in every function would be\ntedious (and might impact performance).\n\nInstead, we can make a new type and put the validations in a function to create\nan instance of the type rather than repeating the validations everywhere. That\nway, it’s safe for functions to use the new type in their signatures and\nconfidently use the values they receive. Listing 9-13 shows one way to define a\n`Guess` type that will only create an instance of `Guess` if the `new` function\nreceives a value between 1 and 100.\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile requires the `rand` crate. We do want to include it for reader\nexperimentation purposes, but don't want to include it for rustdoc testing\npurposes. -->\n\n```rust\n{{#include ../listings/ch09-error-handling/listing-09-13/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 9-13: A `Guess` type that will only continue with\nvalues between 1 and 100</span>\n\nFirst, we define a struct named `Guess` that has a field named `value` that\nholds an `i32`. This is where the number will be stored.\n\nThen we implement an associated function named `new` on `Guess` that creates\ninstances of `Guess` values. The `new` function is defined to have one\nparameter named `value` of type `i32` and to return a `Guess`. The code in the\nbody of the `new` function tests `value` to make sure it’s between 1 and 100.\nIf `value` doesn’t pass this test, we make a `panic!` call, which will alert\nthe programmer who is writing the calling code that they have a bug they need\nto fix, because creating a `Guess` with a `value` outside this range would\nviolate the contract that `Guess::new` is relying on. The conditions in which\n`Guess::new` might panic should be discussed in its public-facing API\ndocumentation; we’ll cover documentation conventions indicating the possibility\nof a `panic!` in the API documentation that you create in Chapter 14. If\n`value` does pass the test, we create a new `Guess` with its `value` field set\nto the `value` parameter and return the `Guess`.\n\nNext, we implement a method named `value` that borrows `self`, doesn’t have any\nother parameters, and returns an `i32`. This kind of method is sometimes called\na *getter*, because its purpose is to get some data from its fields and return\nit. This public method is necessary because the `value` field of the `Guess`\nstruct is private. It’s important that the `value` field be private so code\nusing the `Guess` struct is not allowed to set `value` directly: code outside\nthe module *must* use the `Guess::new` function to create an instance of\n`Guess`, thereby ensuring there’s no way for a `Guess` to have a `value` that\nhasn’t been checked by the conditions in the `Guess::new` function.\n\nA function that has a parameter or returns only numbers between 1 and 100 could\nthen declare in its signature that it takes or returns a `Guess` rather than an\n`i32` and wouldn’t need to do any additional checks in its body.\n\n## Summary\n\nRust’s error handling features are designed to help you write more robust code.\nThe `panic!` macro signals that your program is in a state it can’t handle and\nlets you tell the process to stop instead of trying to proceed with invalid or\nincorrect values. The `Result` enum uses Rust’s type system to indicate that\noperations might fail in a way that your code could recover from. You can use\n`Result` to tell code that calls your code that it needs to handle potential\nsuccess or failure as well. Using `panic!` and `Result` in the appropriate\nsituations will make your code more reliable in the face of inevitable problems.\n\nNow that you’ve seen useful ways that the standard library uses generics with\nthe `Option` and `Result` enums, we’ll talk about how generics work and how you\ncan use them in your code.\n\n[encoding]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types\n",
          "document_id": 46
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What are generics?",
              "id": 2013,
              "answers": [
                {
                  "answer_id": 2013,
                  "document_id": 47,
                  "question_id": 2013,
                  "text": "abstract stand-ins for\nconcrete types or other properties",
                  "answer_start": 169,
                  "answer_end": 226,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are the examples of generics?",
              "id": 2014,
              "answers": [
                {
                  "answer_id": 2036,
                  "document_id": 47,
                  "question_id": 2014,
                  "text": "`Option‹T>`, Chapter 8 with `Vec‹T>`\nand `HashMap‹K, V>`, and Chapter 9 with `Result‹T, E>",
                  "answer_start": 659,
                  "answer_end": 749,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the advantage of using generics?",
              "id": 2015,
              "answers": [
                {
                  "answer_id": 2015,
                  "document_id": 47,
                  "question_id": 2015,
                  "text": "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
                  "answer_start": 1736,
                  "answer_end": 1857,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I restrict a generic type?",
              "id": 2016,
              "answers": [
                {
                  "answer_id": 2016,
                  "document_id": 47,
                  "question_id": 2016,
                  "text": "You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior, as opposed to just any type.",
                  "answer_start": 1210,
                  "answer_end": 1368,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are lifetimes in context of generics?",
              "id": 2017,
              "answers": [
                {
                  "answer_id": 2017,
                  "document_id": 47,
                  "question_id": 2017,
                  "text": "a variety of generics that give the\ncompiler information about how references relate to each other.",
                  "answer_start": 1406,
                  "answer_end": 1505,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I avoid duplicating code without the usage of generics?",
              "id": 2018,
              "answers": [
                {
                  "answer_id": 2018,
                  "document_id": 47,
                  "question_id": 2018,
                  "text": "by extracting a function that replaces specific values\nwith a placeholder that represents multiple values",
                  "answer_start": 1990,
                  "answer_end": 2095,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why is it bad to duplicate code?",
              "id": 2033,
              "answers": [
                {
                  "answer_id": 2037,
                  "document_id": 47,
                  "question_id": 2033,
                  "text": "duplicating code is tedious and error prone",
                  "answer_start": 3798,
                  "answer_end": 3841,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to eliminate code duplication?",
              "id": 2034,
              "answers": [
                {
                  "answer_id": 2038,
                  "document_id": 47,
                  "question_id": 2034,
                  "text": "create an abstraction by defining a\nfunction",
                  "answer_start": 3971,
                  "answer_end": 4015,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "# Generic Types, Traits, and Lifetimes\n\nEvery programming language has tools for effectively handling the duplication\nof concepts. In Rust, one such tool is *generics*: abstract stand-ins for\nconcrete types or other properties. We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.\n\nFunctions can take parameters of some generic type, instead of a concrete type\nlike `i32` or `String`, in the same way a function takes parameters with\nunknown values to run the same code on multiple concrete values. In fact, we’ve\nalready used generics in Chapter 6 with `Option<T>`, Chapter 8 with `Vec<T>`\nand `HashMap<K, V>`, and Chapter 9 with `Result<T, E>`. In this chapter, you’ll\nexplore how to define your own types, functions, and methods with generics!\n\nFirst, we’ll review how to extract a function to reduce code duplication. We’ll\nthen use the same technique to make a generic function from two functions that\ndiffer only in the types of their parameters. We’ll also explain how to use\ngeneric types in struct and enum definitions.\n\nThen you’ll learn how to use *traits* to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior, as opposed to just any type.\n\nFinally, we’ll discuss *lifetimes*: a variety of generics that give the\ncompiler information about how references relate to each other. Lifetimes allow\nus to give the compiler enough information about borrowed values so that it can\nensure references will be valid in more situations than it could without our\nhelp.\n\n## Removing Duplication by Extracting a Function\n\nGenerics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication. Before diving into generics syntax,\nthen, let’s first look at how to remove duplication in a way that doesn’t\ninvolve generic types by extracting a function that replaces specific values\nwith a placeholder that represents multiple values. Then we’ll apply the same\ntechnique to extract a generic function! By looking at how to recognize\nduplicated code you can extract into a function, you’ll start to recognize\nduplicated code that can use generics.\n\nWe begin with the short program in Listing 10-1 that finds the largest number\nin a list.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-01/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-1: Finding the largest number in a list of\nnumbers</span>\n\nWe store a list of integers in the variable `number_list` and place a reference\nto the first number in the list in a variable named `largest`. We then iterate\nthrough all the numbers in the list, and if the current number is greater than\nthe number stored in `largest`, replace the reference in that variable.\nHowever, if the current number is less than or equal to the largest number seen\nso far, the variable doesn’t change, and the code moves on to the next number\nin the list. After considering all the numbers in the list, `largest` should\nrefer to the largest number, which in this case is 100.\n\nWe've now been tasked with finding the largest number in two different lists of\nnumbers. To do so, we can choose to duplicate the code in Listing 10-1 and use\nthe same logic at two different places in the program, as shown in Listing 10-2.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-02/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-2: Code to find the largest number in *two*\nlists of numbers</span>\n\nAlthough this code works, duplicating code is tedious and error prone. We also\nhave to remember to update the code in multiple places when we want to change\nit.\n\nTo eliminate this duplication, we’ll create an abstraction by defining a\nfunction that operates on any list of integers passed in a parameter. This\nsolution makes our code clearer and lets us express the concept of finding the\nlargest number in a list abstractly.\n\nIn Listing 10-3, we extract the code that finds the largest number into a\nfunction named `largest`. Then we call the function to find the largest number\nin the two lists from Listing 10-2. We could also use the function on any other\nlist of `i32` values we might have in the future.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-03/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-3: Abstracted code to find the largest number\nin two lists</span>\n\nThe `largest` function has a parameter called `list`, which represents any\nconcrete slice of `i32` values we might pass into the function. As a result,\nwhen we call the function, the code runs on the specific values that we pass\nin.\n\nIn summary, here are the steps we took to change the code from Listing 10-2 to\nListing 10-3:\n\n1. Identify duplicate code.\n2. Extract the duplicate code into the body of the function and specify the\n   inputs and return values of that code in the function signature.\n3. Update the two instances of duplicated code to call the function instead.\n\nNext, we’ll use these same steps with generics to reduce code duplication. In\nthe same way that the function body can operate on an abstract `list` instead\nof specific values, generics allow code to operate on abstract types.\n\nFor example, say we had two functions: one that finds the largest item in a\nslice of `i32` values and one that finds the largest item in a slice of `char`\nvalues. How would we eliminate that duplication? Let’s find out!\n",
          "document_id": 47
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What can be used for creating function signatures?",
              "id": 2035,
              "answers": [
                {
                  "answer_id": 2039,
                  "document_id": 48,
                  "question_id": 2035,
                  "text": "Generic Data Types",
                  "answer_start": 3,
                  "answer_end": 21,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are generics used for?",
              "id": 2036,
              "answers": [
                {
                  "answer_id": 2040,
                  "document_id": 48,
                  "question_id": 2036,
                  "text": "to create definitions for items like function signatures or\nstructs, which we can then use with many different concrete data types",
                  "answer_start": 39,
                  "answer_end": 169,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What can be defined using generics?",
              "id": 2037,
              "answers": [
                {
                  "answer_id": 2041,
                  "document_id": 48,
                  "question_id": 2037,
                  "text": "functions, structs, enums, and methods",
                  "answer_start": 205,
                  "answer_end": 243,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Where should the generic be placed?",
              "id": 2038,
              "answers": [
                {
                  "answer_id": 2042,
                  "document_id": 48,
                  "question_id": 2038,
                  "text": "we place the generics in the\nsignature of the function where we would usually specify the data types of the\nparameters and return value",
                  "answer_start": 392,
                  "answer_end": 527,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How should generics be named in code?",
              "id": 2039,
              "answers": [
                {
                  "answer_id": 2043,
                  "document_id": 48,
                  "question_id": 2039,
                  "text": "by\nconvention, type parameter names in Rust are short, often just a letter",
                  "answer_start": 1676,
                  "answer_end": 1750,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which naming convention is used in Rust?",
              "id": 2040,
              "answers": [
                {
                  "answer_id": 2044,
                  "document_id": 48,
                  "question_id": 2040,
                  "text": "UpperCamelCase",
                  "answer_start": 1789,
                  "answer_end": 1803,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does 'T' in generics stand for?",
              "id": 2041,
              "answers": [
                {
                  "answer_id": 2045,
                  "document_id": 48,
                  "question_id": 2041,
                  "text": "Short for “type,”",
                  "answer_start": 1805,
                  "answer_end": 1822,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to declare generic function?",
              "id": 2042,
              "answers": [
                {
                  "answer_id": 2046,
                  "document_id": 48,
                  "question_id": 2042,
                  "text": "place type name declarations inside angle brackets, `‹>`,\nbetween the name of the function and the parameter list",
                  "answer_start": 2201,
                  "answer_end": 2314,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Provide an example of generic function.",
              "id": 2043,
              "answers": [
                {
                  "answer_id": 2047,
                  "document_id": 48,
                  "question_id": 2043,
                  "text": "fn largest‹T>(list: &[T]) -> &T",
                  "answer_start": 2343,
                  "answer_end": 2374,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I use struct in generic function?",
              "id": 2044,
              "answers": [
                {
                  "answer_id": 2048,
                  "document_id": 48,
                  "question_id": 2044,
                  "text": "First, we declare the name of the type parameter inside\nangle brackets just after the name of the struct. Then we use the generic type\nin the struct definition where we would otherwise specify concrete data types.",
                  "answer_start": 4733,
                  "answer_end": 4946,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can I use generics in enum?",
              "id": 2045,
              "answers": [
                {
                  "answer_id": 2049,
                  "document_id": 48,
                  "question_id": 2045,
                  "text": "we can define enums to hold generic data types in their\nvariants",
                  "answer_start": 6990,
                  "answer_end": 7054,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can using generics make code slower?",
              "id": 2046,
              "answers": [
                {
                  "answer_id": 2050,
                  "document_id": 48,
                  "question_id": 2046,
                  "text": "using generic types won't make your program run\nany slower than it would with concrete types",
                  "answer_start": 12740,
                  "answer_end": 12832,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is monomorphization?",
              "id": 2047,
              "answers": [
                {
                  "answer_id": 2051,
                  "document_id": 48,
                  "question_id": 2047,
                  "text": "the process of turning generic\ncode into specific code by filling in the concrete types that are used when\ncompiled",
                  "answer_start": 12955,
                  "answer_end": 13070,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What can be an example of enum with generics?",
              "id": 2048,
              "answers": [
                {
                  "answer_id": 2052,
                  "document_id": 48,
                  "question_id": 2048,
                  "text": "enum Option‹T> {\n    Some(T),\n    None,\n}",
                  "answer_start": 7177,
                  "answer_end": 7218,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Generic Data Types\n\nWe use generics to create definitions for items like function signatures or\nstructs, which we can then use with many different concrete data types. Let’s\nfirst look at how to define functions, structs, enums, and methods using\ngenerics. Then we’ll discuss how generics affect code performance.\n\n### In Function Definitions\n\nWhen defining a function that uses generics, we place the generics in the\nsignature of the function where we would usually specify the data types of the\nparameters and return value. Doing so makes our code more flexible and provides\nmore functionality to callers of our function while preventing code duplication.\n\nContinuing with our `largest` function, Listing 10-4 shows two functions that\nboth find the largest value in a slice. We'll then combine these into a single\nfunction that uses generics.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-4: Two functions that differ only in their\nnames and the types in their signatures</span>\n\nThe `largest_i32` function is the one we extracted in Listing 10-3 that finds\nthe largest `i32` in a slice. The `largest_char` function finds the largest\n`char` in a slice. The function bodies have the same code, so let’s eliminate\nthe duplication by introducing a generic type parameter in a single function.\n\nTo parameterize the types in a new single function, we need to name the type\nparameter, just as we do for the value parameters to a function. You can use\nany identifier as a type parameter name. But we’ll use `T` because, by\nconvention, type parameter names in Rust are short, often just a letter, and\nRust’s type-naming convention is UpperCamelCase. Short for “type,” `T` is the\ndefault choice of most Rust programmers.\n\nWhen we use a parameter in the body of the function, we have to declare the\nparameter name in the signature so the compiler knows what that name means.\nSimilarly, when we use a type parameter name in a function signature, we have\nto declare the type parameter name before we use it. To define the generic\n`largest` function, place type name declarations inside angle brackets, `<>`,\nbetween the name of the function and the parameter list, like this:\n\n```rust,ignore\nfn largest<T>(list: &[T]) -> &T {\n```\n\nWe read this definition as: the function `largest` is generic over some type\n`T`. This function has one parameter named `list`, which is a slice of values\nof type `T`. The `largest` function will return a reference to a value of the\nsame type `T`.\n\nListing 10-5 shows the combined `largest` function definition using the generic\ndata type in its signature. The listing also shows how we can call the function\nwith either a slice of `i32` values or `char` values. Note that this code won’t\ncompile yet, but we’ll fix it later in this chapter.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-5: The `largest` function using generic type\nparameters; this doesn’t yet compile</span>\n\nIf we compile this code right now, we’ll get this error:\n\n```console\n{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}\n```\n\nThe help text mentions `std::cmp::PartialOrd`, which is a *trait*, and we’re\ngoing to talk about traits in the next section. For now, know that this error\nstates that the body of `largest` won’t work for all possible types that `T`\ncould be. Because we want to compare values of type `T` in the body, we can\nonly use types whose values can be ordered. To enable comparisons, the standard\nlibrary has the `std::cmp::PartialOrd` trait that you can implement on types\n(see Appendix C for more on this trait). By following the help text's\nsuggestion, we restrict the types valid for `T` to only those that implement\n`PartialOrd` and this example will compile, because the standard library\nimplements `PartialOrd` on both `i32` and `char`.\n\n### In Struct Definitions\n\nWe can also define structs to use a generic type parameter in one or more\nfields using the `<>` syntax. Listing 10-6 defines a `Point<T>` struct to hold\n`x` and `y` coordinate values of any type.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-6: A `Point<T>` struct that holds `x` and `y`\nvalues of type `T`</span>\n\nThe syntax for using generics in struct definitions is similar to that used in\nfunction definitions. First, we declare the name of the type parameter inside\nangle brackets just after the name of the struct. Then we use the generic type\nin the struct definition where we would otherwise specify concrete data types.\n\nNote that because we’ve used only one generic type to define `Point<T>`, this\ndefinition says that the `Point<T>` struct is generic over some type `T`, and\nthe fields `x` and `y` are *both* that same type, whatever that type may be. If\nwe create an instance of a `Point<T>` that has values of different types, as in\nListing 10-7, our code won’t compile.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-7: The fields `x` and `y` must be the same\ntype because both have the same generic data type `T`.</span>\n\nIn this example, when we assign the integer value 5 to `x`, we let the compiler\nknow that the generic type `T` will be an integer for this instance of\n`Point<T>`. Then when we specify 4.0 for `y`, which we’ve defined to have the\nsame type as `x`, we’ll get a type mismatch error like this:\n\n```console\n{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}\n```\n\nTo define a `Point` struct where `x` and `y` are both generics but could have\ndifferent types, we can use multiple generic type parameters. For example, in\nListing 10-8, we change the definition of `Point` to be generic over types `T`\nand `U` where `x` is of type `T` and `y` is of type `U`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-8: A `Point<T, U>` generic over two types so\nthat `x` and `y` can be values of different types</span>\n\nNow all the instances of `Point` shown are allowed! You can use as many generic\ntype parameters in a definition as you want, but using more than a few makes\nyour code hard to read. If you're finding you need lots of generic types in\nyour code, it could indicate that your code needs restructuring into smaller\npieces.\n\n### In Enum Definitions\n\nAs we did with structs, we can define enums to hold generic data types in their\nvariants. Let’s take another look at the `Option<T>` enum that the standard\nlibrary provides, which we used in Chapter 6:\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n```\n\nThis definition should now make more sense to you. As you can see, the\n`Option<T>` enum is generic over type `T` and has two variants: `Some`, which\nholds one value of type `T`, and a `None` variant that doesn’t hold any value.\nBy using the `Option<T>` enum, we can express the abstract concept of an\noptional value, and because `Option<T>` is generic, we can use this abstraction\nno matter what the type of the optional value is.\n\nEnums can use multiple generic types as well. The definition of the `Result`\nenum that we used in Chapter 9 is one example:\n\n```rust\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\nThe `Result` enum is generic over two types, `T` and `E`, and has two variants:\n`Ok`, which holds a value of type `T`, and `Err`, which holds a value of type\n`E`. This definition makes it convenient to use the `Result` enum anywhere we\nhave an operation that might succeed (return a value of some type `T`) or fail\n(return an error of some type `E`). In fact, this is what we used to open a\nfile in Listing 9-3, where `T` was filled in with the type `std::fs::File` when\nthe file was opened successfully and `E` was filled in with the type\n`std::io::Error` when there were problems opening the file.\n\nWhen you recognize situations in your code with multiple struct or enum\ndefinitions that differ only in the types of the values they hold, you can\navoid duplication by using generic types instead.\n\n### In Method Definitions\n\nWe can implement methods on structs and enums (as we did in Chapter 5) and use\ngeneric types in their definitions, too. Listing 10-9 shows the `Point<T>`\nstruct we defined in Listing 10-6 with a method named `x` implemented on it.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-9: Implementing a method named `x` on the\n`Point<T>` struct that will return a reference to the `x` field of type\n`T`</span>\n\nHere, we’ve defined a method named `x` on `Point<T>` that returns a reference\nto the data in the field `x`.\n\nNote that we have to declare `T` just after `impl` so we can use `T` to specify\nthat we’re implementing methods on the type `Point<T>`. By declaring `T` as a\ngeneric type after `impl`, Rust can identify that the type in the angle\nbrackets in `Point` is a generic type rather than a concrete type. We could\nhave chosen a different name for this generic parameter than the generic\nparameter declared in the struct definition, but using the same name is\nconventional. Methods written within an `impl` that declares the generic type\nwill be defined on any instance of the type, no matter what concrete type ends\nup substituting for the generic type.\n\nWe can also specify constraints on generic types when defining methods on the\ntype. We could, for example, implement methods only on `Point<f32>` instances\nrather than on `Point<T>` instances with any generic type. In Listing 10-10 we\nuse the concrete type `f32`, meaning we don’t declare any types after `impl`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-10: An `impl` block that only applies to a\nstruct with a particular concrete type for the generic type parameter `T`</span>\n\nThis code means the type `Point<f32>` will have a `distance_from_origin`\nmethod; other instances of `Point<T>` where `T` is not of type `f32` will not\nhave this method defined. The method measures how far our point is from the\npoint at coordinates (0.0, 0.0) and uses mathematical operations that are\navailable only for floating point types.\n\nGeneric type parameters in a struct definition aren’t always the same as those\nyou use in that same struct’s method signatures. Listing 10-11 uses the generic\ntypes `X1` and `Y1` for the `Point` struct and `X2` `Y2` for the `mixup` method\nsignature to make the example clearer. The method creates a new `Point`\ninstance with the `x` value from the `self` `Point` (of type `X1`) and the `y`\nvalue from the passed-in `Point` (of type `Y2`).\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-11: A method that uses generic types different\nfrom its struct’s definition</span>\n\nIn `main`, we’ve defined a `Point` that has an `i32` for `x` (with value `5`)\nand an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct\nthat has a string slice for `x` (with value `\"Hello\"`) and a `char` for `y`\n(with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`,\nwhich will have an `i32` for `x`, because `x` came from `p1`. The `p3` variable\nwill have a `char` for `y`, because `y` came from `p2`. The `println!` macro\ncall will print `p3.x = 5, p3.y = c`.\n\nThe purpose of this example is to demonstrate a situation in which some generic\nparameters are declared with `impl` and some are declared with the method\ndefinition. Here, the generic parameters `X1` and `Y1` are declared after\n`impl` because they go with the struct definition. The generic parameters `X2`\nand `Y2` are declared after `fn mixup`, because they’re only relevant to the\nmethod.\n\n### Performance of Code Using Generics\n\nYou might be wondering whether there is a runtime cost when using generic type\nparameters. The good news is that using generic types won't make your program run\nany slower than it would with concrete types.\n\nRust accomplishes this by performing monomorphization of the code using\ngenerics at compile time. *Monomorphization* is the process of turning generic\ncode into specific code by filling in the concrete types that are used when\ncompiled. In this process, the compiler does the opposite of the steps we used\nto create the generic function in Listing 10-5: the compiler looks at all the\nplaces where generic code is called and generates code for the concrete types\nthe generic code is called with.\n\nLet’s look at how this works by using the standard library’s generic\n`Option<T>` enum:\n\n```rust\nlet integer = Some(5);\nlet float = Some(5.0);\n```\n\nWhen Rust compiles this code, it performs monomorphization. During that\nprocess, the compiler reads the values that have been used in `Option<T>`\ninstances and identifies two kinds of `Option<T>`: one is `i32` and the other\nis `f64`. As such, it expands the generic definition of `Option<T>` into two\ndefinitions specialized to `i32` and `f64`, thereby replacing the generic\ndefinition with the specific ones.\n\nThe monomorphized version of the code looks similar to the following (the\ncompiler uses different names than what we’re using here for illustration):\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\nenum Option_i32 {\n    Some(i32),\n    None,\n}\n\nenum Option_f64 {\n    Some(f64),\n    None,\n}\n\nfn main() {\n    let integer = Option_i32::Some(5);\n    let float = Option_f64::Some(5.0);\n}\n```\n\nThe generic `Option<T>` is replaced with the specific definitions created by\nthe compiler. Because Rust compiles generic code into code that specifies the\ntype in each instance, we pay no runtime cost for using generics. When the code\nruns, it performs just as it would if we had duplicated each definition by\nhand. The process of monomorphization makes Rust’s generics extremely efficient\nat runtime.\n",
          "document_id": 48
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What are traits used for?",
              "id": 2049,
              "answers": [
                {
                  "answer_id": 2053,
                  "document_id": 49,
                  "question_id": 2049,
                  "text": "Defining Shared Behavior",
                  "answer_start": 11,
                  "answer_end": 35,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are traits?",
              "id": 2050,
              "answers": [
                {
                  "answer_id": 2054,
                  "document_id": 49,
                  "question_id": 2050,
                  "text": "A *trait* defines functionality a particular type has and can share with other\ntypes.",
                  "answer_start": 37,
                  "answer_end": 122,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can different types share the same behavior?",
              "id": 2051,
              "answers": [
                {
                  "answer_id": 2055,
                  "document_id": 49,
                  "question_id": 2051,
                  "text": "Different\ntypes share the same behavior if we can call the same methods on all of those\ntypes",
                  "answer_start": 499,
                  "answer_end": 592,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to declare a trait?",
              "id": 2052,
              "answers": [
                {
                  "answer_id": 2056,
                  "document_id": 49,
                  "question_id": 2052,
                  "text": "we declare a trait using the `trait` keyword and then the trait’s name",
                  "answer_start": 1743,
                  "answer_end": 1813,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to implement a trait?",
              "id": 2053,
              "answers": [
                {
                  "answer_id": 2057,
                  "document_id": 49,
                  "question_id": 2053,
                  "text": "Implementing a trait on a type is similar to implementing regular methods. The\ndifference is that after `impl`, we put the trait name we want to implement,\nthen use the `for` keyword, and then specify the name of the type we want to\nimplement the trait for.",
                  "answer_start": 3480,
                  "answer_end": 3737,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is used after trait signature?",
              "id": 2054,
              "answers": [
                {
                  "answer_id": 2058,
                  "document_id": 49,
                  "question_id": 2054,
                  "text": "curly brackets",
                  "answer_start": 3890,
                  "answer_end": 3904,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What restrictions are used in traits?",
              "id": 2055,
              "answers": [
                {
                  "answer_id": 2059,
                  "document_id": 49,
                  "question_id": 2055,
                  "text": "we can implement a trait on a type only if at least one of the\ntrait or the type is local to our crate.",
                  "answer_start": 4830,
                  "answer_end": 4933,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is it possible to implement external traits?",
              "id": 2056,
              "answers": [
                {
                  "answer_id": 2060,
                  "document_id": 49,
                  "question_id": 2056,
                  "text": "we can’t implement external traits on external types.",
                  "answer_start": 5283,
                  "answer_end": 5336,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the orphan rule?",
              "id": 2057,
              "answers": [
                {
                  "answer_id": 2061,
                  "document_id": 49,
                  "question_id": 2057,
                  "text": "the parent type is not present",
                  "answer_start": 5665,
                  "answer_end": 5695,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does the orphan rule prevent from?",
              "id": 2058,
              "answers": [
                {
                  "answer_id": 2062,
                  "document_id": 49,
                  "question_id": 2058,
                  "text": "ensures that other people’s code\ncan’t break your code and vice versa",
                  "answer_start": 5707,
                  "answer_end": 5776,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I establish default behavior for few methods?",
              "id": 2059,
              "answers": [
                {
                  "answer_id": 2063,
                  "document_id": 49,
                  "question_id": 2059,
                  "text": "in a trait instead of requiring implementations for all methods on every type",
                  "answer_start": 6017,
                  "answer_end": 6094,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is it possible to override default behavior of a method?",
              "id": 2060,
              "answers": [
                {
                  "answer_id": 2064,
                  "document_id": 49,
                  "question_id": 2060,
                  "text": "we can keep or override\neach method’s default behavior",
                  "answer_start": 6150,
                  "answer_end": 6204,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I set more than 1 trait bound?",
              "id": 2061,
              "answers": [
                {
                  "answer_id": 2065,
                  "document_id": 49,
                  "question_id": 2061,
                  "text": "with the `+` Syntax",
                  "answer_start": 11967,
                  "answer_end": 11986,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is  \"+\" syntax valid on generics?",
              "id": 2062,
              "answers": [
                {
                  "answer_id": 2066,
                  "document_id": 49,
                  "question_id": 2062,
                  "text": "The `+` syntax is also valid with trait bounds on generic types",
                  "answer_start": 12318,
                  "answer_end": 12381,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to return a value of type that implements a trait?",
              "id": 2063,
              "answers": [
                {
                  "answer_id": 2067,
                  "document_id": 49,
                  "question_id": 2063,
                  "text": "use the `impl Trait` syntax in the return position",
                  "answer_start": 13541,
                  "answer_end": 13591,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can I use 'impl Trait' when I return multiple types?",
              "id": 2064,
              "answers": [
                {
                  "answer_id": 2068,
                  "document_id": 49,
                  "question_id": 2064,
                  "text": "you can only use `impl Trait` if you’re returning a single type",
                  "answer_start": 14558,
                  "answer_end": 14621,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are blanket implementations?",
              "id": 2065,
              "answers": [
                {
                  "answer_id": 2069,
                  "document_id": 49,
                  "question_id": 2065,
                  "text": "Implementations of a trait on any type that satisfies the trait\nbounds",
                  "answer_start": 16429,
                  "answer_end": 16499,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Where are blanket implementations used?",
              "id": 2066,
              "answers": [
                {
                  "answer_id": 2070,
                  "document_id": 49,
                  "question_id": 2066,
                  "text": "in the\nRust standard library",
                  "answer_start": 16562,
                  "answer_end": 16590,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Traits: Defining Shared Behavior\n\nA *trait* defines functionality a particular type has and can share with other\ntypes. We can use traits to define shared behavior in an abstract way. We can\nuse *trait bounds* to specify that a generic type can be any type that has\ncertain behavior.\n\n> Note: Traits are similar to a feature often called *interfaces* in other\n> languages, although with some differences.\n\n### Defining a Trait\n\nA type’s behavior consists of the methods we can call on that type. Different\ntypes share the same behavior if we can call the same methods on all of those\ntypes. Trait definitions are a way to group method signatures together to\ndefine a set of behaviors necessary to accomplish some purpose.\n\nFor example, let’s say we have multiple structs that hold various kinds and\namounts of text: a `NewsArticle` struct that holds a news story filed in a\nparticular location and a `Tweet` that can have at most 280 characters along\nwith metadata that indicates whether it was a new tweet, a retweet, or a reply\nto another tweet.\n\nWe want to make a media aggregator library crate named `aggregator` that can\ndisplay summaries of data that might be stored in a `NewsArticle` or `Tweet`\ninstance. To do this, we need a summary from each type, and we’ll request\nthat summary by calling a `summarize` method on an instance. Listing 10-12\nshows the definition of a public `Summary` trait that expresses this behavior.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 10-12: A `Summary` trait that consists of the\nbehavior provided by a `summarize` method</span>\n\nHere, we declare a trait using the `trait` keyword and then the trait’s name,\nwhich is `Summary` in this case. We’ve also declared the trait as `pub` so that\ncrates depending on this crate can make use of this trait too, as we’ll see in\na few examples. Inside the curly brackets, we declare the method signatures\nthat describe the behaviors of the types that implement this trait, which in\nthis case is `fn summarize(&self) -> String`.\n\nAfter the method signature, instead of providing an implementation within curly\nbrackets, we use a semicolon. Each type implementing this trait must provide\nits own custom behavior for the body of the method. The compiler will enforce\nthat any type that has the `Summary` trait will have the method `summarize`\ndefined with this signature exactly.\n\nA trait can have multiple methods in its body: the method signatures are listed\none per line and each line ends in a semicolon.\n\n### Implementing a Trait on a Type\n\nNow that we’ve defined the desired signatures of the `Summary` trait’s methods,\nwe can implement it on the types in our media aggregator. Listing 10-13 shows\nan implementation of the `Summary` trait on the `NewsArticle` struct that uses\nthe headline, the author, and the location to create the return value of\n`summarize`. For the `Tweet` struct, we define `summarize` as the username\nfollowed by the entire text of the tweet, assuming that tweet content is\nalready limited to 280 characters.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-13: Implementing the `Summary` trait on the\n`NewsArticle` and `Tweet` types</span>\n\nImplementing a trait on a type is similar to implementing regular methods. The\ndifference is that after `impl`, we put the trait name we want to implement,\nthen use the `for` keyword, and then specify the name of the type we want to\nimplement the trait for. Within the `impl` block, we put the method signatures\nthat the trait definition has defined. Instead of adding a semicolon after each\nsignature, we use curly brackets and fill in the method body with the specific\nbehavior that we want the methods of the trait to have for the particular type.\n\nNow that the library has implemented the `Summary` trait on `NewsArticle` and\n`Tweet`, users of the crate can call the trait methods on instances of\n`NewsArticle` and `Tweet` in the same way we call regular methods. The only\ndifference is that the user must bring the trait into scope as well as the\ntypes. Here’s an example of how a binary crate could use our `aggregator`\nlibrary crate:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}\n```\n\nThis code prints `1 new tweet: horse_ebooks: of course, as you probably already\nknow, people`.\n\nOther crates that depend on the `aggregator` crate can also bring the `Summary`\ntrait into scope to implement `Summary` on their own types. One restriction to\nnote is that we can implement a trait on a type only if at least one of the\ntrait or the type is local to our crate. For example, we can implement standard\nlibrary traits like `Display` on a custom type like `Tweet` as part of our\n`aggregator` crate functionality, because the type `Tweet` is local to our\n`aggregator` crate. We can also implement `Summary` on `Vec<T>` in our\n`aggregator` crate, because the trait `Summary` is local to our `aggregator`\ncrate.\n\nBut we can’t implement external traits on external types. For example, we can’t\nimplement the `Display` trait on `Vec<T>` within our `aggregator` crate,\nbecause `Display` and `Vec<T>` are both defined in the standard library and\naren’t local to our `aggregator` crate. This restriction is part of a property\ncalled *coherence*, and more specifically the *orphan rule*, so named because\nthe parent type is not present. This rule ensures that other people’s code\ncan’t break your code and vice versa. Without the rule, two crates could\nimplement the same trait for the same type, and Rust wouldn’t know which\nimplementation to use.\n\n### Default Implementations\n\nSometimes it’s useful to have default behavior for some or all of the methods\nin a trait instead of requiring implementations for all methods on every type.\nThen, as we implement the trait on a particular type, we can keep or override\neach method’s default behavior.\n\nIn Listing 10-14 we specify a default string for the `summarize` method of the\n`Summary` trait instead of only defining the method signature, as we did in\nListing 10-12.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-14: Defining a `Summary` trait with a default\nimplementation of the `summarize` method</span>\n\nTo use a default implementation to summarize instances of `NewsArticle`, we\nspecify an empty `impl` block with `impl Summary for NewsArticle {}`.\n\nEven though we’re no longer defining the `summarize` method on `NewsArticle`\ndirectly, we’ve provided a default implementation and specified that\n`NewsArticle` implements the `Summary` trait. As a result, we can still call\nthe `summarize` method on an instance of `NewsArticle`, like this:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}\n```\n\nThis code prints `New article available! (Read more...)`.\n\nCreating a default implementation doesn’t require us to change anything about\nthe implementation of `Summary` on `Tweet` in Listing 10-13. The reason is that\nthe syntax for overriding a default implementation is the same as the syntax\nfor implementing a trait method that doesn’t have a default implementation.\n\nDefault implementations can call other methods in the same trait, even if those\nother methods don’t have a default implementation. In this way, a trait can\nprovide a lot of useful functionality and only require implementors to specify\na small part of it. For example, we could define the `Summary` trait to have a\n`summarize_author` method whose implementation is required, and then define a\n`summarize` method that has a default implementation that calls the\n`summarize_author` method:\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}\n```\n\nTo use this version of `Summary`, we only need to define `summarize_author`\nwhen we implement the trait on a type:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}\n```\n\nAfter we define `summarize_author`, we can call `summarize` on instances of the\n`Tweet` struct, and the default implementation of `summarize` will call the\ndefinition of `summarize_author` that we’ve provided. Because we’ve implemented\n`summarize_author`, the `Summary` trait has given us the behavior of the\n`summarize` method without requiring us to write any more code.\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}\n```\n\nThis code prints `1 new tweet: (Read more from @horse_ebooks...)`.\n\nNote that it isn’t possible to call the default implementation from an\noverriding implementation of that same method.\n\n### Traits as Parameters\n\nNow that you know how to define and implement traits, we can explore how to use\ntraits to define functions that accept many different types. We'll use the\n`Summary` trait we implemented on the `NewsArticle` and `Tweet` types in\nListing 10-13 to define a `notify` function that calls the `summarize` method\non its `item` parameter, which is of some type that implements the `Summary`\ntrait. To do this, we use the `impl Trait` syntax, like this:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}\n```\n\nInstead of a concrete type for the `item` parameter, we specify the `impl`\nkeyword and the trait name. This parameter accepts any type that implements the\nspecified trait. In the body of `notify`, we can call any methods on `item`\nthat come from the `Summary` trait, such as `summarize`. We can call `notify`\nand pass in any instance of `NewsArticle` or `Tweet`. Code that calls the\nfunction with any other type, such as a `String` or an `i32`, won’t compile\nbecause those types don’t implement `Summary`.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"fixing-the-largest-function-with-trait-bounds\"></a>\n\n#### Trait Bound Syntax\n\nThe `impl Trait` syntax works for straightforward cases but is actually syntax\nsugar for a longer form known as a *trait bound*; it looks like this:\n\n```rust,ignore\npub fn notify<T: Summary>(item: &T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n```\n\nThis longer form is equivalent to the example in the previous section but is\nmore verbose. We place trait bounds with the declaration of the generic type\nparameter after a colon and inside angle brackets.\n\nThe `impl Trait` syntax is convenient and makes for more concise code in simple\ncases, while the fuller trait bound syntax can express more complexity in other\ncases. For example, we can have two parameters that implement `Summary`. Doing\nso with the `impl Trait` syntax looks like this:\n\n```rust,ignore\npub fn notify(item1: &impl Summary, item2: &impl Summary) {\n```\n\nUsing `impl Trait` is appropriate if we want this function to allow `item1` and\n`item2` to have different types (as long as both types implement `Summary`). If\nwe want to force both parameters to have the same type, however, we must use a\ntrait bound, like this:\n\n```rust,ignore\npub fn notify<T: Summary>(item1: &T, item2: &T) {\n```\n\nThe generic type `T` specified as the type of the `item1` and `item2`\nparameters constrains the function such that the concrete type of the value\npassed as an argument for `item1` and `item2` must be the same.\n\n#### Specifying Multiple Trait Bounds with the `+` Syntax\n\nWe can also specify more than one trait bound. Say we wanted `notify` to use\ndisplay formatting as well as `summarize` on `item`: we specify in the `notify`\ndefinition that `item` must implement both `Display` and `Summary`. We can do\nso using the `+` syntax:\n\n```rust,ignore\npub fn notify(item: &(impl Summary + Display)) {\n```\n\nThe `+` syntax is also valid with trait bounds on generic types:\n\n```rust,ignore\npub fn notify<T: Summary + Display>(item: &T) {\n```\n\nWith the two trait bounds specified, the body of `notify` can call `summarize`\nand use `{}` to format `item`.\n\n#### Clearer Trait Bounds with `where` Clauses\n\nUsing too many trait bounds has its downsides. Each generic has its own trait\nbounds, so functions with multiple generic type parameters can contain lots of\ntrait bound information between the function’s name and its parameter list,\nmaking the function signature hard to read. For this reason, Rust has alternate\nsyntax for specifying trait bounds inside a `where` clause after the function\nsignature. So instead of writing this:\n\n```rust,ignore\nfn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {\n```\n\nwe can use a `where` clause, like this:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}\n```\n\nThis function’s signature is less cluttered: the function name, parameter list,\nand return type are close together, similar to a function without lots of trait\nbounds.\n\n### Returning Types that Implement Traits\n\nWe can also use the `impl Trait` syntax in the return position to return a\nvalue of some type that implements a trait, as shown here:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}\n```\n\nBy using `impl Summary` for the return type, we specify that the\n`returns_summarizable` function returns some type that implements the `Summary`\ntrait without naming the concrete type. In this case, `returns_summarizable`\nreturns a `Tweet`, but the code calling this function doesn’t need to know that.\n\nThe ability to specify a return type only by the trait it implements is\nespecially useful in the context of closures and iterators, which we cover in\nChapter 13. Closures and iterators create types that only the compiler knows or\ntypes that are very long to specify. The `impl Trait` syntax lets you concisely\nspecify that a function returns some type that implements the `Iterator` trait\nwithout needing to write out a very long type.\n\nHowever, you can only use `impl Trait` if you’re returning a single type. For\nexample, this code that returns either a `NewsArticle` or a `Tweet` with the\nreturn type specified as `impl Summary` wouldn’t work:\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}\n```\n\nReturning either a `NewsArticle` or a `Tweet` isn’t allowed due to restrictions\naround how the `impl Trait` syntax is implemented in the compiler. We’ll cover\nhow to write a function with this behavior in the [“Using Trait Objects That\nAllow for Values of Different\nTypes”][using-trait-objects-that-allow-for-values-of-different-types]<!--\nignore --> section of Chapter 17.\n\n### Using Trait Bounds to Conditionally Implement Methods\n\nBy using a trait bound with an `impl` block that uses generic type parameters,\nwe can implement methods conditionally for types that implement the specified\ntraits. For example, the type `Pair<T>` in Listing 10-15 always implements the\n`new` function to return a new instance of `Pair<T>` (recall from the\n[“Defining Methods”][methods]<!-- ignore --> section of Chapter 5 that `Self`\nis a type alias for the type of the `impl` block, which in this case is\n`Pair<T>`). But in the next `impl` block, `Pair<T>` only implements the\n`cmp_display` method if its inner type `T` implements the `PartialOrd` trait\nthat enables comparison *and* the `Display` trait that enables printing.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 10-15: Conditionally implementing methods on a\ngeneric type depending on trait bounds</span>\n\nWe can also conditionally implement a trait for any type that implements\nanother trait. Implementations of a trait on any type that satisfies the trait\nbounds are called *blanket implementations* and are extensively used in the\nRust standard library. For example, the standard library implements the\n`ToString` trait on any type that implements the `Display` trait. The `impl`\nblock in the standard library looks similar to this code:\n\n```rust,ignore\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n```\n\nBecause the standard library has this blanket implementation, we can call the\n`to_string` method defined by the `ToString` trait on any type that implements\nthe `Display` trait. For example, we can turn integers into their corresponding\n`String` values like this because integers implement `Display`:\n\n```rust\nlet s = 3.to_string();\n```\n\nBlanket implementations appear in the documentation for the trait in the\n“Implementors” section.\n\nTraits and trait bounds let us write code that uses generic type parameters to\nreduce duplication but also specify to the compiler that we want the generic\ntype to have particular behavior. The compiler can then use the trait bound\ninformation to check that all the concrete types used with our code provide the\ncorrect behavior. In dynamically typed languages, we would get an error at\nruntime if we called a method on a type which didn’t define the method. But Rust\nmoves these errors to compile time so we’re forced to fix the problems before\nour code is even able to run. Additionally, we don’t have to write code that\nchecks for behavior at runtime because we’ve already checked at compile time.\nDoing so improves performance without having to give up the flexibility of\ngenerics.\n\n[using-trait-objects-that-allow-for-values-of-different-types]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[methods]: ch05-03-method-syntax.html#defining-methods\n",
          "document_id": 49
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What are lifetimes used for?",
              "id": 2067,
              "answers": [
                {
                  "answer_id": 2071,
                  "document_id": 50,
                  "question_id": 2067,
                  "text": "The main aim of lifetimes is to prevent *dangling references*, which cause a\nprogram to reference data other than the data it’s intended to reference.",
                  "answer_start": 1263,
                  "answer_end": 1413,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What do lifetimes ensure?",
              "id": 2150,
              "answers": [
                {
                  "answer_id": 2155,
                  "document_id": 50,
                  "question_id": 2150,
                  "text": "references are valid as long as we need them to be",
                  "answer_start": 191,
                  "answer_end": 241,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is borrow checker used for?",
              "id": 2151,
              "answers": [
                {
                  "answer_id": 2156,
                  "document_id": 50,
                  "question_id": 2151,
                  "text": "compares scopes to determine\nwhether all borrows are valid",
                  "answer_start": 3257,
                  "answer_end": 3315,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Are Rust references permanent?",
              "id": 2152,
              "answers": [
                {
                  "answer_id": 2157,
                  "document_id": 50,
                  "question_id": 2152,
                  "text": "every reference in Rust has a *lifetime*, which is the scope for which\nthat reference is valid",
                  "answer_start": 379,
                  "answer_end": 473,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Are lifetimes implicit?",
              "id": 2153,
              "answers": [
                {
                  "answer_id": 2158,
                  "document_id": 50,
                  "question_id": 2153,
                  "text": "lifetimes are implicit and inferred",
                  "answer_start": 493,
                  "answer_end": 528,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is it possible to know which lifetime of reference will be passed?",
              "id": 2154,
              "answers": [
                {
                  "answer_id": 2159,
                  "document_id": 50,
                  "question_id": 2154,
                  "text": "We also don’t know the concrete lifetimes of the\nreferences that will be passed in",
                  "answer_start": 7018,
                  "answer_end": 7100,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Do lifetime annonations affect how long reference live?",
              "id": 2155,
              "answers": [
                {
                  "answer_id": 2160,
                  "document_id": 50,
                  "question_id": 2155,
                  "text": "Lifetime annotations don’t change how long any of the references live",
                  "answer_start": 7577,
                  "answer_end": 7646,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the naming convention of lifetimes?",
              "id": 2156,
              "answers": [
                {
                  "answer_id": 2161,
                  "document_id": 50,
                  "question_id": 2156,
                  "text": "the names of lifetime\nparameters must start with an apostrophe (`'`) and are usually all lowercase\nand very short, like generic types",
                  "answer_start": 8016,
                  "answer_end": 8149,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to use lifetime annotations in function signature?",
              "id": 2157,
              "answers": [
                {
                  "answer_id": 2162,
                  "document_id": 50,
                  "question_id": 2157,
                  "text": "we need to declare the\ngeneric *lifetime* parameters inside angle brackets between the function name\nand the parameter list",
                  "answer_start": 9123,
                  "answer_end": 9246,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Where should the annotation of lifetime be placed?",
              "id": 2158,
              "answers": [
                {
                  "answer_id": 2163,
                  "document_id": 50,
                  "question_id": 2158,
                  "text": "the annotations go in the function\nsignature, not in the function body",
                  "answer_start": 11115,
                  "answer_end": 11185,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can we define structs to keep references?",
              "id": 2159,
              "answers": [
                {
                  "answer_id": 2164,
                  "document_id": 50,
                  "question_id": 2159,
                  "text": "We can define structs to\nhold references, but in that case we would need to add a lifetime annotation on\nevery reference in the struct’s definition",
                  "answer_start": 18007,
                  "answer_end": 18154,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is input lifetime?",
              "id": 2160,
              "answers": [
                {
                  "answer_id": 2165,
                  "document_id": 50,
                  "question_id": 2160,
                  "text": "Lifetimes on function or method parameters",
                  "answer_start": 21595,
                  "answer_end": 21637,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are output lifetimes?",
              "id": 2161,
              "answers": [
                {
                  "answer_id": 2166,
                  "document_id": 50,
                  "question_id": 2161,
                  "text": "lifetimes on return values",
                  "answer_start": 21672,
                  "answer_end": 21698,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is a static lifetime?",
              "id": 2162,
              "answers": [
                {
                  "answer_id": 2167,
                  "document_id": 50,
                  "question_id": 2162,
                  "text": "the\naffected reference *can* live for the entire duration of the program",
                  "answer_start": 27129,
                  "answer_end": 27201,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Where should lifetime name be placed?",
              "id": 2188,
              "answers": [
                {
                  "answer_id": 2193,
                  "document_id": 50,
                  "question_id": 2188,
                  "text": "after the `impl`\nkeyword and then used after the struct’s name",
                  "answer_start": 25542,
                  "answer_end": 25604,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Do elision rule provide inference?",
              "id": 2189,
              "answers": [
                {
                  "answer_id": 2194,
                  "document_id": 50,
                  "question_id": 2189,
                  "text": "The elision rules don’t provide full inference.",
                  "answer_start": 21235,
                  "answer_end": 21282,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Should I use 'static' lifetime in error messages?",
              "id": 2190,
              "answers": [
                {
                  "answer_id": 2195,
                  "document_id": 50,
                  "question_id": 2190,
                  "text": " In such cases, the solution\nis fixing those problems, not specifying the `'static` lifetime.",
                  "answer_start": 27943,
                  "answer_end": 28036,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Do references have to be tied to struct's fields?",
              "id": 2191,
              "answers": [
                {
                  "answer_id": 2196,
                  "document_id": 50,
                  "question_id": 2191,
                  "text": "In method signatures inside the `impl` block, references might be tied to the\nlifetime of references in the struct’s fields, or they might be independent",
                  "answer_start": 25662,
                  "answer_end": 25815,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Validating References with Lifetimes\n\nLifetimes are another kind of generic that we’ve already been using. Rather\nthan ensuring that a type has the behavior we want, lifetimes ensure that\nreferences are valid as long as we need them to be.\n\nOne detail we didn’t discuss in the [“References and\nBorrowing”][references-and-borrowing]<!-- ignore --> section in Chapter 4 is\nthat every reference in Rust has a *lifetime*, which is the scope for which\nthat reference is valid. Most of the time, lifetimes are implicit and inferred,\njust like most of the time, types are inferred. We only must annotate types\nwhen multiple types are possible. In a similar way, we must annotate lifetimes\nwhen the lifetimes of references could be related in a few different ways. Rust\nrequires us to annotate the relationships using generic lifetime parameters to\nensure the actual references used at runtime will definitely be valid.\n\nAnnotating lifetimes is not even a concept most other programming languages\nhave, so this is going to feel unfamiliar. Although we won’t cover lifetimes in\ntheir entirety in this chapter, we’ll discuss common ways you might encounter\nlifetime syntax so you can get comfortable with the concept.\n\n### Preventing Dangling References with Lifetimes\n\nThe main aim of lifetimes is to prevent *dangling references*, which cause a\nprogram to reference data other than the data it’s intended to reference.\nConsider the program in Listing 10-16, which has an outer scope and an inner\nscope.\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-16: An attempt to use a reference whose value\nhas gone out of scope</span>\n\n> Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables\n> without giving them an initial value, so the variable name exists in the\n> outer scope. At first glance, this might appear to be in conflict with Rust’s\n> having no null values. However, if we try to use a variable before giving it\n> a value, we’ll get a compile-time error, which shows that Rust indeed does\n> not allow null values.\n\nThe outer scope declares a variable named `r` with no initial value, and the\ninner scope declares a variable named `x` with the initial value of 5. Inside\nthe inner scope, we attempt to set the value of `r` as a reference to `x`. Then\nthe inner scope ends, and we attempt to print the value in `r`. This code won’t\ncompile because the value `r` is referring to has gone out of scope before we\ntry to use it. Here is the error message:\n\n```console\n{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt}}\n```\n\nThe variable `x` doesn’t “live long enough.” The reason is that `x` will be out\nof scope when the inner scope ends on line 7. But `r` is still valid for the\nouter scope; because its scope is larger, we say that it “lives longer.” If\nRust allowed this code to work, `r` would be referencing memory that was\ndeallocated when `x` went out of scope, and anything we tried to do with `r`\nwouldn’t work correctly. So how does Rust determine that this code is invalid?\nIt uses a borrow checker.\n\n### The Borrow Checker\n\nThe Rust compiler has a *borrow checker* that compares scopes to determine\nwhether all borrows are valid. Listing 10-17 shows the same code as Listing\n10-16 but with annotations showing the lifetimes of the variables.\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-17/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-17: Annotations of the lifetimes of `r` and\n`x`, named `'a` and `'b`, respectively</span>\n\nHere, we’ve annotated the lifetime of `r` with `'a` and the lifetime of `x`\nwith `'b`. As you can see, the inner `'b` block is much smaller than the outer\n`'a` lifetime block. At compile time, Rust compares the size of the two\nlifetimes and sees that `r` has a lifetime of `'a` but that it refers to memory\nwith a lifetime of `'b`. The program is rejected because `'b` is shorter than\n`'a`: the subject of the reference doesn’t live as long as the reference.\n\nListing 10-18 fixes the code so it doesn’t have a dangling reference and\ncompiles without any errors.\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-18/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-18: A valid reference because the data has a\nlonger lifetime than the reference</span>\n\nHere, `x` has the lifetime `'b`, which in this case is larger than `'a`. This\nmeans `r` can reference `x` because Rust knows that the reference in `r` will\nalways be valid while `x` is valid.\n\nNow that you know where the lifetimes of references are and how Rust analyzes\nlifetimes to ensure references will always be valid, let’s explore generic\nlifetimes of parameters and return values in the context of functions.\n\n### Generic Lifetimes in Functions\n\nWe’ll write a function that returns the longer of two string slices. This\nfunction will take two string slices and return a single string slice. After\nwe’ve implemented the `longest` function, the code in Listing 10-19 should\nprint `The longest string is abcd`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-19/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-19: A `main` function that calls the `longest`\nfunction to find the longer of two string slices</span>\n\nNote that we want the function to take string slices, which are references,\nrather than strings, because we don’t want the `longest` function to take\nownership of its parameters. Refer to the [“String Slices as\nParameters”][string-slices-as-parameters]<!-- ignore --> section in Chapter 4\nfor more discussion about why the parameters we use in Listing 10-19 are the\nones we want.\n\nIf we try to implement the `longest` function as shown in Listing 10-20, it\nwon’t compile.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-20: An implementation of the `longest`\nfunction that returns the longer of two string slices but does not yet\ncompile</span>\n\nInstead, we get the following error that talks about lifetimes:\n\n```console\n{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/output.txt}}\n```\n\nThe help text reveals that the return type needs a generic lifetime parameter\non it because Rust can’t tell whether the reference being returned refers to\n`x` or `y`. Actually, we don’t know either, because the `if` block in the body\nof this function returns a reference to `x` and the `else` block returns a\nreference to `y`!\n\nWhen we’re defining this function, we don’t know the concrete values that will\nbe passed into this function, so we don’t know whether the `if` case or the\n`else` case will execute. We also don’t know the concrete lifetimes of the\nreferences that will be passed in, so we can’t look at the scopes as we did in\nListings 10-17 and 10-18 to determine whether the reference we return will\nalways be valid. The borrow checker can’t determine this either, because it\ndoesn’t know how the lifetimes of `x` and `y` relate to the lifetime of the\nreturn value. To fix this error, we’ll add generic lifetime parameters that\ndefine the relationship between the references so the borrow checker can\nperform its analysis.\n\n### Lifetime Annotation Syntax\n\nLifetime annotations don’t change how long any of the references live. Rather,\nthey describe the relationships of the lifetimes of multiple references to each\nother without affecting the lifetimes. Just as functions can accept any type\nwhen the signature specifies a generic type parameter, functions can accept\nreferences with any lifetime by specifying a generic lifetime parameter.\n\nLifetime annotations have a slightly unusual syntax: the names of lifetime\nparameters must start with an apostrophe (`'`) and are usually all lowercase\nand very short, like generic types. Most people use the name `'a` for the first\nlifetime annotation. We place lifetime parameter annotations after the `&` of a\nreference, using a space to separate the annotation from the reference’s type.\n\nHere are some examples: a reference to an `i32` without a lifetime parameter, a\nreference to an `i32` that has a lifetime parameter named `'a`, and a mutable\nreference to an `i32` that also has the lifetime `'a`.\n\n```rust,ignore\n&i32        // a reference\n&'a i32     // a reference with an explicit lifetime\n&'a mut i32 // a mutable reference with an explicit lifetime\n```\n\nOne lifetime annotation by itself doesn’t have much meaning, because the\nannotations are meant to tell Rust how generic lifetime parameters of multiple\nreferences relate to each other. Let’s examine how the lifetime annotations\nrelate to each other in the context of the `longest` function.\n\n### Lifetime Annotations in Function Signatures\n\nTo use lifetime annotations in function signatures, we need to declare the\ngeneric *lifetime* parameters inside angle brackets between the function name\nand the parameter list, just as we did with generic *type* parameters.\n\nWe want the signature to express the following constraint: the returned\nreference will be valid as long as both the parameters are valid. This is the\nrelationship between lifetimes of the parameters and the return value. We’ll\nname the lifetime `'a` and then add it to each reference, as shown in Listing\n10-21.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-21/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-21: The `longest` function definition\nspecifying that all the references in the signature must have the same lifetime\n`'a`</span>\n\nThis code should compile and produce the result we want when we use it with the\n`main` function in Listing 10-19.\n\nThe function signature now tells Rust that for some lifetime `'a`, the function\ntakes two parameters, both of which are string slices that live at least as\nlong as lifetime `'a`. The function signature also tells Rust that the string\nslice returned from the function will live at least as long as lifetime `'a`.\nIn practice, it means that the lifetime of the reference returned by the\n`longest` function is the same as the smaller of the lifetimes of the values\nreferred to by the function arguments. These relationships are what we want\nRust to use when analyzing this code.\n\nRemember, when we specify the lifetime parameters in this function signature,\nwe’re not changing the lifetimes of any values passed in or returned. Rather,\nwe’re specifying that the borrow checker should reject any values that don’t\nadhere to these constraints. Note that the `longest` function doesn’t need to\nknow exactly how long `x` and `y` will live, only that some scope can be\nsubstituted for `'a` that will satisfy this signature.\n\nWhen annotating lifetimes in functions, the annotations go in the function\nsignature, not in the function body. The lifetime annotations become part of\nthe contract of the function, much like the types in the signature. Having\nfunction signatures contain the lifetime contract means the analysis the Rust\ncompiler does can be simpler. If there’s a problem with the way a function is\nannotated or the way it is called, the compiler errors can point to the part of\nour code and the constraints more precisely. If, instead, the Rust compiler\nmade more inferences about what we intended the relationships of the lifetimes\nto be, the compiler might only be able to point to a use of our code many steps\naway from the cause of the problem.\n\nWhen we pass concrete references to `longest`, the concrete lifetime that is\nsubstituted for `'a` is the part of the scope of `x` that overlaps with the\nscope of `y`. In other words, the generic lifetime `'a` will get the concrete\nlifetime that is equal to the smaller of the lifetimes of `x` and `y`. Because\nwe’ve annotated the returned reference with the same lifetime parameter `'a`,\nthe returned reference will also be valid for the length of the smaller of the\nlifetimes of `x` and `y`.\n\nLet’s look at how the lifetime annotations restrict the `longest` function by\npassing in references that have different concrete lifetimes. Listing 10-22 is\na straightforward example.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-22/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-22: Using the `longest` function with\nreferences to `String` values that have different concrete lifetimes</span>\n\nIn this example, `string1` is valid until the end of the outer scope, `string2`\nis valid until the end of the inner scope, and `result` references something\nthat is valid until the end of the inner scope. Run this code, and you’ll see\nthat the borrow checker approves; it will compile and print `The longest string\nis long string is long`.\n\nNext, let’s try an example that shows that the lifetime of the reference in\n`result` must be the smaller lifetime of the two arguments. We’ll move the\ndeclaration of the `result` variable outside the inner scope but leave the\nassignment of the value to the `result` variable inside the scope with\n`string2`. Then we’ll move the `println!` that uses `result` to outside the\ninner scope, after the inner scope has ended. The code in Listing 10-23 will\nnot compile.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-23: Attempting to use `result` after `string2`\nhas gone out of scope</span>\n\nWhen we try to compile this code, we get this error:\n\n```console\n{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/output.txt}}\n```\n\nThe error shows that for `result` to be valid for the `println!` statement,\n`string2` would need to be valid until the end of the outer scope. Rust knows\nthis because we annotated the lifetimes of the function parameters and return\nvalues using the same lifetime parameter `'a`.\n\nAs humans, we can look at this code and see that `string1` is longer than\n`string2` and therefore `result` will contain a reference to `string1`.\nBecause `string1` has not gone out of scope yet, a reference to `string1` will\nstill be valid for the `println!` statement. However, the compiler can’t see\nthat the reference is valid in this case. We’ve told Rust that the lifetime of\nthe reference returned by the `longest` function is the same as the smaller of\nthe lifetimes of the references passed in. Therefore, the borrow checker\ndisallows the code in Listing 10-23 as possibly having an invalid reference.\n\nTry designing more experiments that vary the values and lifetimes of the\nreferences passed in to the `longest` function and how the returned reference\nis used. Make hypotheses about whether or not your experiments will pass the\nborrow checker before you compile; then check to see if you’re right!\n\n### Thinking in Terms of Lifetimes\n\nThe way in which you need to specify lifetime parameters depends on what your\nfunction is doing. For example, if we changed the implementation of the\n`longest` function to always return the first parameter rather than the longest\nstring slice, we wouldn’t need to specify a lifetime on the `y` parameter. The\nfollowing code will compile:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-08-only-one-reference-with-lifetime/src/main.rs:here}}\n```\n\nWe’ve specified a lifetime parameter `'a` for the parameter `x` and the return\ntype, but not for the parameter `y`, because the lifetime of `y` does not have\nany relationship with the lifetime of `x` or the return value.\n\nWhen returning a reference from a function, the lifetime parameter for the\nreturn type needs to match the lifetime parameter for one of the parameters. If\nthe reference returned does *not* refer to one of the parameters, it must refer\nto a value created within this function. However, this would be a dangling\nreference because the value will go out of scope at the end of the function.\nConsider this attempted implementation of the `longest` function that won’t\ncompile:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/src/main.rs:here}}\n```\n\nHere, even though we’ve specified a lifetime parameter `'a` for the return\ntype, this implementation will fail to compile because the return value\nlifetime is not related to the lifetime of the parameters at all. Here is the\nerror message we get:\n\n```console\n{{#include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/output.txt}}\n```\n\nThe problem is that `result` goes out of scope and gets cleaned up at the end\nof the `longest` function. We’re also trying to return a reference to `result`\nfrom the function. There is no way we can specify lifetime parameters that\nwould change the dangling reference, and Rust won’t let us create a dangling\nreference. In this case, the best fix would be to return an owned data type\nrather than a reference so the calling function is then responsible for\ncleaning up the value.\n\nUltimately, lifetime syntax is about connecting the lifetimes of various\nparameters and return values of functions. Once they’re connected, Rust has\nenough information to allow memory-safe operations and disallow operations that\nwould create dangling pointers or otherwise violate memory safety.\n\n### Lifetime Annotations in Struct Definitions\n\nSo far, the structs we’ve defined all hold owned types. We can define structs to\nhold references, but in that case we would need to add a lifetime annotation on\nevery reference in the struct’s definition. Listing 10-24 has a struct named\n`ImportantExcerpt` that holds a string slice.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-24/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 10-24: A struct that holds a reference, requiring\na lifetime annotation</span>\n\nThis struct has the single field `part` that holds a string slice, which is a\nreference. As with generic data types, we declare the name of the generic\nlifetime parameter inside angle brackets after the name of the struct so we can\nuse the lifetime parameter in the body of the struct definition. This\nannotation means an instance of `ImportantExcerpt` can’t outlive the reference\nit holds in its `part` field.\n\nThe `main` function here creates an instance of the `ImportantExcerpt` struct\nthat holds a reference to the first sentence of the `String` owned by the\nvariable `novel`. The data in `novel` exists before the `ImportantExcerpt`\ninstance is created. In addition, `novel` doesn’t go out of scope until after\nthe `ImportantExcerpt` goes out of scope, so the reference in the\n`ImportantExcerpt` instance is valid.\n\n### Lifetime Elision\n\nYou’ve learned that every reference has a lifetime and that you need to specify\nlifetime parameters for functions or structs that use references. However, in\nChapter 4 we had a function in Listing 4-9, shown again in Listing 10-25, that\ncompiled without lifetime annotations.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-25/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 10-25: A function we defined in Listing 4-9 that\ncompiled without lifetime annotations, even though the parameter and return\ntype are references</span>\n\nThe reason this function compiles without lifetime annotations is historical:\nin early versions (pre-1.0) of Rust, this code wouldn’t have compiled because\nevery reference needed an explicit lifetime. At that time, the function\nsignature would have been written like this:\n\n```rust,ignore\nfn first_word<'a>(s: &'a str) -> &'a str {\n```\n\nAfter writing a lot of Rust code, the Rust team found that Rust programmers\nwere entering the same lifetime annotations over and over in particular\nsituations. These situations were predictable and followed a few deterministic\npatterns. The developers programmed these patterns into the compiler’s code so\nthe borrow checker could infer the lifetimes in these situations and wouldn’t\nneed explicit annotations.\n\nThis piece of Rust history is relevant because it’s possible that more\ndeterministic patterns will emerge and be added to the compiler. In the future,\neven fewer lifetime annotations might be required.\n\nThe patterns programmed into Rust’s analysis of references are called the\n*lifetime elision rules*. These aren’t rules for programmers to follow; they’re\na set of particular cases that the compiler will consider, and if your code\nfits these cases, you don’t need to write the lifetimes explicitly.\n\nThe elision rules don’t provide full inference. If Rust deterministically\napplies the rules but there is still ambiguity as to what lifetimes the\nreferences have, the compiler won’t guess what the lifetime of the remaining\nreferences should be. Instead of guessing, the compiler will give you an error\nthat you can resolve by adding the lifetime annotations.\n\nLifetimes on function or method parameters are called *input lifetimes*, and\nlifetimes on return values are called *output lifetimes*.\n\nThe compiler uses three rules to figure out the lifetimes of the references\nwhen there aren’t explicit annotations. The first rule applies to input\nlifetimes, and the second and third rules apply to output lifetimes. If the\ncompiler gets to the end of the three rules and there are still references for\nwhich it can’t figure out lifetimes, the compiler will stop with an error.\nThese rules apply to `fn` definitions as well as `impl` blocks.\n\nThe first rule is that the compiler assigns a lifetime parameter to each\nparameter that’s a reference. In other words, a function with one parameter gets\none lifetime parameter: `fn foo<'a>(x: &'a i32)`; a function with two\nparameters gets two separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32,\ny: &'b i32)`; and so on.\n\nThe second rule is that, if there is exactly one input lifetime parameter, that\nlifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32)\n-> &'a i32`.\n\nThe third rule is that, if there are multiple input lifetime parameters, but\none of them is `&self` or `&mut self` because this is a method, the lifetime of\n`self` is assigned to all output lifetime parameters. This third rule makes\nmethods much nicer to read and write because fewer symbols are necessary.\n\nLet’s pretend we’re the compiler. We’ll apply these rules to figure out the\nlifetimes of the references in the signature of the `first_word` function in\nListing 10-25. The signature starts without any lifetimes associated with the\nreferences:\n\n```rust,ignore\nfn first_word(s: &str) -> &str {\n```\n\nThen the compiler applies the first rule, which specifies that each parameter\ngets its own lifetime. We’ll call it `'a` as usual, so now the signature is\nthis:\n\n```rust,ignore\nfn first_word<'a>(s: &'a str) -> &str {\n```\n\nThe second rule applies because there is exactly one input lifetime. The second\nrule specifies that the lifetime of the one input parameter gets assigned to\nthe output lifetime, so the signature is now this:\n\n```rust,ignore\nfn first_word<'a>(s: &'a str) -> &'a str {\n```\n\nNow all the references in this function signature have lifetimes, and the\ncompiler can continue its analysis without needing the programmer to annotate\nthe lifetimes in this function signature.\n\nLet’s look at another example, this time using the `longest` function that had\nno lifetime parameters when we started working with it in Listing 10-20:\n\n```rust,ignore\nfn longest(x: &str, y: &str) -> &str {\n```\n\nLet’s apply the first rule: each parameter gets its own lifetime. This time we\nhave two parameters instead of one, so we have two lifetimes:\n\n```rust,ignore\nfn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {\n```\n\nYou can see that the second rule doesn’t apply because there is more than one\ninput lifetime. The third rule doesn’t apply either, because `longest` is a\nfunction rather than a method, so none of the parameters are `self`. After\nworking through all three rules, we still haven’t figured out what the return\ntype’s lifetime is. This is why we got an error trying to compile the code in\nListing 10-20: the compiler worked through the lifetime elision rules but still\ncouldn’t figure out all the lifetimes of the references in the signature.\n\nBecause the third rule really only applies in method signatures, we’ll look at\nlifetimes in that context next to see why the third rule means we don’t have to\nannotate lifetimes in method signatures very often.\n\n### Lifetime Annotations in Method Definitions\n\nWhen we implement methods on a struct with lifetimes, we use the same syntax as\nthat of generic type parameters shown in Listing 10-11. Where we declare and\nuse the lifetime parameters depends on whether they’re related to the struct\nfields or the method parameters and return values.\n\nLifetime names for struct fields always need to be declared after the `impl`\nkeyword and then used after the struct’s name, because those lifetimes are part\nof the struct’s type.\n\nIn method signatures inside the `impl` block, references might be tied to the\nlifetime of references in the struct’s fields, or they might be independent. In\naddition, the lifetime elision rules often make it so that lifetime annotations\naren’t necessary in method signatures. Let’s look at some examples using the\nstruct named `ImportantExcerpt` that we defined in Listing 10-24.\n\nFirst, we’ll use a method named `level` whose only parameter is a reference to\n`self` and whose return value is an `i32`, which is not a reference to anything:\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:1st}}\n```\n\nThe lifetime parameter declaration after `impl` and its use after the type name\nare required, but we’re not required to annotate the lifetime of the reference\nto `self` because of the first elision rule.\n\nHere is an example where the third lifetime elision rule applies:\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:3rd}}\n```\n\nThere are two input lifetimes, so Rust applies the first lifetime elision rule\nand gives both `&self` and `announcement` their own lifetimes. Then, because\none of the parameters is `&self`, the return type gets the lifetime of `&self`,\nand all lifetimes have been accounted for.\n\n### The Static Lifetime\n\nOne special lifetime we need to discuss is `'static`, which denotes that the\naffected reference *can* live for the entire duration of the program. All\nstring literals have the `'static` lifetime, which we can annotate as follows:\n\n```rust\nlet s: &'static str = \"I have a static lifetime.\";\n```\n\nThe text of this string is stored directly in the program’s binary, which\nis always available. Therefore, the lifetime of all string literals is\n`'static`.\n\nYou might see suggestions to use the `'static` lifetime in error messages. But\nbefore specifying `'static` as the lifetime for a reference, think about\nwhether the reference you have actually lives the entire lifetime of your\nprogram or not, and whether you want it to. Most of the time, an error message\nsuggesting the `'static` lifetime results from attempting to create a dangling\nreference or a mismatch of the available lifetimes. In such cases, the solution\nis fixing those problems, not specifying the `'static` lifetime.\n\n## Generic Type Parameters, Trait Bounds, and Lifetimes Together\n\nLet’s briefly look at the syntax of specifying generic type parameters, trait\nbounds, and lifetimes all in one function!\n\n```rust\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}\n```\n\nThis is the `longest` function from Listing 10-21 that returns the longer of\ntwo string slices. But now it has an extra parameter named `ann` of the generic\ntype `T`, which can be filled in by any type that implements the `Display`\ntrait as specified by the `where` clause. This extra parameter will be printed\nusing `{}`, which is why the `Display` trait bound is necessary. Because\nlifetimes are a type of generic, the declarations of the lifetime parameter\n`'a` and the generic type parameter `T` go in the same list inside the angle\nbrackets after the function name.\n\n## Summary\n\nWe covered a lot in this chapter! Now that you know about generic type\nparameters, traits and trait bounds, and generic lifetime parameters, you’re\nready to write code without repetition that works in many different situations.\nGeneric type parameters let you apply the code to different types. Traits and\ntrait bounds ensure that even though the types are generic, they’ll have the\nbehavior the code needs. You learned how to use lifetime annotations to ensure\nthat this flexible code won’t have any dangling references. And all of this\nanalysis happens at compile time, which doesn’t affect runtime performance!\n\nBelieve it or not, there is much more to learn on the topics we discussed in\nthis chapter: Chapter 17 discusses trait objects, which are another way to use\ntraits. There are also more complex scenarios involving lifetime annotations\nthat you will only need in very advanced scenarios; for those, you should read\nthe [Rust Reference][reference]. But next, you’ll learn how to write tests in\nRust so you can make sure your code is working the way it should.\n\n[references-and-borrowing]:\nch04-02-references-and-borrowing.html#references-and-borrowing\n[string-slices-as-parameters]:\nch04-03-slices.html#string-slices-as-parameters\n[reference]: ../reference/index.html\n",
          "document_id": 50
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "Is it possible to use assertions in tests?",
              "id": 2068,
              "answers": [
                {
                  "answer_id": 2072,
                  "document_id": 51,
                  "question_id": 2068,
                  "text": "We can write tests that assert",
                  "answer_start": 1309,
                  "answer_end": 1339,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why should I write tests?",
              "id": 2069,
              "answers": [
                {
                  "answer_id": 2073,
                  "document_id": 51,
                  "question_id": 2069,
                  "text": "check that this function will do precisely\nwhat we intend",
                  "answer_start": 1117,
                  "answer_end": 1174,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is important to be familiar with when writing tests in Rust?",
              "id": 2070,
              "answers": [
                {
                  "answer_id": 2074,
                  "document_id": 51,
                  "question_id": 2070,
                  "text": "annotations and macros",
                  "answer_start": 1741,
                  "answer_end": 1763,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Does Rust support tests?",
              "id": 2071,
              "answers": [
                {
                  "answer_id": 2075,
                  "document_id": 51,
                  "question_id": 2071,
                  "text": "Rust includes support for writing automated software tests.",
                  "answer_start": 630,
                  "answer_end": 689,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "When should I run tests?",
              "id": 2072,
              "answers": [
                {
                  "answer_id": 2076,
                  "document_id": 51,
                  "question_id": 2072,
                  "text": "whenever\nwe make changes to our code to make sure any existing correct behavior has not\nchanged",
                  "answer_start": 1453,
                  "answer_end": 1548,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "# Writing Automated Tests\n\nIn his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that\n“Program testing can be a very effective way to show the presence of bugs, but\nit is hopelessly inadequate for showing their absence.” That doesn’t mean we\nshouldn’t try to test as much as we can!\n\nCorrectness in our programs is the extent to which our code does what we intend\nit to do. Rust is designed with a high degree of concern about the correctness\nof programs, but correctness is complex and not easy to prove. Rust’s type\nsystem shoulders a huge part of this burden, but the type system cannot catch\neverything. As such, Rust includes support for writing automated software tests.\n\nSay we write a function `add_two` that adds 2 to whatever number is passed to\nit. This function’s signature accepts an integer as a parameter and returns an\ninteger as a result. When we implement and compile that function, Rust does all\nthe type checking and borrow checking that you’ve learned so far to ensure\nthat, for instance, we aren’t passing a `String` value or an invalid reference\nto this function. But Rust *can’t* check that this function will do precisely\nwhat we intend, which is return the parameter plus 2 rather than, say, the\nparameter plus 10 or the parameter minus 50! That’s where tests come in.\n\nWe can write tests that assert, for example, that when we pass `3` to the\n`add_two` function, the returned value is `5`. We can run these tests whenever\nwe make changes to our code to make sure any existing correct behavior has not\nchanged.\n\nTesting is a complex skill: although we can’t cover every detail about how to\nwrite good tests in one chapter, we’ll discuss the mechanics of Rust’s testing\nfacilities. We’ll talk about the annotations and macros available to you when\nwriting your tests, the default behavior and options provided for running your\ntests, and how to organize tests into unit tests and integration tests.\n",
          "document_id": 51
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What are tests?",
              "id": 2073,
              "answers": [
                {
                  "answer_id": 2077,
                  "document_id": 52,
                  "question_id": 2073,
                  "text": "functions that verify that the non-test code is functioning in\nthe expected manner",
                  "answer_start": 38,
                  "answer_end": 120,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How do tests work?",
              "id": 2074,
              "answers": [
                {
                  "answer_id": 2078,
                  "document_id": 52,
                  "question_id": 2074,
                  "text": "1. Set up any needed data or state.\n2. Run the code you want to test.\n3. Assert the results are what you expect.",
                  "answer_start": 191,
                  "answer_end": 303,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to distinguish test function from normal function?",
              "id": 2075,
              "answers": [
                {
                  "answer_id": 2079,
                  "document_id": 52,
                  "question_id": 2075,
                  "text": "a test in Rust is a function that’s annotated with the `test`\nattribute",
                  "answer_start": 540,
                  "answer_end": 611,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does test annotation mean?",
              "id": 2076,
              "answers": [
                {
                  "answer_id": 2080,
                  "document_id": 52,
                  "question_id": 2076,
                  "text": "indicates this is a test function",
                  "answer_start": 2447,
                  "answer_end": 2480,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to create a test function?",
              "id": 2077,
              "answers": [
                {
                  "answer_id": 2081,
                  "document_id": 52,
                  "question_id": 2077,
                  "text": "add `#[test]` on the line before `fn`",
                  "answer_start": 780,
                  "answer_end": 817,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to run tests in Rust?",
              "id": 2078,
              "answers": [
                {
                  "answer_id": 2082,
                  "document_id": 52,
                  "question_id": 2078,
                  "text": "with the `cargo test` command",
                  "answer_start": 843,
                  "answer_end": 872,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does 'cargo test' command do?",
              "id": 2079,
              "answers": [
                {
                  "answer_id": 2083,
                  "document_id": 52,
                  "question_id": 2079,
                  "text": "runs\nthe annotated functions and reports on whether each\ntest function passes or fails",
                  "answer_start": 912,
                  "answer_end": 998,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I verify if tested function returns correct value?",
              "id": 2080,
              "answers": [
                {
                  "answer_id": 2084,
                  "document_id": 52,
                  "question_id": 2080,
                  "text": "assert_eq!",
                  "answer_start": 2757,
                  "answer_end": 2767,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does ignored test mean?",
              "id": 2081,
              "answers": [
                {
                  "answer_id": 2085,
                  "document_id": 52,
                  "question_id": 2081,
                  "text": "it doesn’t run in a particular\ninstance",
                  "answer_start": 3659,
                  "answer_end": 3698,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Are benchmark tests available in Rust?",
              "id": 2082,
              "answers": [
                {
                  "answer_id": 2086,
                  "document_id": 52,
                  "question_id": 2082,
                  "text": "only available in nightly Rust",
                  "answer_start": 4343,
                  "answer_end": 4373,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What happens when test result is different than expected?",
              "id": 2083,
              "answers": [
                {
                  "answer_id": 2087,
                  "document_id": 52,
                  "question_id": 2083,
                  "text": "`assert!` macro calls `panic!` to cause the test to fail",
                  "answer_start": 7863,
                  "answer_end": 7919,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which keyword is used for verification of result given by tested function?",
              "id": 2084,
              "answers": [
                {
                  "answer_id": 2088,
                  "document_id": 52,
                  "question_id": 2084,
                  "text": "`assert!`",
                  "answer_start": 7931,
                  "answer_end": 7940,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is 'assert!' keyword used for?",
              "id": 2085,
              "answers": [
                {
                  "answer_id": 2089,
                  "document_id": 52,
                  "question_id": 2085,
                  "text": "helps us check that our code is functioning in the way we intend",
                  "answer_start": 7947,
                  "answer_end": 8011,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I check if result given by tested function is different than some value?",
              "id": 2086,
              "answers": [
                {
                  "answer_id": 2090,
                  "document_id": 52,
                  "question_id": 2086,
                  "text": "`assert_ne!`",
                  "answer_start": 11940,
                  "answer_end": 11952,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is 'assert_eq' used for?",
              "id": 2087,
              "answers": [
                {
                  "answer_id": 2091,
                  "document_id": 52,
                  "question_id": 2087,
                  "text": "compare two arguments for equality",
                  "answer_start": 12006,
                  "answer_end": 12040,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does 'assert_ne!' check?",
              "id": 2088,
              "answers": [
                {
                  "answer_id": 2092,
                  "document_id": 52,
                  "question_id": 2088,
                  "text": "inequality",
                  "answer_start": 12044,
                  "answer_end": 12054,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "When could I use 'assert_ne!'?",
              "id": 2089,
              "answers": [
                {
                  "answer_id": 2093,
                  "document_id": 52,
                  "question_id": 2089,
                  "text": "when we’re not sure\nwhat a value *will* be, but we know what the value definitely *shouldn’t* be.",
                  "answer_start": 14617,
                  "answer_end": 14714,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I add a custom failure message?",
              "id": 2090,
              "answers": [
                {
                  "answer_id": 2094,
                  "document_id": 52,
                  "question_id": 2090,
                  "text": "`format!` macro",
                  "answer_start": 16170,
                  "answer_end": 16185,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are custom messages used for?",
              "id": 2091,
              "answers": [
                {
                  "answer_id": 2095,
                  "document_id": 52,
                  "question_id": 2091,
                  "text": "for documenting\nwhat an assertion means; when a test fails",
                  "answer_start": 16490,
                  "answer_end": 16548,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I check if function throws an error?",
              "id": 2092,
              "answers": [
                {
                  "answer_id": 2096,
                  "document_id": 52,
                  "question_id": 2092,
                  "text": "should_panic",
                  "answer_start": 18606,
                  "answer_end": 18618,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is 'should_panic' used for?",
              "id": 2093,
              "answers": [
                {
                  "answer_id": 2097,
                  "document_id": 52,
                  "question_id": 2093,
                  "text": "to check that our code\nhandles error conditions as we expect",
                  "answer_start": 18675,
                  "answer_end": 18735,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## How to Write Tests\n\nTests are Rust functions that verify that the non-test code is functioning in\nthe expected manner. The bodies of test functions typically perform these three\nactions:\n\n1. Set up any needed data or state.\n2. Run the code you want to test.\n3. Assert the results are what you expect.\n\nLet’s look at the features Rust provides specifically for writing tests that\ntake these actions, which include the `test` attribute, a few macros, and the\n`should_panic` attribute.\n\n### The Anatomy of a Test Function\n\nAt its simplest, a test in Rust is a function that’s annotated with the `test`\nattribute. Attributes are metadata about pieces of Rust code; one example is\nthe `derive` attribute we used with structs in Chapter 5. To change a function\ninto a test function, add `#[test]` on the line before `fn`. When you run your\ntests with the `cargo test` command, Rust builds a test runner binary that runs\nthe annotated functions and reports on whether each\ntest function passes or fails.\n\nWhenever we make a new library project with Cargo, a test module with a test\nfunction in it is automatically generated for us. This module gives you a\ntemplate for writing your tests so you don’t have to look up the exact\nstructure and syntax every time you start a new project. You can add as many\nadditional test functions and as many test modules as you want!\n\nWe’ll explore some aspects of how tests work by experimenting with the template\ntest before we actually test any code. Then we’ll write some real-world tests\nthat call some code that we’ve written and assert that its behavior is correct.\n\nLet’s create a new library project called `adder` that will add two numbers:\n\n```console\n$ cargo new adder --lib\n     Created library `adder` project\n$ cd adder\n```\n\nThe contents of the *src/lib.rs* file in your `adder` library should look like\nListing 11-1.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n<!-- manual-regeneration\ncd listings/ch11-writing-automated-tests\nrm -rf listing-11-01\ncargo new listing-11-01 --lib --name adder\ncd listing-11-01\ncargo test\ngit co output.txt\ncd ../../..\n-->\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 11-1: The test module and function generated\nautomatically by `cargo new`</span>\n\nFor now, let’s ignore the top two lines and focus on the function. Note the\n`#[test]` annotation: this attribute indicates this is a test function, so the\ntest runner knows to treat this function as a test. We might also have non-test\nfunctions in the `tests` module to help set up common scenarios or perform\ncommon operations, so we always need to indicate which functions are tests.\n\nThe example function body uses the `assert_eq!` macro to assert that `result`,\nwhich contains the result of adding 2 and 2, equals 4. This assertion serves as\nan example of the format for a typical test. Let’s run it to see that this test\npasses.\n\nThe `cargo test` command runs all tests in our project, as shown in Listing\n11-2.\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/listing-11-01/output.txt}}\n```\n\n<span class=\"caption\">Listing 11-2: The output from running the automatically\ngenerated test</span>\n\nCargo compiled and ran the test. We see the line `running 1 test`. The next\nline shows the name of the generated test function, called `it_works`, and that\nthe result of running that test is `ok`. The overall summary `test result: ok.`\nmeans that all the tests passed, and the portion that reads `1 passed; 0\nfailed` totals the number of tests that passed or failed.\n\nIt’s possible to mark a test as ignored so it doesn’t run in a particular\ninstance; we’ll cover that in the [“Ignoring Some Tests Unless Specifically\nRequested”][ignoring]<!-- ignore --> section later in this chapter. Because we\nhaven’t done that here, the summary shows `0 ignored`. We can also pass an\nargument to the `cargo test` command to run only tests whose name matches a\nstring; this is called *filtering* and we’ll cover that in the [“Running a\nSubset of Tests by Name”][subset]<!-- ignore --> section. We also haven’t\nfiltered the tests being run, so the end of the summary shows `0 filtered out`.\n\nThe `0 measured` statistic is for benchmark tests that measure performance.\nBenchmark tests are, as of this writing, only available in nightly Rust. See\n[the documentation about benchmark tests][bench] to learn more.\n\nThe next part of the test output starting at `Doc-tests adder` is for the\nresults of any documentation tests. We don’t have any documentation tests yet,\nbut Rust can compile any code examples that appear in our API documentation.\nThis feature helps keep your docs and your code in sync! We’ll discuss how to\nwrite documentation tests in the [“Documentation Comments as\nTests”][doc-comments]<!-- ignore --> section of Chapter 14. For now, we’ll\nignore the `Doc-tests` output.\n\nLet’s start to customize the test to our own needs. First change the name of\nthe `it_works` function to a different name, such as `exploration`, like so:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/src/lib.rs}}\n```\n\nThen run `cargo test` again. The output now shows `exploration` instead of\n`it_works`:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt}}\n```\n\nNow we’ll add another test, but this time we’ll make a test that fails! Tests\nfail when something in the test function panics. Each test is run in a new\nthread, and when the main thread sees that a test thread has died, the test is\nmarked as failed. In Chapter 9, we talked about how the simplest way to panic\nis to call the `panic!` macro. Enter the new test as a function named\n`another`, so your *src/lib.rs* file looks like Listing 11-3.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,panics,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-03/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 11-3: Adding a second test that will fail because\nwe call the `panic!` macro</span>\n\nRun the tests again using `cargo test`. The output should look like Listing\n11-4, which shows that our `exploration` test passed and `another` failed.\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/listing-11-03/output.txt}}\n```\n\n<span class=\"caption\">Listing 11-4: Test results when one test passes and one\ntest fails</span>\n\nInstead of `ok`, the line `test tests::another` shows `FAILED`. Two new\nsections appear between the individual results and the summary: the first\ndisplays the detailed reason for each test failure. In this case, we get the\ndetails that `another` failed because it `panicked at 'Make this test fail'` on\nline 10 in the *src/lib.rs* file. The next section lists just the names of all\nthe failing tests, which is useful when there are lots of tests and lots of\ndetailed failing test output. We can use the name of a failing test to run just\nthat test to more easily debug it; we’ll talk more about ways to run tests in\nthe [“Controlling How Tests Are Run”][controlling-how-tests-are-run]<!-- ignore\n--> section.\n\nThe summary line displays at the end: overall, our test result is `FAILED`. We\nhad one test pass and one test fail.\n\nNow that you’ve seen what the test results look like in different scenarios,\nlet’s look at some macros other than `panic!` that are useful in tests.\n\n### Checking Results with the `assert!` Macro\n\nThe `assert!` macro, provided by the standard library, is useful when you want\nto ensure that some condition in a test evaluates to `true`. We give the\n`assert!` macro an argument that evaluates to a Boolean. If the value is\n`true`, nothing happens and the test passes. If the value is `false`, the\n`assert!` macro calls `panic!` to cause the test to fail. Using the `assert!`\nmacro helps us check that our code is functioning in the way we intend.\n\nIn Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold`\nmethod, which are repeated here in Listing 11-5. Let’s put this code in the\n*src/lib.rs* file, then write some tests for it using the `assert!` macro.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-05/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 11-5: Using the `Rectangle` struct and its\n`can_hold` method from Chapter 5</span>\n\nThe `can_hold` method returns a Boolean, which means it’s a perfect use case\nfor the `assert!` macro. In Listing 11-6, we write a test that exercises the\n`can_hold` method by creating a `Rectangle` instance that has a width of 8 and\na height of 7 and asserting that it can hold another `Rectangle` instance that\nhas a width of 5 and a height of 1.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-06/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 11-6: A test for `can_hold` that checks whether a\nlarger rectangle can indeed hold a smaller rectangle</span>\n\nNote that we’ve added a new line inside the `tests` module: `use super::*;`.\nThe `tests` module is a regular module that follows the usual visibility rules\nwe covered in Chapter 7 in the [“Paths for Referring to an Item in the Module\nTree”][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore -->\nsection. Because the `tests` module is an inner module, we need to bring the\ncode under test in the outer module into the scope of the inner module. We use\na glob here so anything we define in the outer module is available to this\n`tests` module.\n\nWe’ve named our test `larger_can_hold_smaller`, and we’ve created the two\n`Rectangle` instances that we need. Then we called the `assert!` macro and\npassed it the result of calling `larger.can_hold(&smaller)`. This expression is\nsupposed to return `true`, so our test should pass. Let’s find out!\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/listing-11-06/output.txt}}\n```\n\nIt does pass! Let’s add another test, this time asserting that a smaller\nrectangle cannot hold a larger rectangle:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/src/lib.rs:here}}\n```\n\nBecause the correct result of the `can_hold` function in this case is `false`,\nwe need to negate that result before we pass it to the `assert!` macro. As a\nresult, our test will pass if `can_hold` returns `false`:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/output.txt}}\n```\n\nTwo tests that pass! Now let’s see what happens to our test results when we\nintroduce a bug in our code. We’ll change the implementation of the `can_hold`\nmethod by replacing the greater-than sign with a less-than sign when it\ncompares the widths:\n\n```rust,not_desired_behavior,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/src/lib.rs:here}}\n```\n\nRunning the tests now produces the following:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/output.txt}}\n```\n\nOur tests caught the bug! Because `larger.width` is 8 and `smaller.width` is\n5, the comparison of the widths in `can_hold` now returns `false`: 8 is not\nless than 5.\n\n### Testing Equality with the `assert_eq!` and `assert_ne!` Macros\n\nA common way to verify functionality is to test for equality between the result\nof the code under test and the value you expect the code to return. You could\ndo this using the `assert!` macro and passing it an expression using the `==`\noperator. However, this is such a common test that the standard library\nprovides a pair of macros—`assert_eq!` and `assert_ne!`—to perform this test\nmore conveniently. These macros compare two arguments for equality or\ninequality, respectively. They’ll also print the two values if the assertion\nfails, which makes it easier to see *why* the test failed; conversely, the\n`assert!` macro only indicates that it got a `false` value for the `==`\nexpression, without printing the values that led to the `false` value.\n\nIn Listing 11-7, we write a function named `add_two` that adds `2` to its\nparameter, then we test this function using the `assert_eq!` macro.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-07/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 11-7: Testing the function `add_two` using the\n`assert_eq!` macro</span>\n\nLet’s check that it passes!\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/listing-11-07/output.txt}}\n```\n\nWe pass `4` as the argument to `assert_eq!`, which is equal to the result of\ncalling `add_two(2)`. The line for this test is `test tests::it_adds_two ...\nok`, and the `ok` text indicates that our test passed!\n\nLet’s introduce a bug into our code to see what `assert_eq!` looks like when it\nfails. Change the implementation of the `add_two` function to instead add `3`:\n\n```rust,not_desired_behavior,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/src/lib.rs:here}}\n```\n\nRun the tests again:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/output.txt}}\n```\n\nOur test caught the bug! The `it_adds_two` test failed, and the message tells\nus that the assertion that fails was `` assertion failed: `(left == right)` ``\nand what the `left` and `right` values are. This message helps us start\ndebugging: the `left` argument was `4` but the `right` argument, where we had\n`add_two(2)`, was `5`. You can imagine that this would be especially helpful\nwhen we have a lot of tests going on.\n\nNote that in some languages and test frameworks, the parameters to equality\nassertion functions are called `expected` and `actual`, and the order in which\nwe specify the arguments matters. However, in Rust, they’re called `left` and\n`right`, and the order in which we specify the value we expect and the value\nthe code produces doesn’t matter. We could write the assertion in this test as\n`assert_eq!(add_two(2), 4)`, which would result in the same failure message\nthat displays `` assertion failed: `(left == right)` ``.\n\nThe `assert_ne!` macro will pass if the two values we give it are not equal and\nfail if they’re equal. This macro is most useful for cases when we’re not sure\nwhat a value *will* be, but we know what the value definitely *shouldn’t* be.\nFor example, if we’re testing a function that is guaranteed to change its input\nin some way, but the way in which the input is changed depends on the day of\nthe week that we run our tests, the best thing to assert might be that the\noutput of the function is not equal to the input.\n\nUnder the surface, the `assert_eq!` and `assert_ne!` macros use the operators\n`==` and `!=`, respectively. When the assertions fail, these macros print their\narguments using debug formatting, which means the values being compared must\nimplement the `PartialEq` and `Debug` traits. All primitive types and most of\nthe standard library types implement these traits. For structs and enums that\nyou define yourself, you’ll need to implement `PartialEq` to assert equality of\nthose types. You’ll also need to implement `Debug` to print the values when the\nassertion fails. Because both traits are derivable traits, as mentioned in\nListing 5-12 in Chapter 5, this is usually as straightforward as adding the\n`#[derive(PartialEq, Debug)]` annotation to your struct or enum definition. See\nAppendix C, [“Derivable Traits,”][derivable-traits]<!-- ignore --> for more\ndetails about these and other derivable traits.\n\n### Adding Custom Failure Messages\n\nYou can also add a custom message to be printed with the failure message as\noptional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. Any\narguments specified after the required arguments are passed along to the\n`format!` macro (discussed in Chapter 8 in the [“Concatenation with the `+`\nOperator or the `format!`\nMacro”][concatenation-with-the--operator-or-the-format-macro]<!-- ignore -->\nsection), so you can pass a format string that contains `{}` placeholders and\nvalues to go in those placeholders. Custom messages are useful for documenting\nwhat an assertion means; when a test fails, you’ll have a better idea of what\nthe problem is with the code.\n\nFor example, let’s say we have a function that greets people by name and we\nwant to test that the name we pass into the function appears in the output:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-05-greeter/src/lib.rs}}\n```\n\nThe requirements for this program haven’t been agreed upon yet, and we’re\npretty sure the `Hello` text at the beginning of the greeting will change. We\ndecided we don’t want to have to update the test when the requirements change,\nso instead of checking for exact equality to the value returned from the\n`greeting` function, we’ll just assert that the output contains the text of the\ninput parameter.\n\nNow let’s introduce a bug into this code by changing `greeting` to exclude\n`name` to see what the default test failure looks like:\n\n```rust,not_desired_behavior,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/src/lib.rs:here}}\n```\n\nRunning this test produces the following:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt}}\n```\n\nThis result just indicates that the assertion failed and which line the\nassertion is on. A more useful failure message would print the value from the\n`greeting` function. Let’s add a custom failure message composed of a format\nstring with a placeholder filled in with the actual value we got from the\n`greeting` function:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/src/lib.rs:here}}\n```\n\nNow when we run the test, we’ll get a more informative error message:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/output.txt}}\n```\n\nWe can see the value we actually got in the test output, which would help us\ndebug what happened instead of what we were expecting to happen.\n\n### Checking for Panics with `should_panic`\n\nIn addition to checking return values, it’s important to check that our code\nhandles error conditions as we expect. For example, consider the `Guess` type\nthat we created in Chapter 9, Listing 9-13. Other code that uses `Guess`\ndepends on the guarantee that `Guess` instances will contain only values\nbetween 1 and 100. We can write a test that ensures that attempting to create a\n`Guess` instance with a value outside that range panics.\n\nWe do this by adding the attribute `should_panic` to our test function. The\ntest passes if the code inside the function panics; the test fails if the code\ninside the function doesn’t panic.\n\nListing 11-8 shows a test that checks that the error conditions of `Guess::new`\nhappen when we expect them to.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-08/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 11-8: Testing that a condition will cause a\n`panic!`</span>\n\nWe place the `#[should_panic]` attribute after the `#[test]` attribute and\nbefore the test function it applies to. Let’s look at the result when this test\npasses:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/listing-11-08/output.txt}}\n```\n\nLooks good! Now let’s introduce a bug in our code by removing the condition\nthat the `new` function will panic if the value is greater than 100:\n\n```rust,not_desired_behavior,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/src/lib.rs:here}}\n```\n\nWhen we run the test in Listing 11-8, it will fail:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/output.txt}}\n```\n\nWe don’t get a very helpful message in this case, but when we look at the test\nfunction, we see that it’s annotated with `#[should_panic]`. The failure we got\nmeans that the code in the test function did not cause a panic.\n\nTests that use `should_panic` can be imprecise. A `should_panic` test would\npass even if the test panics for a different reason from the one we were\nexpecting. To make `should_panic` tests more precise, we can add an optional\n`expected` parameter to the `should_panic` attribute. The test harness will\nmake sure that the failure message contains the provided text. For example,\nconsider the modified code for `Guess` in Listing 11-9 where the `new` function\npanics with different messages depending on whether the value is too small or\ntoo large.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-09/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 11-9: Testing for a `panic!` with a panic message\ncontaining a specified substring</span>\n\nThis test will pass because the value we put in the `should_panic` attribute’s\n`expected` parameter is a substring of the message that the `Guess::new`\nfunction panics with. We could have specified the entire panic message that we\nexpect, which in this case would be `Guess value must be less than or equal to\n100, got 200.` What you choose to specify depends on how much of the panic\nmessage is unique or dynamic and how precise you want your test to be. In this\ncase, a substring of the panic message is enough to ensure that the code in the\ntest function executes the `else if value > 100` case.\n\nTo see what happens when a `should_panic` test with an `expected` message\nfails, let’s again introduce a bug into our code by swapping the bodies of the\n`if value < 1` and the `else if value > 100` blocks:\n\n```rust,ignore,not_desired_behavior\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/src/lib.rs:here}}\n```\n\nThis time when we run the `should_panic` test, it will fail:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/output.txt}}\n```\n\nThe failure message indicates that this test did indeed panic as we expected,\nbut the panic message did not include the expected string `'Guess value must be\nless than or equal to 100'`. The panic message that we did get in this case was\n`Guess value must be greater than or equal to 1, got 200.` Now we can start\nfiguring out where our bug is!\n\n### Using `Result<T, E>` in Tests\n\nOur tests so far all panic when they fail. We can also write tests that use\n`Result<T, E>`! Here’s the test from Listing 11-1, rewritten to use `Result<T,\nE>` and return an `Err` instead of panicking:\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-10-result-in-tests/src/lib.rs}}\n```\n\nThe `it_works` function now has the `Result<(), String>` return type. In the\nbody of the function, rather than calling the `assert_eq!` macro, we return\n`Ok(())` when the test passes and an `Err` with a `String` inside when the test\nfails.\n\nWriting tests so they return a `Result<T, E>` enables you to use the question\nmark operator in the body of tests, which can be a convenient way to write\ntests that should fail if any operation within them returns an `Err` variant.\n\nYou can’t use the `#[should_panic]` annotation on tests that use `Result<T,\nE>`. To assert that an operation returns an `Err` variant, *don’t* use the\nquestion mark operator on the `Result<T, E>` value. Instead, use\n`assert!(value.is_err())`.\n\nNow that you know several ways to write tests, let’s look at what is happening\nwhen we run our tests and explore the different options we can use with `cargo\ntest`.\n\n[concatenation-with-the--operator-or-the-format-macro]:\nch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro\n[bench]: ../unstable-book/library-features/test.html\n[ignoring]: ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested\n[subset]: ch11-02-running-tests.html#running-a-subset-of-tests-by-name\n[controlling-how-tests-are-run]:\nch11-02-running-tests.html#controlling-how-tests-are-run\n[derivable-traits]: appendix-03-derivable-traits.html\n[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests\n[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\n",
          "document_id": 52
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What does 'cargo run' do?",
              "id": 2094,
              "answers": [
                {
                  "answer_id": 2098,
                  "document_id": 53,
                  "question_id": 2094,
                  "text": "compiles your code and then runs the resulting binary",
                  "answer_start": 54,
                  "answer_end": 107,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the default behavior of 'cargo test'?",
              "id": 2095,
              "answers": [
                {
                  "answer_id": 2099,
                  "document_id": 53,
                  "question_id": 2095,
                  "text": "run\nall the tests in parallel and capture output generated during test runs",
                  "answer_start": 256,
                  "answer_end": 331,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I check options of 'cargo test'?",
              "id": 2096,
              "answers": [
                {
                  "answer_id": 2100,
                  "document_id": 53,
                  "question_id": 2096,
                  "text": " `cargo test --help`",
                  "answer_start": 787,
                  "answer_end": 807,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I add arguments to 'cargo test'?",
              "id": 2097,
              "answers": [
                {
                  "answer_id": 2101,
                  "document_id": 53,
                  "question_id": 2097,
                  "text": "`cargo test` followed by the separator `--`",
                  "answer_start": 690,
                  "answer_end": 733,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How do parallel tests run by default?",
              "id": 2098,
              "answers": [
                {
                  "answer_id": 2102,
                  "document_id": 53,
                  "question_id": 2098,
                  "text": "they run in parallel using threads",
                  "answer_start": 1038,
                  "answer_end": 1072,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to change number of threads used to perform tests?",
              "id": 2099,
              "answers": [
                {
                  "answer_id": 2103,
                  "document_id": 53,
                  "question_id": 2099,
                  "text": "`--test-threads` flag\nand the number of threads you want to use",
                  "answer_start": 2176,
                  "answer_end": 2239,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can tests depend on each other?",
              "id": 2100,
              "answers": [
                {
                  "answer_id": 2104,
                  "document_id": 53,
                  "question_id": 2100,
                  "text": "you must make sure your tests don’t depend\non each other or on any shared state, including a shared environment, such as\nthe current working directory or environment variables.",
                  "answer_start": 1187,
                  "answer_end": 1363,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to make sure that tests don't interfere each other?",
              "id": 2101,
              "answers": [
                {
                  "answer_id": 2105,
                  "document_id": 53,
                  "question_id": 2101,
                  "text": "set the number of test threads to `1`",
                  "answer_start": 2351,
                  "answer_end": 2388,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What happens by default when test passes?",
              "id": 2102,
              "answers": [
                {
                  "answer_id": 2106,
                  "document_id": 53,
                  "question_id": 2102,
                  "text": "test library captures anything printed to\nstandard output",
                  "answer_start": 2655,
                  "answer_end": 2712,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is showed by default when test fails?",
              "id": 2103,
              "answers": [
                {
                  "answer_id": 2107,
                  "document_id": 53,
                  "question_id": 2103,
                  "text": "we’ll see whatever was\nprinted to standard output with the rest of the failure message",
                  "answer_start": 2905,
                  "answer_end": 2991,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to enable printing output of passed tests?",
              "id": 2104,
              "answers": [
                {
                  "answer_id": 2108,
                  "document_id": 53,
                  "question_id": 2104,
                  "text": "cargo test -- --show-output",
                  "answer_start": 4052,
                  "answer_end": 4079,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to run only selected set of tests?",
              "id": 2105,
              "answers": [
                {
                  "answer_id": 2109,
                  "document_id": 53,
                  "question_id": 2105,
                  "text": "`cargo test` the name\nor names of the test(s) you want to run as an argument",
                  "answer_start": 4552,
                  "answer_end": 4628,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What will happen when no parameters are passed when running tests?",
              "id": 2106,
              "answers": [
                {
                  "answer_id": 2110,
                  "document_id": 53,
                  "question_id": 2106,
                  "text": "all the\ntests will run in parallel",
                  "answer_start": 5112,
                  "answer_end": 5146,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to run only one selected test?",
              "id": 2107,
              "answers": [
                {
                  "answer_id": 2111,
                  "document_id": 53,
                  "question_id": 2107,
                  "text": "pass the name of any test function to `cargo test` to run only that test",
                  "answer_start": 5278,
                  "answer_end": 5350,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is it possible to run selected tests without having to pass all functions names in parameters?",
              "id": 2108,
              "answers": [
                {
                  "answer_id": 2112,
                  "document_id": 53,
                  "question_id": 2108,
                  "text": "We can specify part of a test name, and any test whose name matches that value\nwill be run. For example, because two of our tests’ names contain `add`, we can\nrun those two by running `cargo test add`",
                  "answer_start": 5855,
                  "answer_end": 6055,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I run all tests only with few of them excluded?",
              "id": 2109,
              "answers": [
                {
                  "answer_id": 2113,
                  "document_id": 53,
                  "question_id": 2109,
                  "text": "annotate the\ntime-consuming tests using the `ignore` attribute to exclude them",
                  "answer_start": 6697,
                  "answer_end": 6775,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to run ignored tests only?",
              "id": 2110,
              "answers": [
                {
                  "answer_id": 2114,
                  "document_id": 53,
                  "question_id": 2110,
                  "text": "cargo test -- --ignored",
                  "answer_start": 7713,
                  "answer_end": 7736,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Controlling How Tests Are Run\n\nJust as `cargo run` compiles your code and then runs the resulting binary,\n`cargo test` compiles your code in test mode and runs the resulting test\nbinary. The default behavior of the binary produced by `cargo test` is to run\nall the tests in parallel and capture output generated during test runs,\npreventing the output from being displayed and making it easier to read the\noutput related to the test results. You can, however, specify command line\noptions to change this default behavior.\n\nSome command line options go to `cargo test`, and some go to the resulting test\nbinary. To separate these two types of arguments, you list the arguments that\ngo to `cargo test` followed by the separator `--` and then the ones that go to\nthe test binary. Running `cargo test --help` displays the options you can use\nwith `cargo test`, and running `cargo test -- --help` displays the options you\ncan use after the separator.\n\n### Running Tests in Parallel or Consecutively\n\nWhen you run multiple tests, by default they run in parallel using threads,\nmeaning they finish running faster and you get feedback quicker. Because the\ntests are running at the same time, you must make sure your tests don’t depend\non each other or on any shared state, including a shared environment, such as\nthe current working directory or environment variables.\n\nFor example, say each of your tests runs some code that creates a file on disk\nnamed *test-output.txt* and writes some data to that file. Then each test reads\nthe data in that file and asserts that the file contains a particular value,\nwhich is different in each test. Because the tests run at the same time, one\ntest might overwrite the file in the time between another test writing and\nreading the file. The second test will then fail, not because the code is\nincorrect but because the tests have interfered with each other while running\nin parallel. One solution is to make sure each test writes to a different file;\nanother solution is to run the tests one at a time.\n\nIf you don’t want to run the tests in parallel or if you want more fine-grained\ncontrol over the number of threads used, you can send the `--test-threads` flag\nand the number of threads you want to use to the test binary. Take a look at\nthe following example:\n\n```console\n$ cargo test -- --test-threads=1\n```\n\nWe set the number of test threads to `1`, telling the program not to use any\nparallelism. Running the tests using one thread will take longer than running\nthem in parallel, but the tests won’t interfere with each other if they share\nstate.\n\n### Showing Function Output\n\nBy default, if a test passes, Rust’s test library captures anything printed to\nstandard output. For example, if we call `println!` in a test and the test\npasses, we won’t see the `println!` output in the terminal; we’ll see only the\nline that indicates the test passed. If a test fails, we’ll see whatever was\nprinted to standard output with the rest of the failure message.\n\nAs an example, Listing 11-10 has a silly function that prints the value of its\nparameter and returns 10, as well as a test that passes and a test that fails.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,panics,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-10/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 11-10: Tests for a function that calls\n`println!`</span>\n\nWhen we run these tests with `cargo test`, we’ll see the following output:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/listing-11-10/output.txt}}\n```\n\nNote that nowhere in this output do we see `I got the value 4`, which is what\nis printed when the test that passes runs. That output has been captured. The\noutput from the test that failed, `I got the value 8`, appears in the section\nof the test summary output, which also shows the cause of the test failure.\n\nIf we want to see printed values for passing tests as well, we can tell Rust\nto also show the output of successful tests with `--show-output`.\n\n```console\n$ cargo test -- --show-output\n```\n\nWhen we run the tests in Listing 11-10 again with the `--show-output` flag, we\nsee the following output:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/output-only-01-show-output/output.txt}}\n```\n\n### Running a Subset of Tests by Name\n\nSometimes, running a full test suite can take a long time. If you’re working on\ncode in a particular area, you might want to run only the tests pertaining to\nthat code. You can choose which tests to run by passing `cargo test` the name\nor names of the test(s) you want to run as an argument.\n\nTo demonstrate how to run a subset of tests, we’ll first create three tests for\nour `add_two` function, as shown in Listing 11-11, and choose which ones to run.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-11/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 11-11: Three tests with three different\nnames</span>\n\nIf we run the tests without passing any arguments, as we saw earlier, all the\ntests will run in parallel:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/listing-11-11/output.txt}}\n```\n\n#### Running Single Tests\n\nWe can pass the name of any test function to `cargo test` to run only that test:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/output-only-02-single-test/output.txt}}\n```\n\nOnly the test with the name `one_hundred` ran; the other two tests didn’t match\nthat name. The test output lets us know we had more tests that didn’t run by\ndisplaying `2 filtered out` at the end.\n\nWe can’t specify the names of multiple tests in this way; only the first value\ngiven to `cargo test` will be used. But there is a way to run multiple tests.\n\n#### Filtering to Run Multiple Tests\n\nWe can specify part of a test name, and any test whose name matches that value\nwill be run. For example, because two of our tests’ names contain `add`, we can\nrun those two by running `cargo test add`:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/output-only-03-multiple-tests/output.txt}}\n```\n\nThis command ran all tests with `add` in the name and filtered out the test\nnamed `one_hundred`. Also note that the module in which a test appears becomes\npart of the test’s name, so we can run all the tests in a module by filtering\non the module’s name.\n\n### Ignoring Some Tests Unless Specifically Requested\n\nSometimes a few specific tests can be very time-consuming to execute, so you\nmight want to exclude them during most runs of `cargo test`. Rather than\nlisting as arguments all tests you do want to run, you can instead annotate the\ntime-consuming tests using the `ignore` attribute to exclude them, as shown\nhere:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/src/lib.rs}}\n```\n\nAfter `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now\nwhen we run our tests, `it_works` runs, but `expensive_test` doesn’t:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/output.txt}}\n```\n\nThe `expensive_test` function is listed as `ignored`. If we want to run only\nthe ignored tests, we can use `cargo test -- --ignored`:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/output-only-04-running-ignored/output.txt}}\n```\n\nBy controlling which tests run, you can make sure your `cargo test` results\nwill be fast. When you’re at a point where it makes sense to check the results\nof the `ignored` tests and you have time to wait for the results, you can run\n`cargo test -- --ignored` instead. If you want to run all tests whether they’re\nignored or not, you can run `cargo test -- --include-ignored`.\n",
          "document_id": 53
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What types of tests are possible to perform in Rust?",
              "id": 2163,
              "answers": [
                {
                  "answer_id": 2168,
                  "document_id": 54,
                  "question_id": 2163,
                  "text": "unit tests and integration\ntests",
                  "answer_start": 233,
                  "answer_end": 265,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are unit tests?",
              "id": 2164,
              "answers": [
                {
                  "answer_id": 2169,
                  "document_id": 54,
                  "question_id": 2164,
                  "text": "small and more focused, testing one module in isolation\nat a time, and can test private interfaces",
                  "answer_start": 284,
                  "answer_end": 382,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are integration tests?",
              "id": 2165,
              "answers": [
                {
                  "answer_id": 2170,
                  "document_id": 54,
                  "question_id": 2165,
                  "text": "using only the public interface and potentially exercising multiple\nmodules per test",
                  "answer_start": 507,
                  "answer_end": 591,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are unit tests used for?",
              "id": 2166,
              "answers": [
                {
                  "answer_id": 2171,
                  "document_id": 54,
                  "question_id": 2166,
                  "text": "The purpose of unit tests is to test each unit of code in isolation from the\nrest of the code to quickly pinpoint where code is and isn’t working as\nexpected. ",
                  "answer_start": 754,
                  "answer_end": 913,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Where to put unit tests in Rust?",
              "id": 2167,
              "answers": [
                {
                  "answer_id": 2172,
                  "document_id": 54,
                  "question_id": 2167,
                  "text": "in the *src* directory in each file with the\ncode that they’re testing",
                  "answer_start": 935,
                  "answer_end": 1005,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the naming convention of tests in Rust?",
              "id": 2168,
              "answers": [
                {
                  "answer_id": 2173,
                  "document_id": 54,
                  "question_id": 2168,
                  "text": "to create a module named `tests`\nin each file to contain the test functions and to annotate the module with\n`cfg(test)`.",
                  "answer_start": 1025,
                  "answer_end": 1145,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the purpose of #[cfg(test)] annotation?",
              "id": 2169,
              "answers": [
                {
                  "answer_id": 2174,
                  "document_id": 54,
                  "question_id": 2169,
                  "text": " tells Rust to compile and run\nthe test code only when you run `cargo test`, not when you run `cargo build`.",
                  "answer_start": 1238,
                  "answer_end": 1346,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Do integration tests need #[cfg(test)] annotation?",
              "id": 2170,
              "answers": [
                {
                  "answer_id": 2175,
                  "document_id": 54,
                  "question_id": 2170,
                  "text": "they don’t need\nthe `#[cfg(test)]` annotation",
                  "answer_start": 1569,
                  "answer_end": 1614,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is it possible to test private functions?",
              "id": 2171,
              "answers": [
                {
                  "answer_id": 2176,
                  "document_id": 54,
                  "question_id": 2171,
                  "text": "Rust’s privacy rules do allow you to test private functions",
                  "answer_start": 2885,
                  "answer_end": 2944,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the purpose of integration tests?",
              "id": 2172,
              "answers": [
                {
                  "answer_id": 2177,
                  "document_id": 54,
                  "question_id": 2172,
                  "text": "to test\nwhether many parts of your library work together correctly",
                  "answer_start": 4080,
                  "answer_end": 4146,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to run all the tests in particular integration test file?",
              "id": 2173,
              "answers": [
                {
                  "answer_id": 2178,
                  "document_id": 54,
                  "question_id": 2173,
                  "text": "use the `--test` argument of `cargo test`\nfollowed by the name of the file:",
                  "answer_start": 7030,
                  "answer_end": 7105,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What could I use to better organize tests?",
              "id": 2174,
              "answers": [
                {
                  "answer_id": 2179,
                  "document_id": 54,
                  "question_id": 2174,
                  "text": "Submodules in Integration Tests",
                  "answer_start": 7302,
                  "answer_end": 7333,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Test Organization\n\nAs mentioned at the start of the chapter, testing is a complex discipline, and\ndifferent people use different terminology and organization. The Rust community\nthinks about tests in terms of two main categories: unit tests and integration\ntests. *Unit tests* are small and more focused, testing one module in isolation\nat a time, and can test private interfaces. *Integration tests* are entirely\nexternal to your library and use your code in the same way any other external\ncode would, using only the public interface and potentially exercising multiple\nmodules per test.\n\nWriting both kinds of tests is important to ensure that the pieces of your\nlibrary are doing what you expect them to, separately and together.\n\n### Unit Tests\n\nThe purpose of unit tests is to test each unit of code in isolation from the\nrest of the code to quickly pinpoint where code is and isn’t working as\nexpected. You’ll put unit tests in the *src* directory in each file with the\ncode that they’re testing. The convention is to create a module named `tests`\nin each file to contain the test functions and to annotate the module with\n`cfg(test)`.\n\n#### The Tests Module and `#[cfg(test)]`\n\nThe `#[cfg(test)]` annotation on the tests module tells Rust to compile and run\nthe test code only when you run `cargo test`, not when you run `cargo build`.\nThis saves compile time when you only want to build the library and saves space\nin the resulting compiled artifact because the tests are not included. You’ll\nsee that because integration tests go in a different directory, they don’t need\nthe `#[cfg(test)]` annotation. However, because unit tests go in the same files\nas the code, you’ll use `#[cfg(test)]` to specify that they shouldn’t be\nincluded in the compiled result.\n\nRecall that when we generated the new `adder` project in the first section of\nthis chapter, Cargo generated this code for us:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}\n```\n\nThis code is the automatically generated test module. The attribute `cfg`\nstands for *configuration* and tells Rust that the following item should only\nbe included given a certain configuration option. In this case, the\nconfiguration option is `test`, which is provided by Rust for compiling and\nrunning tests. By using the `cfg` attribute, Cargo compiles our test code only\nif we actively run the tests with `cargo test`. This includes any helper\nfunctions that might be within this module, in addition to the functions\nannotated with `#[test]`.\n\n#### Testing Private Functions\n\nThere’s debate within the testing community about whether or not private\nfunctions should be tested directly, and other languages make it difficult or\nimpossible to test private functions. Regardless of which testing ideology you\nadhere to, Rust’s privacy rules do allow you to test private functions.\nConsider the code in Listing 11-12 with the private function `internal_adder`.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 11-12: Testing a private function</span>\n\nNote that the `internal_adder` function is not marked as `pub`. Tests are just\nRust code, and the `tests` module is just another module. As we discussed in\nthe [“Paths for Referring to an Item in the Module Tree”][paths]<!-- ignore -->\nsection, items in child modules can use the items in their ancestor modules. In\nthis test, we bring all of the `test` module’s parent’s items into scope with\n`use super::*`, and then the test can call `internal_adder`. If you don’t think\nprivate functions should be tested, there’s nothing in Rust that will compel\nyou to do so.\n\n### Integration Tests\n\nIn Rust, integration tests are entirely external to your library. They use your\nlibrary in the same way any other code would, which means they can only call\nfunctions that are part of your library’s public API. Their purpose is to test\nwhether many parts of your library work together correctly. Units of code that\nwork correctly on their own could have problems when integrated, so test\ncoverage of the integrated code is important as well. To create integration\ntests, you first need a *tests* directory.\n\n#### The *tests* Directory\n\nWe create a *tests* directory at the top level of our project directory, next\nto *src*. Cargo knows to look for integration test files in this directory. We\ncan then make as many test files as we want, and Cargo will compile each of the\nfiles as an individual crate.\n\nLet’s create an integration test. With the code in Listing 11-12 still in the\n*src/lib.rs* file, make a *tests* directory, and create a new file named\n*tests/integration_test.rs*. Your directory structure should look like this:\n\n```text\nadder\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── lib.rs\n└── tests\n    └── integration_test.rs\n```\n\nEnter the code in Listing 11-13 into the *tests/integration_test.rs* file:\n\n<span class=\"filename\">Filename: tests/integration_test.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}\n```\n\n<span class=\"caption\">Listing 11-13: An integration test of a function in the\n`adder` crate</span>\n\nEach file in the `tests` directory is a separate crate, so we need to bring our\nlibrary into each test crate’s scope. For that reason we add `use adder` at the\ntop of the code, which we didn’t need in the unit tests.\n\nWe don’t need to annotate any code in *tests/integration_test.rs* with\n`#[cfg(test)]`. Cargo treats the `tests` directory specially and compiles files\nin this directory only when we run `cargo test`. Run `cargo test` now:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}\n```\n\nThe three sections of output include the unit tests, the integration test, and\nthe doc tests. Note that if any test in a section fails, the following sections\nwill not be run. For example, if a unit test fails, there won’t be any output\nfor integration and doc tests because those tests will only be run if all unit\ntests are passing.\n\nThe first section for the unit tests is the same as we’ve been seeing: one line\nfor each unit test (one named `internal` that we added in Listing 11-12) and\nthen a summary line for the unit tests.\n\nThe integration tests section starts with the line `Running\ntests/integration_test.rs`. Next, there is a line for each test function in\nthat integration test and a summary line for the results of the integration\ntest just before the `Doc-tests adder` section starts.\n\nEach integration test file has its own section, so if we add more files in the\n*tests* directory, there will be more integration test sections.\n\nWe can still run a particular integration test function by specifying the test\nfunction’s name as an argument to `cargo test`. To run all the tests in a\nparticular integration test file, use the `--test` argument of `cargo test`\nfollowed by the name of the file:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}\n```\n\nThis command runs only the tests in the *tests/integration_test.rs* file.\n\n#### Submodules in Integration Tests\n\nAs you add more integration tests, you might want to make more files in the\n*tests* directory to help organize them; for example, you can group the test\nfunctions by the functionality they’re testing. As mentioned earlier, each file\nin the *tests* directory is compiled as its own separate crate, which is useful\nfor creating separate scopes to more closely imitate the way end users will be\nusing your crate. However, this means files in the *tests* directory don’t\nshare the same behavior as files in *src* do, as you learned in Chapter 7\nregarding how to separate code into modules and files.\n\nThe different behavior of *tests* directory files is most noticeable when you\nhave a set of helper functions to use in multiple integration test files and\nyou try to follow the steps in the [“Separating Modules into Different\nFiles”][separating-modules-into-files]<!-- ignore --> section of Chapter 7 to\nextract them into a common module. For example, if we create *tests/common.rs*\nand place a function named `setup` in it, we can add some code to `setup` that\nwe want to call from multiple test functions in multiple test files:\n\n<span class=\"filename\">Filename: tests/common.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}\n```\n\nWhen we run the tests again, we’ll see a new section in the test output for the\n*common.rs* file, even though this file doesn’t contain any test functions nor\ndid we call the `setup` function from anywhere:\n\n```console\n{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}\n```\n\nHaving `common` appear in the test results with `running 0 tests` displayed for\nit is not what we wanted. We just wanted to share some code with the other\nintegration test files.\n\nTo avoid having `common` appear in the test output, instead of creating\n*tests/common.rs*, we’ll create *tests/common/mod.rs*. The project directory\nnow looks like this:\n\n```text\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── lib.rs\n└── tests\n    ├── common\n    │   └── mod.rs\n    └── integration_test.rs\n```\n\nThis is the older naming convention that Rust also understands that we\nmentioned in the [“Alternate File Paths”][alt-paths]<!-- ignore --> section of\nChapter 7. Naming the file this way tells Rust not to treat the `common` module\nas an integration test file. When we move the `setup` function code into\n*tests/common/mod.rs* and delete the *tests/common.rs* file, the section in the\ntest output will no longer appear. Files in subdirectories of the *tests*\ndirectory don’t get compiled as separate crates or have sections in the test\noutput.\n\nAfter we’ve created *tests/common/mod.rs*, we can use it from any of the\nintegration test files as a module. Here’s an example of calling the `setup`\nfunction from the `it_adds_two` test in *tests/integration_test.rs*:\n\n<span class=\"filename\">Filename: tests/integration_test.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}\n```\n\nNote that the `mod common;` declaration is the same as the module declaration\nwe demonstrated in Listing 7-21. Then in the test function, we can call the\n`common::setup()` function.\n\n#### Integration Tests for Binary Crates\n\nIf our project is a binary crate that only contains a *src/main.rs* file and\ndoesn’t have a *src/lib.rs* file, we can’t create integration tests in the\n*tests* directory and bring functions defined in the *src/main.rs* file into\nscope with a `use` statement. Only library crates expose functions that other\ncrates can use; binary crates are meant to be run on their own.\n\nThis is one of the reasons Rust projects that provide a binary have a\nstraightforward *src/main.rs* file that calls logic that lives in the\n*src/lib.rs* file. Using that structure, integration tests *can* test the\nlibrary crate with `use` to make the important functionality available.\nIf the important functionality works, the small amount of code in the\n*src/main.rs* file will work as well, and that small amount of code doesn’t\nneed to be tested.\n\n## Summary\n\nRust’s testing features provide a way to specify how code should function to\nensure it continues to work as you expect, even as you make changes. Unit tests\nexercise different parts of a library separately and can test private\nimplementation details. Integration tests check that many parts of the library\nwork together correctly, and they use the library’s public API to test the code\nin the same way external code will use it. Even though Rust’s type system and\nownership rules help prevent some kinds of bugs, tests are still important to\nreduce logic bugs having to do with how your code is expected to behave.\n\nLet’s combine the knowledge you learned in this chapter and in previous\nchapters to work on a project!\n\n[paths]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\n[separating-modules-into-files]:\nch07-05-separating-modules-into-different-files.html\n[alt-paths]: ch07-05-separating-modules-into-different-files.html#alternate-file-paths\n",
          "document_id": 54
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What is the name of error stream?",
              "id": 2111,
              "answers": [
                {
                  "answer_id": 2115,
                  "document_id": 55,
                  "question_id": 2111,
                  "text": "stderr",
                  "answer_start": 1181,
                  "answer_end": 1187,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the name of standard output?",
              "id": 2112,
              "answers": [
                {
                  "answer_id": 2116,
                  "document_id": 55,
                  "question_id": 2112,
                  "text": "stdout",
                  "answer_start": 1219,
                  "answer_end": 1225,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which parameters takes 'grep' for file search?",
              "id": 2113,
              "answers": [
                {
                  "answer_id": 2117,
                  "document_id": 55,
                  "question_id": 2113,
                  "text": "a file path and a string",
                  "answer_start": 745,
                  "answer_end": 769,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the purpose of stderr?",
              "id": 2114,
              "answers": [
                {
                  "answer_id": 2118,
                  "document_id": 55,
                  "question_id": 2114,
                  "text": "print error messages",
                  "answer_start": 1121,
                  "answer_end": 1141,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "# An I/O Project: Building a Command Line Program\n\nThis chapter is a recap of the many skills you’ve learned so far and an\nexploration of a few more standard library features. We’ll build a command line\ntool that interacts with file and command line input/output to practice some of\nthe Rust concepts you now have under your belt.\n\nRust’s speed, safety, single binary output, and cross-platform support make it\nan ideal language for creating command line tools, so for our project, we’ll\nmake our own version of the classic command line search tool `grep`\n(**g**lobally search a **r**egular **e**xpression and **p**rint). In the\nsimplest use case, `grep` searches a specified file for a specified string. To\ndo so, `grep` takes as its arguments a file path and a string. Then it reads\nthe file, finds lines in that file that contain the string argument, and prints\nthose lines.\n\nAlong the way, we’ll show how to make our command line tool use the terminal\nfeatures that many other command line tools use. We’ll read the value of an\nenvironment variable to allow the user to configure the behavior of our tool.\nWe’ll also print error messages to the standard error console stream (`stderr`)\ninstead of standard output (`stdout`), so, for example, the user can redirect\nsuccessful output to a file while still seeing error messages onscreen.\n\nOne Rust community member, Andrew Gallant, has already created a fully\nfeatured, very fast version of `grep`, called `ripgrep`. By comparison, our\nversion will be fairly simple, but this chapter will give you some of the\nbackground knowledge you need to understand a real-world project such as\n`ripgrep`.\n\nOur `grep` project will combine a number of concepts you’ve learned so far:\n\n* Organizing code (using what you learned about modules in [Chapter 7][ch7]<!--\n  ignore -->)\n* Using vectors and strings (collections, [Chapter 8][ch8]<!-- ignore -->)\n* Handling errors ([Chapter 9][ch9]<!-- ignore -->)\n* Using traits and lifetimes where appropriate ([Chapter 10][ch10]<!-- ignore\n  -->)\n* Writing tests ([Chapter 11][ch11]<!-- ignore -->)\n\nWe’ll also briefly introduce closures, iterators, and trait objects, which\nChapters [13][ch13]<!-- ignore --> and [17][ch17]<!-- ignore --> will cover in\ndetail.\n\n[ch7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\n[ch8]: ch08-00-common-collections.html\n[ch9]: ch09-00-error-handling.html\n[ch10]: ch10-00-generics.html\n[ch11]: ch11-00-testing.html\n[ch13]: ch13-00-functional-features.html\n[ch17]: ch17-00-oop.html\n",
          "document_id": 55
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "How are command line arguments marked with?",
              "id": 2115,
              "answers": [
                {
                  "answer_id": 2120,
                  "document_id": 56,
                  "question_id": 2115,
                  "text": "two hyphens",
                  "answer_start": 499,
                  "answer_end": 510,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which function is needed to read command line arguments?",
              "id": 2116,
              "answers": [
                {
                  "answer_id": 2121,
                  "document_id": 56,
                  "question_id": 2116,
                  "text": "std::env::args",
                  "answer_start": 1160,
                  "answer_end": 1174,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Where is 'std::env::args' provided?",
              "id": 2117,
              "answers": [
                {
                  "answer_id": 2122,
                  "document_id": 56,
                  "question_id": 2117,
                  "text": "Rust’s standard\nlibrary",
                  "answer_start": 1197,
                  "answer_end": 1220,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does 'std::env::args' function return?",
              "id": 2118,
              "answers": [
                {
                  "answer_id": 2123,
                  "document_id": 56,
                  "question_id": 2118,
                  "text": "iterator of the command line arguments",
                  "answer_start": 1247,
                  "answer_end": 1285,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is an iterator?",
              "id": 2119,
              "answers": [
                {
                  "answer_id": 2124,
                  "document_id": 56,
                  "question_id": 2119,
                  "text": "a series of values",
                  "answer_start": 1452,
                  "answer_end": 1470,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the name of Rust's standard library?",
              "id": 2120,
              "answers": [
                {
                  "answer_id": 2125,
                  "document_id": 56,
                  "question_id": 2120,
                  "text": "std::env",
                  "answer_start": 2054,
                  "answer_end": 2062,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What will happen if there is invalid character in command line argument?",
              "id": 2121,
              "answers": [
                {
                  "answer_id": 2126,
                  "document_id": 56,
                  "question_id": 2121,
                  "text": "`std::env::args` will panic",
                  "answer_start": 2756,
                  "answer_end": 2783,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why do we use fuction 'collect' on iterator?",
              "id": 2122,
              "answers": [
                {
                  "answer_id": 2127,
                  "document_id": 56,
                  "question_id": 2122,
                  "text": "to turn the iterator into a vector containing all the values produced\nby the iterator",
                  "answer_start": 3277,
                  "answer_end": 3362,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the first command line argument?",
              "id": 2123,
              "answers": [
                {
                  "answer_id": 2128,
                  "document_id": 56,
                  "question_id": 2123,
                  "text": "the name of our binary",
                  "answer_start": 4099,
                  "answer_end": 4121,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to access first command line argument?",
              "id": 2124,
              "answers": [
                {
                  "answer_id": 2129,
                  "document_id": 56,
                  "question_id": 2124,
                  "text": "args[0]",
                  "answer_start": 5218,
                  "answer_end": 5225,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Accepting Command Line Arguments\n\nLet’s create a new project with, as always, `cargo new`. We’ll call our project\n`minigrep` to distinguish it from the `grep` tool that you might already have\non your system.\n\n```console\n$ cargo new minigrep\n     Created binary (application) `minigrep` project\n$ cd minigrep\n```\n\nThe first task is to make `minigrep` accept its two command line arguments: the\nfile path and a string to search for. That is, we want to be able to run our\nprogram with `cargo run`, two hyphens to indicate the following arguments are\nfor our program rather than for `cargo`, a string to search for, and a path to\na file to search in, like so:\n\n```console\n$ cargo run -- searchstring example-filename.txt\n```\n\nRight now, the program generated by `cargo new` cannot process arguments we\ngive it. Some existing libraries on [crates.io](https://crates.io/) can help\nwith writing a program that accepts command line arguments, but because you’re\njust learning this concept, let’s implement this capability ourselves.\n\n### Reading the Argument Values\n\nTo enable `minigrep` to read the values of command line arguments we pass to\nit, we’ll need the `std::env::args` function provided in Rust’s standard\nlibrary. This function returns an iterator of the command line arguments passed\nto `minigrep`. We’ll cover iterators fully in [Chapter 13][ch13]<!-- ignore\n-->. For now, you only need to know two details about iterators: iterators\nproduce a series of values, and we can call the `collect` method on an iterator\nto turn it into a collection, such as a vector, that contains all the elements\nthe iterator produces.\n\nThe code in Listing 12-1 allows your `minigrep` program to read any command\nline arguments passed to it and then collect the values into a vector.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 12-1: Collecting the command line arguments into\na vector and printing them</span>\n\nFirst, we bring the `std::env` module into scope with a `use` statement so we\ncan use its `args` function. Notice that the `std::env::args` function is\nnested in two levels of modules. As we discussed in [Chapter\n7][ch7-idiomatic-use]<!-- ignore -->, in cases where the desired function is\nnested in more than one module, we’ve chosen to bring the parent module into\nscope rather than the function. By doing so, we can easily use other functions\nfrom `std::env`. It’s also less ambiguous than adding `use std::env::args` and\nthen calling the function with just `args`, because `args` might easily be\nmistaken for a function that’s defined in the current module.\n\n> ### The `args` Function and Invalid Unicode\n>\n> Note that `std::env::args` will panic if any argument contains invalid\n> Unicode. If your program needs to accept arguments containing invalid\n> Unicode, use `std::env::args_os` instead. That function returns an iterator\n> that produces `OsString` values instead of `String` values. We’ve chosen to\n> use `std::env::args` here for simplicity, because `OsString` values differ\n> per platform and are more complex to work with than `String` values.\n\nOn the first line of `main`, we call `env::args`, and we immediately use\n`collect` to turn the iterator into a vector containing all the values produced\nby the iterator. We can use the `collect` function to create many kinds of\ncollections, so we explicitly annotate the type of `args` to specify that we\nwant a vector of strings. Although we very rarely need to annotate types in\nRust, `collect` is one function you do often need to annotate because Rust\nisn’t able to infer the kind of collection you want.\n\nFinally, we print the vector using the debug macro. Let’s try running the code\nfirst with no arguments and then with two arguments:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}\n```\n\n```console\n{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}\n```\n\nNotice that the first value in the vector is `\"target/debug/minigrep\"`, which\nis the name of our binary. This matches the behavior of the arguments list in\nC, letting programs use the name by which they were invoked in their execution.\nIt’s often convenient to have access to the program name in case you want to\nprint it in messages or change behavior of the program based on what command\nline alias was used to invoke the program. But for the purposes of this\nchapter, we’ll ignore it and save only the two arguments we need.\n\n### Saving the Argument Values in Variables\n\nThe program is currently able to access the values specified as command line\narguments. Now we need to save the values of the two arguments in variables so\nwe can use the values throughout the rest of the program. We do that in Listing\n12-2.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic,noplayground\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 12-2: Creating variables to hold the query\nargument and file path argument</span>\n\nAs we saw when we printed the vector, the program’s name takes up the first\nvalue in the vector at `args[0]`, so we’re starting arguments at index `1`. The\nfirst argument `minigrep` takes is the string we’re searching for, so we put a\nreference to the first argument in the variable `query`. The second argument\nwill be the file path, so we put a reference to the second argument in the\nvariable `file_path`.\n\nWe temporarily print the values of these variables to prove that the code is\nworking as we intend. Let’s run this program again with the arguments `test`\nand `sample.txt`:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}\n```\n\nGreat, the program is working! The values of the arguments we need are being\nsaved into the right variables. Later we’ll add some error handling to deal\nwith certain potential erroneous situations, such as when the user provides no\narguments; for now, we’ll ignore that situation and work on adding file-reading\ncapabilities instead.\n\n[ch13]: ch13-00-functional-features.html\n[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths\n",
          "document_id": 56
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What is the usage of 'std::fs'?",
              "id": 2125,
              "answers": [
                {
                  "answer_id": 2130,
                  "document_id": 57,
                  "question_id": 2125,
                  "text": "to handle files",
                  "answer_start": 1126,
                  "answer_end": 1141,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the name of module used to handle files?",
              "id": 2126,
              "answers": [
                {
                  "answer_id": 2131,
                  "document_id": 57,
                  "question_id": 2126,
                  "text": "std::fs",
                  "answer_start": 1117,
                  "answer_end": 1124,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to read the entire content of file?",
              "id": 2127,
              "answers": [
                {
                  "answer_id": 2132,
                  "document_id": 57,
                  "question_id": 2127,
                  "text": "fs::read_to_string",
                  "answer_start": 1174,
                  "answer_end": 1192,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does 'fs::read_to_string' do?",
              "id": 2128,
              "answers": [
                {
                  "answer_id": 2133,
                  "document_id": 57,
                  "question_id": 2128,
                  "text": "opens\nthat file, and returns a `std::io::Result‹String>` of the file’s contents",
                  "answer_start": 1217,
                  "answer_end": 1296,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Reading a File\n\nNow we’ll add functionality to read the file specified in the `file_path`\nargument. First, we need a sample file to test it with: we’ll use a file with a\nsmall amount of text over multiple lines with some repeated words. Listing 12-3\nhas an Emily Dickinson poem that will work well! Create a file called\n*poem.txt* at the root level of your project, and enter the poem “I’m Nobody!\nWho are you?”\n\n<span class=\"filename\">Filename: poem.txt</span>\n\n```text\n{{#include ../listings/ch12-an-io-project/listing-12-03/poem.txt}}\n```\n\n<span class=\"caption\">Listing 12-3: A poem by Emily Dickinson makes a good test\ncase</span>\n\nWith the text in place, edit *src/main.rs* and add code to read the file, as\nshown in Listing 12-4.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic,noplayground\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-04/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-4: Reading the contents of the file specified\nby the second argument</span>\n\nFirst, we bring in a relevant part of the standard library with a `use`\nstatement: we need `std::fs` to handle files.\n\nIn `main`, the new statement `fs::read_to_string` takes the `file_path`, opens\nthat file, and returns a `std::io::Result<String>` of the file’s contents.\n\nAfter that, we again add a temporary `println!` statement that prints the value\nof `contents` after the file is read, so we can check that the program is\nworking so far.\n\nLet’s run this code with any string as the first command line argument (because\nwe haven’t implemented the searching part yet) and the *poem.txt* file as the\nsecond argument:\n\n```console\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-04/output.txt}}\n```\n\nGreat! The code read and then printed the contents of the file. But the code\nhas a few flaws. At the moment, the `main` function has multiple\nresponsibilities: generally, functions are clearer and easier to maintain if\neach function is responsible for only one idea. The other problem is that we’re\nnot handling errors as well as we could. The program is still small, so these\nflaws aren’t a big problem, but as the program grows, it will be harder to fix\nthem cleanly. It’s good practice to begin refactoring early on when developing\na program, because it’s much easier to refactor smaller amounts of code. We’ll\ndo that next.\n",
          "document_id": 57
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "Are there any guidelines how to split program properly?",
              "id": 2175,
              "answers": [
                {
                  "answer_id": 2180,
                  "document_id": 58,
                  "question_id": 2175,
                  "text": "Split your program into a *main.rs* and a *lib.rs* and move your program’s\n  logic to *lib.rs*.\n* As long as your command line parsing logic is small, it can remain in\n  *main.rs*.\n* When the command line parsing logic starts getting complicated, extract it\n  from *main.rs* and move it to *lib.rs*.",
                  "answer_start": 2482,
                  "answer_end": 2781,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is is good to use 'clone'?",
              "id": 2192,
              "answers": [
                {
                  "answer_id": 2197,
                  "document_id": 58,
                  "question_id": 2192,
                  "text": "There’s a tendency among many Rustaceans to avoid using `clone` to fix\n> ownership problems because of its runtime cost.",
                  "answer_start": 7415,
                  "answer_end": 7535,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to create new instance of a type?",
              "id": 2193,
              "answers": [
                {
                  "answer_id": 2198,
                  "document_id": 58,
                  "question_id": 2193,
                  "text": "We can create instances of types in the\nstandard library, such as `String`, by calling `String::new`",
                  "answer_start": 9403,
                  "answer_end": 9503,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are benefits of using 'unwrap_or_else\"?",
              "id": 2194,
              "answers": [
                {
                  "answer_id": 2199,
                  "document_id": 58,
                  "question_id": 2194,
                  "text": "Using `unwrap_or_else` allows us to define some custom, non-`panic!` error\nhandling.",
                  "answer_start": 15635,
                  "answer_end": 15719,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the purpose of main.rs file?",
              "id": 2195,
              "answers": [
                {
                  "answer_id": 2200,
                  "document_id": 58,
                  "question_id": 2195,
                  "text": "*main.rs* handles running the\nprogram",
                  "answer_start": 3128,
                  "answer_end": 3165,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the purpose of lib.rs file?",
              "id": 2196,
              "answers": [
                {
                  "answer_id": 2201,
                  "document_id": 58,
                  "question_id": 2196,
                  "text": "handles all the logic of the task at hand",
                  "answer_start": 3180,
                  "answer_end": 3221,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Refactoring to Improve Modularity and Error Handling\n\nTo improve our program, we’ll fix four problems that have to do with the\nprogram’s structure and how it’s handling potential errors. First, our `main`\nfunction now performs two tasks: it parses arguments and reads files. As our\nprogram grows, the number of separate tasks the `main` function handles will\nincrease. As a function gains responsibilities, it becomes more difficult to\nreason about, harder to test, and harder to change without breaking one of its\nparts. It’s best to separate functionality so each function is responsible for\none task.\n\nThis issue also ties into the second problem: although `query` and `file_path`\nare configuration variables to our program, variables like `contents` are used\nto perform the program’s logic. The longer `main` becomes, the more variables\nwe’ll need to bring into scope; the more variables we have in scope, the harder\nit will be to keep track of the purpose of each. It’s best to group the\nconfiguration variables into one structure to make their purpose clear.\n\nThe third problem is that we’ve used `expect` to print an error message when\nreading the file fails, but the error message just prints `Should have been\nable to read the file`. Reading a file can fail in a number of ways: for\nexample, the file could be missing, or we might not have permission to open it.\nRight now, regardless of the situation, we’d print the same error message for\neverything, which wouldn’t give the user any information!\n\nFourth, we use `expect` repeatedly to handle different errors, and if the user\nruns our program without specifying enough arguments, they’ll get an `index out\nof bounds` error from Rust that doesn’t clearly explain the problem. It would\nbe best if all the error-handling code were in one place so future maintainers\nhad only one place to consult the code if the error-handling logic needed to\nchange. Having all the error-handling code in one place will also ensure that\nwe’re printing messages that will be meaningful to our end users.\n\nLet’s address these four problems by refactoring our project.\n\n### Separation of Concerns for Binary Projects\n\nThe organizational problem of allocating responsibility for multiple tasks to\nthe `main` function is common to many binary projects. As a result, the Rust\ncommunity has developed guidelines for splitting the separate concerns of a\nbinary program when `main` starts getting large. This process has the following\nsteps:\n\n* Split your program into a *main.rs* and a *lib.rs* and move your program’s\n  logic to *lib.rs*.\n* As long as your command line parsing logic is small, it can remain in\n  *main.rs*.\n* When the command line parsing logic starts getting complicated, extract it\n  from *main.rs* and move it to *lib.rs*.\n\nThe responsibilities that remain in the `main` function after this process\nshould be limited to the following:\n\n* Calling the command line parsing logic with the argument values\n* Setting up any other configuration\n* Calling a `run` function in *lib.rs*\n* Handling the error if `run` returns an error\n\nThis pattern is about separating concerns: *main.rs* handles running the\nprogram, and *lib.rs* handles all the logic of the task at hand. Because you\ncan’t test the `main` function directly, this structure lets you test all of\nyour program’s logic by moving it into functions in *lib.rs*. The code that\nremains in *main.rs* will be small enough to verify its correctness by reading\nit. Let’s rework our program by following this process.\n\n#### Extracting the Argument Parser\n\nWe’ll extract the functionality for parsing arguments into a function that\n`main` will call to prepare for moving the command line parsing logic to\n*src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new\nfunction `parse_config`, which we’ll define in *src/main.rs* for the moment.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-05/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-5: Extracting a `parse_config` function from\n`main`</span>\n\nWe’re still collecting the command line arguments into a vector, but instead of\nassigning the argument value at index 1 to the variable `query` and the\nargument value at index 2 to the variable `file_path` within the `main`\nfunction, we pass the whole vector to the `parse_config` function. The\n`parse_config` function then holds the logic that determines which argument\ngoes in which variable and passes the values back to `main`. We still create\nthe `query` and `file_path` variables in `main`, but `main` no longer has the\nresponsibility of determining how the command line arguments and variables\ncorrespond.\n\nThis rework may seem like overkill for our small program, but we’re refactoring\nin small, incremental steps. After making this change, run the program again to\nverify that the argument parsing still works. It’s good to check your progress\noften, to help identify the cause of problems when they occur.\n\n#### Grouping Configuration Values\n\nWe can take another small step to improve the `parse_config` function further.\nAt the moment, we’re returning a tuple, but then we immediately break that\ntuple into individual parts again. This is a sign that perhaps we don’t have\nthe right abstraction yet.\n\nAnother indicator that shows there’s room for improvement is the `config` part\nof `parse_config`, which implies that the two values we return are related and\nare both part of one configuration value. We’re not currently conveying this\nmeaning in the structure of the data other than by grouping the two values into\na tuple; we’ll instead put the two values into one struct and give each of the\nstruct fields a meaningful name. Doing so will make it easier for future\nmaintainers of this code to understand how the different values relate to each\nother and what their purpose is.\n\nListing 12-6 shows the improvements to the `parse_config` function.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic,noplayground\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-06/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-6: Refactoring `parse_config` to return an\ninstance of a `Config` struct</span>\n\nWe’ve added a struct named `Config` defined to have fields named `query` and\n`file_path`. The signature of `parse_config` now indicates that it returns a\n`Config` value. In the body of `parse_config`, where we used to return\nstring slices that reference `String` values in `args`, we now define `Config`\nto contain owned `String` values. The `args` variable in `main` is the owner of\nthe argument values and is only letting the `parse_config` function borrow\nthem, which means we’d violate Rust’s borrowing rules if `Config` tried to take\nownership of the values in `args`.\n\nThere are a number of ways we could manage the `String` data; the easiest,\nthough somewhat inefficient, route is to call the `clone` method on the values.\nThis will make a full copy of the data for the `Config` instance to own, which\ntakes more time and memory than storing a reference to the string data.\nHowever, cloning the data also makes our code very straightforward because we\ndon’t have to manage the lifetimes of the references; in this circumstance,\ngiving up a little performance to gain simplicity is a worthwhile trade-off.\n\n> ### The Trade-Offs of Using `clone`\n>\n> There’s a tendency among many Rustaceans to avoid using `clone` to fix\n> ownership problems because of its runtime cost. In\n> [Chapter 13][ch13]<!-- ignore -->, you’ll learn how to use more efficient\n> methods in this type of situation. But for now, it’s okay to copy a few\n> strings to continue making progress because you’ll make these copies only\n> once and your file path and query string are very small. It’s better to have\n> a working program that’s a bit inefficient than to try to hyperoptimize code\n> on your first pass. As you become more experienced with Rust, it’ll be\n> easier to start with the most efficient solution, but for now, it’s\n> perfectly acceptable to call `clone`.\n\nWe’ve updated `main` so it places the instance of `Config` returned by\n`parse_config` into a variable named `config`, and we updated the code that\npreviously used the separate `query` and `file_path` variables so it now uses\nthe fields on the `Config` struct instead.\n\nNow our code more clearly conveys that `query` and `file_path` are related and\nthat their purpose is to configure how the program will work. Any code that\nuses these values knows to find them in the `config` instance in the fields\nnamed for their purpose.\n\n#### Creating a Constructor for `Config`\n\nSo far, we’ve extracted the logic responsible for parsing the command line\narguments from `main` and placed it in the `parse_config` function. Doing so\nhelped us to see that the `query` and `file_path` values were related and that\nrelationship should be conveyed in our code. We then added a `Config` struct to\nname the related purpose of `query` and `file_path` and to be able to return the\nvalues’ names as struct field names from the `parse_config` function.\n\nSo now that the purpose of the `parse_config` function is to create a `Config`\ninstance, we can change `parse_config` from a plain function to a function\nnamed `new` that is associated with the `Config` struct. Making this change\nwill make the code more idiomatic. We can create instances of types in the\nstandard library, such as `String`, by calling `String::new`. Similarly, by\nchanging `parse_config` into a `new` function associated with `Config`, we’ll\nbe able to create instances of `Config` by calling `Config::new`. Listing 12-7\nshows the changes we need to make.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,should_panic,noplayground\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-07/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-7: Changing `parse_config` into\n`Config::new`</span>\n\nWe’ve updated `main` where we were calling `parse_config` to instead call\n`Config::new`. We’ve changed the name of `parse_config` to `new` and moved it\nwithin an `impl` block, which associates the `new` function with `Config`. Try\ncompiling this code again to make sure it works.\n\n### Fixing the Error Handling\n\nNow we’ll work on fixing our error handling. Recall that attempting to access\nthe values in the `args` vector at index 1 or index 2 will cause the program to\npanic if the vector contains fewer than three items. Try running the program\nwithout any arguments; it will look like this:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-07/output.txt}}\n```\n\nThe line `index out of bounds: the len is 1 but the index is 1` is an error\nmessage intended for programmers. It won’t help our end users understand what\nthey should do instead. Let’s fix that now.\n\n#### Improving the Error Message\n\nIn Listing 12-8, we add a check in the `new` function that will verify that the\nslice is long enough before accessing index 1 and 2. If the slice isn’t long\nenough, the program panics and displays a better error message.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-08/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-8: Adding a check for the number of\narguments</span>\n\nThis code is similar to [the `Guess::new` function we wrote in Listing\n9-13][ch9-custom-types]<!-- ignore -->, where we called `panic!` when the\n`value` argument was out of the range of valid values. Instead of checking for\na range of values here, we’re checking that the length of `args` is at least 3\nand the rest of the function can operate under the assumption that this\ncondition has been met. If `args` has fewer than three items, this condition\nwill be true, and we call the `panic!` macro to end the program immediately.\n\nWith these extra few lines of code in `new`, let’s run the program without any\narguments again to see what the error looks like now:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-08/output.txt}}\n```\n\nThis output is better: we now have a reasonable error message. However, we also\nhave extraneous information we don’t want to give to our users. Perhaps using\nthe technique we used in Listing 9-13 isn’t the best to use here: a call to\n`panic!` is more appropriate for a programming problem than a usage problem,\n[as discussed in Chapter 9][ch9-error-guidelines]<!-- ignore -->. Instead,\nwe’ll use the other technique you learned about in Chapter 9—[returning a\n`Result`][ch9-result]<!-- ignore --> that indicates either success or an error.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"returning-a-result-from-new-instead-of-calling-panic\"></a>\n\n#### Returning a `Result` Instead of Calling `panic!`\n\nWe can instead return a `Result` value that will contain a `Config` instance in\nthe successful case and will describe the problem in the error case. We’re also\ngoing to change the function name from `new` to `build` because many\nprogrammers expect `new` functions to never fail. When `Config::build` is\ncommunicating to `main`, we can use the `Result` type to signal there was a\nproblem. Then we can change `main` to convert an `Err` variant into a more\npractical error for our users without the surrounding text about `thread\n'main'` and `RUST_BACKTRACE` that a call to `panic!` causes.\n\nListing 12-9 shows the changes we need to make to the return value of the\nfunction we’re now calling `Config::build` and the body of the function needed\nto return a `Result`. Note that this won’t compile until we update `main` as\nwell, which we’ll do in the next listing.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-09/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-9: Returning a `Result` from\n`Config::build`</span>\n\nOur `build` function returns a `Result` with a `Config` instance in the success\ncase and a `&'static str` in the error case. Our error values will always be\nstring literals that have the `'static` lifetime.\n\nWe’ve made two changes in the body of the function: instead of calling `panic!`\nwhen the user doesn’t pass enough arguments, we now return an `Err` value, and\nwe’ve wrapped the `Config` return value in an `Ok`. These changes make the\nfunction conform to its new type signature.\n\nReturning an `Err` value from `Config::build` allows the `main` function to\nhandle the `Result` value returned from the `build` function and exit the\nprocess more cleanly in the error case.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"calling-confignew-and-handling-errors\"></a>\n\n#### Calling `Config::build` and Handling Errors\n\nTo handle the error case and print a user-friendly message, we need to update\n`main` to handle the `Result` being returned by `Config::build`, as shown in\nListing 12-10. We’ll also take the responsibility of exiting the command line\ntool with a nonzero error code away from `panic!` and instead implement it by\nhand. A nonzero exit status is a convention to signal to the process that\ncalled our program that the program exited with an error state.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-10/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-10: Exiting with an error code if building a\n`Config` fails</span>\n\nIn this listing, we’ve used a method we haven’t covered in detail yet:\n`unwrap_or_else`, which is defined on `Result<T, E>` by the standard library.\nUsing `unwrap_or_else` allows us to define some custom, non-`panic!` error\nhandling. If the `Result` is an `Ok` value, this method’s behavior is similar\nto `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value\nis an `Err` value, this method calls the code in the *closure*, which is an\nanonymous function we define and pass as an argument to `unwrap_or_else`. We’ll\ncover closures in more detail in [Chapter 13][ch13]<!-- ignore -->. For now,\nyou just need to know that `unwrap_or_else` will pass the inner value of the\n`Err`, which in this case is the static string `\"not enough arguments\"` that we\nadded in Listing 12-9, to our closure in the argument `err` that appears\nbetween the vertical pipes. The code in the closure can then use the `err`\nvalue when it runs.\n\nWe’ve added a new `use` line to bring `process` from the standard library into\nscope. The code in the closure that will be run in the error case is only two\nlines: we print the `err` value and then call `process::exit`. The\n`process::exit` function will stop the program immediately and return the\nnumber that was passed as the exit status code. This is similar to the\n`panic!`-based handling we used in Listing 12-8, but we no longer get all the\nextra output. Let’s try it:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-10/output.txt}}\n```\n\nGreat! This output is much friendlier for our users.\n\n### Extracting Logic from `main`\n\nNow that we’ve finished refactoring the configuration parsing, let’s turn to\nthe program’s logic. As we stated in [“Separation of Concerns for Binary\nProjects”](#separation-of-concerns-for-binary-projects)<!-- ignore -->, we’ll\nextract a function named `run` that will hold all the logic currently in the\n`main` function that isn’t involved with setting up configuration or handling\nerrors. When we’re done, `main` will be concise and easy to verify by\ninspection, and we’ll be able to write tests for all the other logic.\n\nListing 12-11 shows the extracted `run` function. For now, we’re just making\nthe small, incremental improvement of extracting the function. We’re still\ndefining the function in *src/main.rs*.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-11/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-11: Extracting a `run` function containing the\nrest of the program logic</span>\n\nThe `run` function now contains all the remaining logic from `main`, starting\nfrom reading the file. The `run` function takes the `Config` instance as an\nargument.\n\n#### Returning Errors from the `run` Function\n\nWith the remaining program logic separated into the `run` function, we can\nimprove the error handling, as we did with `Config::build` in Listing 12-9.\nInstead of allowing the program to panic by calling `expect`, the `run`\nfunction will return a `Result<T, E>` when something goes wrong. This will let\nus further consolidate the logic around handling errors into `main` in a\nuser-friendly way. Listing 12-12 shows the changes we need to make to the\nsignature and body of `run`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-12/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-12: Changing the `run` function to return\n`Result`</span>\n\nWe’ve made three significant changes here. First, we changed the return type of\nthe `run` function to `Result<(), Box<dyn Error>>`. This function previously\nreturned the unit type, `()`, and we keep that as the value returned in the\n`Ok` case.\n\nFor the error type, we used the *trait object* `Box<dyn Error>` (and we’ve\nbrought `std::error::Error` into scope with a `use` statement at the top).\nWe’ll cover trait objects in [Chapter 17][ch17]<!-- ignore -->. For now, just\nknow that `Box<dyn Error>` means the function will return a type that\nimplements the `Error` trait, but we don’t have to specify what particular type\nthe return value will be. This gives us flexibility to return error values that\nmay be of different types in different error cases. The `dyn` keyword is short\nfor “dynamic.”\n\nSecond, we’ve removed the call to `expect` in favor of the `?` operator, as we\ntalked about in [Chapter 9][ch9-question-mark]<!-- ignore -->. Rather than\n`panic!` on an error, `?` will return the error value from the current function\nfor the caller to handle.\n\nThird, the `run` function now returns an `Ok` value in the success case.\nWe’ve declared the `run` function’s success type as `()` in the signature,\nwhich means we need to wrap the unit type value in the `Ok` value. This\n`Ok(())` syntax might look a bit strange at first, but using `()` like this is\nthe idiomatic way to indicate that we’re calling `run` for its side effects\nonly; it doesn’t return a value we need.\n\nWhen you run this code, it will compile but will display a warning:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-12/output.txt}}\n```\n\nRust tells us that our code ignored the `Result` value and the `Result` value\nmight indicate that an error occurred. But we’re not checking to see whether or\nnot there was an error, and the compiler reminds us that we probably meant to\nhave some error-handling code here! Let’s rectify that problem now.\n\n#### Handling Errors Returned from `run` in `main`\n\nWe’ll check for errors and handle them using a technique similar to one we used\nwith `Config::build` in Listing 12-10, but with a slight difference:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-01-handling-errors-in-main/src/main.rs:here}}\n```\n\nWe use `if let` rather than `unwrap_or_else` to check whether `run` returns an\n`Err` value and call `process::exit(1)` if it does. The `run` function doesn’t\nreturn a value that we want to `unwrap` in the same way that `Config::build`\nreturns the `Config` instance. Because `run` returns `()` in the success case,\nwe only care about detecting an error, so we don’t need `unwrap_or_else` to\nreturn the unwrapped value, which would only be `()`.\n\nThe bodies of the `if let` and the `unwrap_or_else` functions are the same in\nboth cases: we print the error and exit.\n\n### Splitting Code into a Library Crate\n\nOur `minigrep` project is looking good so far! Now we’ll split the\n*src/main.rs* file and put some code into the *src/lib.rs* file. That way we\ncan test the code and have a *src/main.rs* file with fewer responsibilities.\n\nLet’s move all the code that isn’t the `main` function from *src/main.rs* to\n*src/lib.rs*:\n\n* The `run` function definition\n* The relevant `use` statements\n* The definition of `Config`\n* The `Config::build` function definition\n\nThe contents of *src/lib.rs* should have the signatures shown in Listing 12-13\n(we’ve omitted the bodies of the functions for brevity). Note that this won’t\ncompile until we modify *src/main.rs* in Listing 12-14.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-13/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-13: Moving `Config` and `run` into\n*src/lib.rs*</span>\n\nWe’ve made liberal use of the `pub` keyword: on `Config`, on its fields and its\n`build` method, and on the `run` function. We now have a library crate that has\na public API we can test!\n\nNow we need to bring the code we moved to *src/lib.rs* into the scope of the\nbinary crate in *src/main.rs*, as shown in Listing 12-14.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-14/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-14: Using the `minigrep` library crate in\n*src/main.rs*</span>\n\nWe add a `use minigrep::Config` line to bring the `Config` type from the\nlibrary crate into the binary crate’s scope, and we prefix the `run` function\nwith our crate name. Now all the functionality should be connected and should\nwork. Run the program with `cargo run` and make sure everything works\ncorrectly.\n\nWhew! That was a lot of work, but we’ve set ourselves up for success in the\nfuture. Now it’s much easier to handle errors, and we’ve made the code more\nmodular. Almost all of our work will be done in *src/lib.rs* from here on out.\n\nLet’s take advantage of this newfound modularity by doing something that would\nhave been difficult with the old code but is easy with the new code: we’ll\nwrite some tests!\n\n[ch13]: ch13-00-functional-features.html\n[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation\n[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling\n[ch9-result]: ch09-02-recoverable-errors-with-result.html\n[ch17]: ch17-00-oop.html\n[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n",
          "document_id": 58
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "How do I produce code using Test Driven Development?",
              "id": 2197,
              "answers": [
                {
                  "answer_id": 2202,
                  "document_id": 59,
                  "question_id": 2197,
                  "text": "1. Write a test that fails and run it to make sure it fails for the reason you\n   expect.\n2. Write or modify just enough code to make the new test pass.\n3. Refactor the code you just added or changed and make sure the tests\n   continue to pass.\n4. Repeat from step 1!",
                  "answer_start": 551,
                  "answer_end": 818,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are the benefits of TDD?",
              "id": 2198,
              "answers": [
                {
                  "answer_id": 2203,
                  "document_id": 59,
                  "question_id": 2198,
                  "text": "Writing the test before you write the code that makes the test pass\nhelps to maintain high test coverage throughout the process.",
                  "answer_start": 905,
                  "answer_end": 1033,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "From what should I start in Test Driven Development?",
              "id": 2199,
              "answers": [
                {
                  "answer_id": 2204,
                  "document_id": 59,
                  "question_id": 2199,
                  "text": "Write a test that fails and run it to make sure it fails for the reason you\n   expect.",
                  "answer_start": 554,
                  "answer_end": 640,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Developing the Library’s Functionality with Test-Driven Development\n\nNow that we’ve extracted the logic into *src/lib.rs* and left the argument\ncollecting and error handling in *src/main.rs*, it’s much easier to write tests\nfor the core functionality of our code. We can call functions directly with\nvarious arguments and check return values without having to call our binary\nfrom the command line.\n\nIn this section, we’ll add the searching logic to the `minigrep` program\nusing the test-driven development (TDD) process with the following steps:\n\n1. Write a test that fails and run it to make sure it fails for the reason you\n   expect.\n2. Write or modify just enough code to make the new test pass.\n3. Refactor the code you just added or changed and make sure the tests\n   continue to pass.\n4. Repeat from step 1!\n\nThough it’s just one of many ways to write software, TDD can help drive code\ndesign. Writing the test before you write the code that makes the test pass\nhelps to maintain high test coverage throughout the process.\n\nWe’ll test drive the implementation of the functionality that will actually do\nthe searching for the query string in the file contents and produce a list of\nlines that match the query. We’ll add this functionality in a function called\n`search`.\n\n### Writing a Failing Test\n\nBecause we don’t need them anymore, let’s remove the `println!` statements from\n*src/lib.rs* and *src/main.rs* that we used to check the program’s behavior.\nThen, in *src/lib.rs*, add a `tests` module with a test function, as we did in\n[Chapter 11][ch11-anatomy]<!-- ignore -->. The test function specifies the\nbehavior we want the `search` function to have: it will take a query and the\ntext to search, and it will return only the lines from the text that contain\nthe query. Listing 12-15 shows this test, which won’t compile yet.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-15: Creating a failing test for the `search`\nfunction we wish we had</span>\n\nThis test searches for the string `\"duct\"`. The text we’re searching is three\nlines, only one of which contains `\"duct\"` (Note that the backslash after the\nopening double quote tells Rust not to put a newline character at the beginning\nof the contents of this string literal). We assert that the value returned from\nthe `search` function contains only the line we expect.\n\nWe aren’t yet able to run this test and watch it fail because the test doesn’t\neven compile: the `search` function doesn’t exist yet! In accordance with TDD\nprinciples, we’ll add just enough code to get the test to compile and run by\nadding a definition of the `search` function that always returns an empty\nvector, as shown in Listing 12-16. Then the test should compile and fail\nbecause an empty vector doesn’t match a vector containing the line `\"safe,\nfast, productive.\"`\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-16: Defining just enough of the `search`\nfunction so our test will compile</span>\n\nNotice that we need to define an explicit lifetime `'a` in the signature of\n`search` and use that lifetime with the `contents` argument and the return\nvalue. Recall in [Chapter 10][ch10-lifetimes]<!-- ignore --> that the lifetime\nparameters specify which argument lifetime is connected to the lifetime of the\nreturn value. In this case, we indicate that the returned vector should contain\nstring slices that reference slices of the argument `contents` (rather than the\nargument `query`).\n\nIn other words, we tell Rust that the data returned by the `search` function\nwill live as long as the data passed into the `search` function in the\n`contents` argument. This is important! The data referenced *by* a slice needs\nto be valid for the reference to be valid; if the compiler assumes we’re making\nstring slices of `query` rather than `contents`, it will do its safety checking\nincorrectly.\n\nIf we forget the lifetime annotations and try to compile this function, we’ll\nget this error:\n\n```console\n{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}\n```\n\nRust can’t possibly know which of the two arguments we need, so we need to tell\nit explicitly. Because `contents` is the argument that contains all of our text\nand we want to return the parts of that text that match, we know `contents` is\nthe argument that should be connected to the return value using the lifetime\nsyntax.\n\nOther programming languages don’t require you to connect arguments to return\nvalues in the signature, but this practice will get easier over time. You might\nwant to compare this example with the [“Validating References with\nLifetimes”][validating-references-with-lifetimes]<!-- ignore --> section in\nChapter 10.\n\nNow let’s run the test:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-16/output.txt}}\n```\n\nGreat, the test fails, exactly as we expected. Let’s get the test to pass!\n\n### Writing Code to Pass the Test\n\nCurrently, our test is failing because we always return an empty vector. To fix\nthat and implement `search`, our program needs to follow these steps:\n\n* Iterate through each line of the contents.\n* Check whether the line contains our query string.\n* If it does, add it to the list of values we’re returning.\n* If it doesn’t, do nothing.\n* Return the list of results that match.\n\nLet’s work through each step, starting with iterating through lines.\n\n#### Iterating Through Lines with the `lines` Method\n\nRust has a helpful method to handle line-by-line iteration of strings,\nconveniently named `lines`, that works as shown in Listing 12-17. Note this\nwon’t compile yet.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-17: Iterating through each line in `contents`\n</span>\n\nThe `lines` method returns an iterator. We’ll talk about iterators in depth in\n[Chapter 13][ch13-iterators]<!-- ignore -->, but recall that you saw this way\nof using an iterator in [Listing 3-5][ch3-iter]<!-- ignore -->, where we used a\n`for` loop with an iterator to run some code on each item in a collection.\n\n#### Searching Each Line for the Query\n\nNext, we’ll check whether the current line contains our query string.\nFortunately, strings have a helpful method named `contains` that does this for\nus! Add a call to the `contains` method in the `search` function, as shown in\nListing 12-18. Note this still won’t compile yet.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-18: Adding functionality to see whether the\nline contains the string in `query`</span>\n\nAt the moment, we’re building up functionality. To get it to compile, we need\nto return a value from the body as we indicated we would in the function\nsignature.\n\n#### Storing Matching Lines\n\nTo finish this function, we need a way to store the matching lines that we want\nto return. For that, we can make a mutable vector before the `for` loop and\ncall the `push` method to store a `line` in the vector. After the `for` loop,\nwe return the vector, as shown in Listing 12-19.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-19: Storing the lines that match so we can\nreturn them</span>\n\nNow the `search` function should return only the lines that contain `query`,\nand our test should pass. Let’s run the test:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}\n```\n\nOur test passed, so we know it works!\n\nAt this point, we could consider opportunities for refactoring the\nimplementation of the search function while keeping the tests passing to\nmaintain the same functionality. The code in the search function isn’t too bad,\nbut it doesn’t take advantage of some useful features of iterators. We’ll\nreturn to this example in [Chapter 13][ch13-iterators]<!-- ignore -->, where\nwe’ll explore iterators in detail, and look at how to improve it.\n\n#### Using the `search` Function in the `run` Function\n\nNow that the `search` function is working and tested, we need to call `search`\nfrom our `run` function. We need to pass the `config.query` value and the\n`contents` that `run` reads from the file to the `search` function. Then `run`\nwill print each line returned from `search`:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}\n```\n\nWe’re still using a `for` loop to return each line from `search` and print it.\n\nNow the entire program should work! Let’s try it out, first with a word that\nshould return exactly one line from the Emily Dickinson poem, “frog”:\n\n```console\n{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}\n```\n\nCool! Now let’s try a word that will match multiple lines, like “body”:\n\n```console\n{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}\n```\n\nAnd finally, let’s make sure that we don’t get any lines when we search for a\nword that isn’t anywhere in the poem, such as “monomorphization”:\n\n```console\n{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}\n```\n\nExcellent! We’ve built our own mini version of a classic tool and learned a lot\nabout how to structure applications. We’ve also learned a bit about file input\nand output, lifetimes, testing, and command line parsing.\n\nTo round out this project, we’ll briefly demonstrate how to work with\nenvironment variables and how to print to standard error, both of which are\nuseful when you’re writing command line programs.\n\n[validating-references-with-lifetimes]:\nch10-03-lifetime-syntax.html#validating-references-with-lifetimes\n[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function\n[ch10-lifetimes]: ch10-03-lifetime-syntax.html\n[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for\n[ch13-iterators]: ch13-02-iterators.html\n",
          "document_id": 59
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "How can I avoid passing the same command line argument in each running of the program?",
              "id": 2200,
              "answers": [
                {
                  "answer_id": 2205,
                  "document_id": 60,
                  "question_id": 2200,
                  "text": "Environment Variables",
                  "answer_start": 16,
                  "answer_end": 37,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Does 'to_lowercase' work on every letter from Unicode ?",
              "id": 2201,
              "answers": [
                {
                  "answer_id": 2206,
                  "document_id": 60,
                  "question_id": 2201,
                  "text": "`to_lowercase` will handle basic Unicode",
                  "answer_start": 3331,
                  "answer_end": 3371,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to set up an environment variable?",
              "id": 2202,
              "answers": [
                {
                  "answer_id": 2207,
                  "document_id": 60,
                  "question_id": 2202,
                  "text": "`env::var` function and pass it the name of the `IGNORE_CASE` environment\nvariable.",
                  "answer_start": 6253,
                  "answer_end": 6336,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the return value of env::val?",
              "id": 2203,
              "answers": [
                {
                  "answer_id": 2208,
                  "document_id": 60,
                  "question_id": 2203,
                  "text": "returns a `Result` that will be the\nsuccessful `Ok` variant that contains the value of the environment variable if\nthe environment variable is set to any value. It will return the `Err` variant\nif the environment variable is not set.",
                  "answer_start": 6361,
                  "answer_end": 6594,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to delete a environment variable?",
              "id": 2204,
              "answers": [
                {
                  "answer_id": 2209,
                  "document_id": 60,
                  "question_id": 2204,
                  "text": "```console\nPS> Remove-Item Env:IGNORE_CASE\n```",
                  "answer_start": 8081,
                  "answer_end": 8127,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to set up a environment variable in Powershell?",
              "id": 2205,
              "answers": [
                {
                  "answer_id": 2210,
                  "document_id": 60,
                  "question_id": 2205,
                  "text": "```console\nPS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt\n```",
                  "answer_start": 7890,
                  "answer_end": 7953,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Working with Environment Variables\n\nWe’ll improve `minigrep` by adding an extra feature: an option for\ncase-insensitive searching that the user can turn on via an environment\nvariable. We could make this feature a command line option and require that\nusers enter it each time they want it to apply, but by instead making it an\nenvironment variable, we allow our users to set the environment variable once\nand have all their searches be case insensitive in that terminal session.\n\n### Writing a Failing Test for the Case-Insensitive `search` Function\n\nWe first add a new `search_case_insensitive` function that will be called when\nthe environment variable has a value. We’ll continue to follow the TDD process,\nso the first step is again to write a failing test. We’ll add a new test for\nthe new `search_case_insensitive` function and rename our old test from\n`one_result` to `case_sensitive` to clarify the differences between the two\ntests, as shown in Listing 12-20.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-20/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-20: Adding a new failing test for the\ncase-insensitive function we’re about to add</span>\n\nNote that we’ve edited the old test’s `contents` too. We’ve added a new line\nwith the text `\"Duct tape.\"` using a capital D that shouldn’t match the query\n`\"duct\"` when we’re searching in a case-sensitive manner. Changing the old test\nin this way helps ensure that we don’t accidentally break the case-sensitive\nsearch functionality that we’ve already implemented. This test should pass now\nand should continue to pass as we work on the case-insensitive search.\n\nThe new test for the case-*insensitive* search uses `\"rUsT\"` as its query. In\nthe `search_case_insensitive` function we’re about to add, the query `\"rUsT\"`\nshould match the line containing `\"Rust:\"` with a capital R and match the line\n`\"Trust me.\"` even though both have different casing from the query. This is\nour failing test, and it will fail to compile because we haven’t yet defined\nthe `search_case_insensitive` function. Feel free to add a skeleton\nimplementation that always returns an empty vector, similar to the way we did\nfor the `search` function in Listing 12-16 to see the test compile and fail.\n\n### Implementing the `search_case_insensitive` Function\n\nThe `search_case_insensitive` function, shown in Listing 12-21, will be almost\nthe same as the `search` function. The only difference is that we’ll lowercase\nthe `query` and each `line` so whatever the case of the input arguments,\nthey’ll be the same case when we check whether the line contains the query.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-21/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-21: Defining the `search_case_insensitive`\nfunction to lowercase the query and the line before comparing them</span>\n\nFirst, we lowercase the `query` string and store it in a shadowed variable with\nthe same name. Calling `to_lowercase` on the query is necessary so no\nmatter whether the user’s query is `\"rust\"`, `\"RUST\"`, `\"Rust\"`, or `\"rUsT\"`,\nwe’ll treat the query as if it were `\"rust\"` and be insensitive to the case.\nWhile `to_lowercase` will handle basic Unicode, it won’t be 100% accurate. If\nwe were writing a real application, we’d want to do a bit more work here, but\nthis section is about environment variables, not Unicode, so we’ll leave it at\nthat here.\n\nNote that `query` is now a `String` rather than a string slice, because calling\n`to_lowercase` creates new data rather than referencing existing data. Say the\nquery is `\"rUsT\"`, as an example: that string slice doesn’t contain a lowercase\n`u` or `t` for us to use, so we have to allocate a new `String` containing\n`\"rust\"`. When we pass `query` as an argument to the `contains` method now, we\nneed to add an ampersand because the signature of `contains` is defined to take\na string slice.\n\nNext, we add a call to `to_lowercase` on each `line` to lowercase all\ncharacters. Now that we’ve converted `line` and `query` to lowercase, we’ll\nfind matches no matter what the case of the query is.\n\nLet’s see if this implementation passes the tests:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-21/output.txt}}\n```\n\nGreat! They passed. Now, let’s call the new `search_case_insensitive` function\nfrom the `run` function. First, we’ll add a configuration option to the\n`Config` struct to switch between case-sensitive and case-insensitive search.\nAdding this field will cause compiler errors because we aren’t initializing\nthis field anywhere yet:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:here}}\n```\n\nWe added the `ignore_case` field that holds a Boolean. Next, we need the `run`\nfunction to check the `ignore_case` field’s value and use that to decide\nwhether to call the `search` function or the `search_case_insensitive`\nfunction, as shown in Listing 12-22. This still won’t compile yet.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:there}}\n```\n\n<span class=\"caption\">Listing 12-22: Calling either `search` or\n`search_case_insensitive` based on the value in `config.ignore_case`</span>\n\nFinally, we need to check for the environment variable. The functions for\nworking with environment variables are in the `env` module in the standard\nlibrary, so we bring that module into scope at the top of *src/lib.rs*. Then\nwe’ll use the `var` function from the `env` module to check to see if any value\nhas been set for an environment variable named `IGNORE_CASE`, as shown in\nListing 12-23.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-23/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-23: Checking for any value in an environment\nvariable named `IGNORE_CASE`</span>\n\nHere, we create a new variable `ignore_case`. To set its value, we call the\n`env::var` function and pass it the name of the `IGNORE_CASE` environment\nvariable. The `env::var` function returns a `Result` that will be the\nsuccessful `Ok` variant that contains the value of the environment variable if\nthe environment variable is set to any value. It will return the `Err` variant\nif the environment variable is not set.\n\nWe’re using the `is_ok` method on the `Result` to check whether the environment\nvariable is set, which means the program should do a case-insensitive search.\nIf the `IGNORE_CASE` environment variable isn’t set to anything, `is_ok` will\nreturn false and the program will perform a case-sensitive search. We don’t\ncare about the *value* of the environment variable, just whether it’s set or\nunset, so we’re checking `is_ok` rather than using `unwrap`, `expect`, or any\nof the other methods we’ve seen on `Result`.\n\nWe pass the value in the `ignore_case` variable to the `Config` instance so the\n`run` function can read that value and decide whether to call\n`search_case_insensitive` or `search`, as we implemented in Listing 12-22.\n\nLet’s give it a try! First, we’ll run our program without the environment\nvariable set and with the query `to`, which should match any line that contains\nthe word “to” in all lowercase:\n\n```console\n{{#include ../listings/ch12-an-io-project/listing-12-23/output.txt}}\n```\n\nLooks like that still works! Now, let’s run the program with `IGNORE_CASE`\nset to `1` but with the same query `to`.\n\n```console\n$ IGNORE_CASE=1 cargo run -- to poem.txt\n```\n\nIf you’re using PowerShell, you will need to set the environment variable and\nrun the program as separate commands:\n\n```console\nPS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt\n```\n\nThis will make `IGNORE_CASE` persist for the remainder of your shell\nsession. It can be unset with the `Remove-Item` cmdlet:\n\n```console\nPS> Remove-Item Env:IGNORE_CASE\n```\n\nWe should get lines that contain “to” that might have uppercase letters:\n\n<!-- manual-regeneration\ncd listings/ch12-an-io-project/listing-12-23\nIGNORE_CASE=1 cargo run -- to poem.txt\ncan't extract because of the environment variable\n-->\n\n```console\nAre you nobody, too?\nHow dreary to be somebody!\nTo tell your name the livelong day\nTo an admiring bog!\n```\n\nExcellent, we also got lines containing “To”! Our `minigrep` program can now do\ncase-insensitive searching controlled by an environment variable. Now you know\nhow to manage options set using either command line arguments or environment\nvariables.\n\nSome programs allow arguments *and* environment variables for the same\nconfiguration. In those cases, the programs decide that one or the other takes\nprecedence. For another exercise on your own, try controlling case sensitivity\nthrough either a command line argument or an environment variable. Decide\nwhether the command line argument or the environment variable should take\nprecedence if the program is run with one set to case sensitive and one set to\nignore case.\n\nThe `std::env` module contains many more useful features for dealing with\nenvironment variables: check out its documentation to see what is available.\n",
          "document_id": 60
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What is stdout used for?",
              "id": 2129,
              "answers": [
                {
                  "answer_id": 2134,
                  "document_id": 61,
                  "question_id": 2129,
                  "text": "for general information",
                  "answer_start": 242,
                  "answer_end": 265,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is stderr used for?",
              "id": 2130,
              "answers": [
                {
                  "answer_id": 2135,
                  "document_id": 61,
                  "question_id": 2130,
                  "text": "for\nerror messages",
                  "answer_start": 298,
                  "answer_end": 316,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is 'println!' able to print error message?",
              "id": 2131,
              "answers": [
                {
                  "answer_id": 2136,
                  "document_id": 61,
                  "question_id": 2131,
                  "text": "`println!` macro is only capable of printing to standard output",
                  "answer_start": 465,
                  "answer_end": 528,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to redirect output stream to file?",
              "id": 2132,
              "answers": [
                {
                  "answer_id": 2137,
                  "document_id": 61,
                  "question_id": 2132,
                  "text": "with `>` and the file path",
                  "answer_start": 1405,
                  "answer_end": 1431,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the usage of 'eprintln!'?",
              "id": 2133,
              "answers": [
                {
                  "answer_id": 2138,
                  "document_id": 61,
                  "question_id": 2133,
                  "text": " to print errors",
                  "answer_start": 2548,
                  "answer_end": 2564,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which macro enables us to add message to error stream?",
              "id": 2134,
              "answers": [
                {
                  "answer_id": 2139,
                  "document_id": 61,
                  "question_id": 2134,
                  "text": "`eprintln!`",
                  "answer_start": 2572,
                  "answer_end": 2583,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Writing Error Messages to Standard Error Instead of Standard Output\n\nAt the moment, we’re writing all of our output to the terminal using the\n`println!` macro. In most terminals, there are two kinds of output: *standard\noutput* (`stdout`) for general information and *standard error* (`stderr`) for\nerror messages. This distinction enables users to choose to direct the\nsuccessful output of a program to a file but still print error messages to the\nscreen.\n\nThe `println!` macro is only capable of printing to standard output, so we\nhave to use something else to print to standard error.\n\n### Checking Where Errors Are Written\n\nFirst, let’s observe how the content printed by `minigrep` is currently being\nwritten to standard output, including any error messages we want to write to\nstandard error instead. We’ll do that by redirecting the standard output stream\nto a file while intentionally causing an error. We won’t redirect the standard\nerror stream, so any content sent to standard error will continue to display on\nthe screen.\n\nCommand line programs are expected to send error messages to the standard error\nstream so we can still see error messages on the screen even if we redirect the\nstandard output stream to a file. Our program is not currently well-behaved:\nwe’re about to see that it saves the error message output to a file instead!\n\nTo demonstrate this behavior, we’ll run the program with `>` and the file path,\n*output.txt*, that we want to redirect the standard output stream to. We won’t\npass any arguments, which should cause an error:\n\n```console\n$ cargo run > output.txt\n```\n\nThe `>` syntax tells the shell to write the contents of standard output to\n*output.txt* instead of the screen. We didn’t see the error message we were\nexpecting printed to the screen, so that means it must have ended up in the\nfile. This is what *output.txt* contains:\n\n```text\nProblem parsing arguments: not enough arguments\n```\n\nYup, our error message is being printed to standard output. It’s much more\nuseful for error messages like this to be printed to standard error so only\ndata from a successful run ends up in the file. We’ll change that.\n\n### Printing Errors to Standard Error\n\nWe’ll use the code in Listing 12-24 to change how error messages are printed.\nBecause of the refactoring we did earlier in this chapter, all the code that\nprints error messages is in one function, `main`. The standard library provides\nthe `eprintln!` macro that prints to the standard error stream, so let’s change\nthe two places we were calling `println!` to print errors to use `eprintln!`\ninstead.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-24/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 12-24: Writing error messages to standard error\ninstead of standard output using `eprintln!`</span>\n\nLet’s now run the program again in the same way, without any arguments and\nredirecting standard output with `>`:\n\n```console\n$ cargo run > output.txt\nProblem parsing arguments: not enough arguments\n```\n\nNow we see the error onscreen and *output.txt* contains nothing, which is the\nbehavior we expect of command line programs.\n\nLet’s run the program again with arguments that don’t cause an error but still\nredirect standard output to a file, like so:\n\n```console\n$ cargo run -- to poem.txt > output.txt\n```\n\nWe won’t see any output to the terminal, and *output.txt* will contain our\nresults:\n\n<span class=\"filename\">Filename: output.txt</span>\n\n```text\nAre you nobody, too?\nHow dreary to be somebody!\n```\n\nThis demonstrates that we’re now using standard output for successful output\nand standard error for error output as appropriate.\n\n## Summary\n\nThis chapter recapped some of the major concepts you’ve learned so far and\ncovered how to perform common I/O operations in Rust. By using command line\narguments, files, environment variables, and the `eprintln!` macro for printing\nerrors, you’re now prepared to write command line applications. Combined with\nthe concepts in previous chapters, your code will be well organized, store data\neffectively in the appropriate data structures, handle errors nicely, and be\nwell tested.\n\nNext, we’ll explore some Rust features that were influenced by functional\nlanguages: closures and iterators.\n",
          "document_id": 61
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What is a closure?",
              "id": 2135,
              "answers": [
                {
                  "answer_id": 2140,
                  "document_id": 62,
                  "question_id": 2135,
                  "text": "a function-like construct you can store in a variable",
                  "answer_start": 663,
                  "answer_end": 716,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is an iterator?",
              "id": 2136,
              "answers": [
                {
                  "answer_id": 2141,
                  "document_id": 62,
                  "question_id": 2136,
                  "text": "a way of processing a series of elements",
                  "answer_start": 732,
                  "answer_end": 772,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which functional language features are used in Rust?",
              "id": 2137,
              "answers": [
                {
                  "answer_id": 2142,
                  "document_id": 62,
                  "question_id": 2137,
                  "text": "Iterators and Closures",
                  "answer_start": 32,
                  "answer_end": 54,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are the characteristics of functional programming?",
              "id": 2138,
              "answers": [
                {
                  "answer_id": 2143,
                  "document_id": 62,
                  "question_id": 2138,
                  "text": "includes using functions as values by\npassing them in arguments, returning them from other functions, assigning them\nto variables for later execution, and so forth.",
                  "answer_start": 236,
                  "answer_end": 400,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "# Functional Language Features: Iterators and Closures\n\nRust’s design has taken inspiration from many existing languages and\ntechniques, and one significant influence is *functional programming*.\nProgramming in a functional style often includes using functions as values by\npassing them in arguments, returning them from other functions, assigning them\nto variables for later execution, and so forth.\n\nIn this chapter, we won’t debate the issue of what functional programming is or\nisn’t but will instead discuss some features of Rust that are similar to\nfeatures in many languages often referred to as functional.\n\nMore specifically, we’ll cover:\n\n* *Closures*, a function-like construct you can store in a variable\n* *Iterators*, a way of processing a series of elements\n* How to use closures and iterators to improve the I/O project in Chapter 12\n* The performance of closures and iterators (Spoiler alert: they’re faster than\n  you might think!)\n\nWe’ve already covered some other Rust features, such as pattern matching and\nenums, that are also influenced by the functional style. Because mastering\nclosures and iterators is an important part of writing idiomatic, fast Rust\ncode, we’ll devote this entire chapter to them.\n",
          "document_id": 62
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "Where does 'FnMut' apply?",
              "id": 2217,
              "answers": [
                {
                  "answer_id": 2222,
                  "document_id": 63,
                  "question_id": 2217,
                  "text": "`FnMut` applies to closures that don’t move captured values out of their\n   body, but that might mutate the captured values. These closures can be\n   called more than once.",
                  "answer_start": 14690,
                  "answer_end": 14862,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are closures?",
              "id": 2206,
              "answers": [
                {
                  "answer_id": 2211,
                  "document_id": 63,
                  "question_id": 2206,
                  "text": "anonymous functions you can save in a variable or pass as\narguments to other functions",
                  "answer_start": 219,
                  "answer_end": 305,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to use closures?",
              "id": 2207,
              "answers": [
                {
                  "answer_id": 2212,
                  "document_id": 63,
                  "question_id": 2207,
                  "text": "You can create the closure in one place and then\ncall the closure elsewhere to evaluate it in a different context.",
                  "answer_start": 307,
                  "answer_end": 421,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the difference between functions and closures?",
              "id": 2208,
              "answers": [
                {
                  "answer_id": 2213,
                  "document_id": 63,
                  "question_id": 2208,
                  "text": "Unlike\nfunctions, closures can capture values from the scope in which they’re defined.",
                  "answer_start": 422,
                  "answer_end": 508,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Give me a scenario where can I use closure?",
              "id": 2209,
              "answers": [
                {
                  "answer_id": 2214,
                  "document_id": 63,
                  "question_id": 2209,
                  "text": "Every so\noften, our t-shirt company gives away an exclusive, limited-edition shirt to\nsomeone on our mailing list as a promotion. People on the mailing list can\noptionally add their favorite color to their profile. If the person chosen for\na free shirt has their favorite color set, they get that color shirt. If the\nperson hasn’t specified a favorite color, they get whatever color the company\ncurrently has the most of.",
                  "answer_start": 1002,
                  "answer_end": 1423,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Do I have to annotate type of parameters in closures?",
              "id": 2210,
              "answers": [
                {
                  "answer_id": 2215,
                  "document_id": 63,
                  "question_id": 2210,
                  "text": "Closures don’t\nusually require you to annotate the types of the parameters or the return value\nlike `fn` functions do.",
                  "answer_start": 4499,
                  "answer_end": 4617,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Are closures used in exposed interface?",
              "id": 2211,
              "answers": [
                {
                  "answer_id": 2216,
                  "document_id": 63,
                  "question_id": 2211,
                  "text": "Closures, on the other hand, aren’t used\nin an exposed interface",
                  "answer_start": 4868,
                  "answer_end": 4932,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the difference between functions and closures syntax?",
              "id": 2212,
              "answers": [
                {
                  "answer_id": 2217,
                  "document_id": 63,
                  "question_id": 2212,
                  "text": "fn  add_one_v1   (x: u32) -> u32 { x + 1 }\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;",
                  "answer_start": 6522,
                  "answer_end": 6696,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can closures capture values?",
              "id": 2213,
              "answers": [
                {
                  "answer_id": 2218,
                  "document_id": 63,
                  "question_id": 2213,
                  "text": "in three ways, which\ndirectly map to the three ways a function can take a parameter: borrowing\nimmutably, borrowing mutably, and taking ownership.",
                  "answer_start": 8838,
                  "answer_end": 8984,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can closure definition be binded with a variable?",
              "id": 2214,
              "answers": [
                {
                  "answer_id": 2219,
                  "document_id": 63,
                  "question_id": 2214,
                  "text": "This example also illustrates that a variable can bind to a closure definition",
                  "answer_start": 9531,
                  "answer_end": 9609,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is closure allowed to do?",
              "id": 2215,
              "answers": [
                {
                  "answer_id": 2220,
                  "document_id": 63,
                  "question_id": 2215,
                  "text": " move a captured value out of the closure, mutate the\ncaptured value, neither move nor mutate the value, or capture nothing from the\nenvironment to begin with.",
                  "answer_start": 13861,
                  "answer_end": 14020,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is 'FnOnce'?",
              "id": 2216,
              "answers": [
                {
                  "answer_id": 2221,
                  "document_id": 63,
                  "question_id": 2216,
                  "text": " `FnOnce` applies to closures that can be called once. All closures implement\n   at least this trait, because all closures can be called. A closure that\n   moves captured values out of its body will only implement `FnOnce` and none\n   of the other `Fn` traits, because it can only be called once",
                  "answer_start": 14390,
                  "answer_end": 14685,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "To which closures does 'Fn' apply?",
              "id": 2218,
              "answers": [
                {
                  "answer_id": 2223,
                  "document_id": 63,
                  "question_id": 2218,
                  "text": " `Fn` applies to closures that don’t move captured values out of their body\n   and that don’t mutate captured values, as well as closures that capture\n   nothing from their environment.",
                  "answer_start": 14865,
                  "answer_end": 15050,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which traits can functions implement?",
              "id": 2219,
              "answers": [
                {
                  "answer_id": 2224,
                  "document_id": 63,
                  "question_id": 2219,
                  "text": "Functions can implement all three of the `Fn` traits too.",
                  "answer_start": 16603,
                  "answer_end": 16660,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "<!-- Old heading. Do not remove or links may break. -->\n<a id=\"closures-anonymous-functions-that-can-capture-their-environment\"></a>\n\n## Closures: Anonymous Functions that Capture Their Environment\n\nRust’s closures are anonymous functions you can save in a variable or pass as\narguments to other functions. You can create the closure in one place and then\ncall the closure elsewhere to evaluate it in a different context. Unlike\nfunctions, closures can capture values from the scope in which they’re defined.\nWe’ll demonstrate how these closure features allow for code reuse and behavior\ncustomization.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"creating-an-abstraction-of-behavior-with-closures\"></a>\n<a id=\"refactoring-using-functions\"></a>\n<a id=\"refactoring-with-closures-to-store-code\"></a>\n\n### Capturing the Environment with Closures\n\nWe’ll first examine how we can use closures to capture values from the\nenvironment they’re defined in for later use. Here’s the scenario: Every so\noften, our t-shirt company gives away an exclusive, limited-edition shirt to\nsomeone on our mailing list as a promotion. People on the mailing list can\noptionally add their favorite color to their profile. If the person chosen for\na free shirt has their favorite color set, they get that color shirt. If the\nperson hasn’t specified a favorite color, they get whatever color the company\ncurrently has the most of.\n\nThere are many ways to implement this. For this example, we’re going to use an\nenum called `ShirtColor` that has the variants `Red` and `Blue` (limiting the\nnumber of colors available for simplicity). We represent the company’s\ninventory with an `Inventory` struct that has a field named `shirts` that\ncontains a `Vec<ShirtColor>` representing the shirt colors currently in stock.\nThe method `giveaway` defined on `Inventory` gets the optional shirt\ncolor preference of the free shirt winner, and returns the shirt color the\nperson will get. This setup is shown in Listing 13-1:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 13-1: Shirt company giveaway situation</span>\n\nThe `store` defined in `main` has two blue shirts and one red shirt remaining\nto distribute for this limited-edition promotion. We call the `giveaway` method\nfor a user with a preference for a red shirt and a user without any preference.\n\nAgain, this code could be implemented in many ways, and here, to focus on\nclosures, we’ve stuck to concepts you’ve already learned except for the body of\nthe `giveaway` method that uses a closure. In the `giveaway` method, we get the\nuser preference as a parameter of type `Option<ShirtColor>` and call the\n`unwrap_or_else` method on `user_preference`. The [`unwrap_or_else` method on\n`Option<T>`][unwrap-or-else]<!-- ignore --> is defined by the standard library.\nIt takes one argument: a closure without any arguments that returns a value `T`\n(the same type stored in the `Some` variant of the `Option<T>`, in this case\n`ShirtColor`). If the `Option<T>` is the `Some` variant, `unwrap_or_else`\nreturns the value from within the `Some`. If the `Option<T>` is the `None`\nvariant, `unwrap_or_else` calls the closure and returns the value returned by\nthe closure.\n\nWe specify the closure expression `|| self.most_stocked()` as the argument to\n`unwrap_or_else`. This is a closure that takes no parameters itself (if the\nclosure had parameters, they would appear between the two vertical bars). The\nbody of the closure calls `self.most_stocked()`. We’re defining the closure\nhere, and the implementation of `unwrap_or_else` will evaluate the closure\nlater if the result is needed.\n\nRunning this code prints:\n\n```console\n{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}\n```\n\nOne interesting aspect here is that we’ve passed a closure that calls\n`self.most_stocked()` on the current `Inventory` instance. The standard library\ndidn’t need to know anything about the `Inventory` or `ShirtColor` types we\ndefined, or the logic we want to use in this scenario. The closure captures an\nimmutable reference to the `self` `Inventory` instance and passes it with the\ncode we specify to the `unwrap_or_else` method. Functions, on the other hand,\nare not able to capture their environment in this way.\n\n### Closure Type Inference and Annotation\n\nThere are more differences between functions and closures. Closures don’t\nusually require you to annotate the types of the parameters or the return value\nlike `fn` functions do. Type annotations are required on functions because the\ntypes are part of an explicit interface exposed to your users. Defining this\ninterface rigidly is important for ensuring that everyone agrees on what types\nof values a function uses and returns. Closures, on the other hand, aren’t used\nin an exposed interface like this: they’re stored in variables and used without\nnaming them and exposing them to users of our library.\n\nClosures are typically short and relevant only within a narrow context rather\nthan in any arbitrary scenario. Within these limited contexts, the compiler can\ninfer the types of the parameters and the return type, similar to how it’s able\nto infer the types of most variables (there are rare cases where the compiler\nneeds closure type annotations too).\n\nAs with variables, we can add type annotations if we want to increase\nexplicitness and clarity at the cost of being more verbose than is strictly\nnecessary. Annotating the types for a closure would look like the definition\nshown in Listing 13-2. In this example, we’re defining a closure and storing it\nin a variable rather than defining the closure in the spot we pass it as an\nargument as we did in Listing 13-1.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 13-2: Adding optional type annotations of the\nparameter and return value types in the closure</span>\n\nWith type annotations added, the syntax of closures looks more similar to the\nsyntax of functions. Here we define a function that adds 1 to its parameter and\na closure that has the same behavior, for comparison. We’ve added some spaces\nto line up the relevant parts. This illustrates how closure syntax is similar\nto function syntax except for the use of pipes and the amount of syntax that is\noptional:\n\n```rust,ignore\nfn  add_one_v1   (x: u32) -> u32 { x + 1 }\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n```\n\nThe first line shows a function definition, and the second line shows a fully\nannotated closure definition. In the third line, we remove the type annotations\nfrom the closure definition. In the fourth line, we remove the brackets, which\nare optional because the closure body has only one expression. These are all\nvalid definitions that will produce the same behavior when they’re called. The\n`add_one_v3` and `add_one_v4` lines require the closures to be evaluated to be\nable to compile because the types will be inferred from their usage. This is\nsimilar to `let v = Vec::new();` needing either type annotations or values of\nsome type to be inserted into the `Vec` for Rust to be able to infer the type.\n\nFor closure definitions, the compiler will infer one concrete type for each of\ntheir parameters and for their return value. For instance, Listing 13-3 shows\nthe definition of a short closure that just returns the value it receives as a\nparameter. This closure isn’t very useful except for the purposes of this\nexample. Note that we haven’t added any type annotations to the definition.\nBecause there are no type annotations, we can call the closure with any type,\nwhich we’ve done here with `String` the first time. If we then try to call\n`example_closure` with an integer, we’ll get an error.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 13-3: Attempting to call a closure whose types\nare inferred with two different types</span>\n\nThe compiler gives us this error:\n\n```console\n{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}\n```\n\nThe first time we call `example_closure` with the `String` value, the compiler\ninfers the type of `x` and the return type of the closure to be `String`. Those\ntypes are then locked into the closure in `example_closure`, and we get a type\nerror when we next try to use a different type with the same closure.\n\n### Capturing References or Moving Ownership\n\nClosures can capture values from their environment in three ways, which\ndirectly map to the three ways a function can take a parameter: borrowing\nimmutably, borrowing mutably, and taking ownership. The closure will decide\nwhich of these to use based on what the body of the function does with the\ncaptured values.\n\nIn Listing 13-4, we define a closure that captures an immutable reference to\nthe vector named `list` because it only needs an immutable reference to print\nthe value:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 13-4: Defining and calling a closure that\ncaptures an immutable reference</span>\n\nThis example also illustrates that a variable can bind to a closure definition,\nand we can later call the closure by using the variable name and parentheses as\nif the variable name were a function name.\n\nBecause we can have multiple immutable references to `list` at the same time,\n`list` is still accessible from the code before the closure definition, after\nthe closure definition but before the closure is called, and after the closure\nis called. This code compiles, runs, and prints:\n\n```console\n{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}\n```\n\nNext, in Listing 13-5, we change the closure body so that it adds an element to\nthe `list` vector. The closure now captures a mutable reference:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 13-5: Defining and calling a closure that\ncaptures a mutable reference</span>\n\nThis code compiles, runs, and prints:\n\n```console\n{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}\n```\n\nNote that there’s no longer a `println!` between the definition and the call of\nthe `borrows_mutably` closure: when `borrows_mutably` is defined, it captures a\nmutable reference to `list`. We don’t use the closure again after the closure\nis called, so the mutable borrow ends. Between the closure definition and the\nclosure call, an immutable borrow to print isn’t allowed because no other\nborrows are allowed when there’s a mutable borrow. Try adding a `println!`\nthere to see what error message you get!\n\nIf you want to force the closure to take ownership of the values it uses in the\nenvironment even though the body of the closure doesn’t strictly need\nownership, you can use the `move` keyword before the parameter list.\n\nThis technique is mostly useful when passing a closure to a new thread to move\nthe data so that it’s owned by the new thread. We’ll discuss threads and why\nyou would want to use them in detail in Chapter 16 when we talk about\nconcurrency, but for now, let’s briefly explore spawning a new thread using a\nclosure that needs the `move` keyword. Listing 13-6 shows Listing 13-4 modified\nto print the vector in a new thread rather than in the main thread:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 13-6: Using `move` to force the closure for the\nthread to take ownership of `list`</span>\n\nWe spawn a new thread, giving the thread a closure to run as an argument. The\nclosure body prints out the list. In Listing 13-4, the closure only captured\n`list` using an immutable reference because that's the least amount of access\nto `list` needed to print it. In this example, even though the closure body\nstill only needs an immutable reference, we need to specify that `list` should\nbe moved into the closure by putting the `move` keyword at the beginning of the\nclosure definition. The new thread might finish before the rest of the main\nthread finishes, or the main thread might finish first. If the main thread\nmaintained ownership of `list` but ended before the new thread did and dropped\n`list`, the immutable reference in the thread would be invalid. Therefore, the\ncompiler requires that `list` be moved into the closure given to the new thread\nso the reference will be valid. Try removing the `move` keyword or using `list`\nin the main thread after the closure is defined to see what compiler errors you\nget!\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"storing-closures-using-generic-parameters-and-the-fn-traits\"></a>\n<a id=\"limitations-of-the-cacher-implementation\"></a>\n<a id=\"moving-captured-values-out-of-the-closure-and-the-fn-traits\"></a>\n\n### Moving Captured Values Out of Closures and the `Fn` Traits\n\nOnce a closure has captured a reference or captured ownership of a value from\nthe environment where the closure is defined (thus affecting what, if anything,\nis moved *into* the closure), the code in the body of the closure defines what\nhappens to the references or values when the closure is evaluated later (thus\naffecting what, if anything, is moved *out of* the closure). A closure body can\ndo any of the following: move a captured value out of the closure, mutate the\ncaptured value, neither move nor mutate the value, or capture nothing from the\nenvironment to begin with.\n\nThe way a closure captures and handles values from the environment affects\nwhich traits the closure implements, and traits are how functions and structs\ncan specify what kinds of closures they can use. Closures will automatically\nimplement one, two, or all three of these `Fn` traits, in an additive fashion,\ndepending on how the closure’s body handles the values:\n\n1. `FnOnce` applies to closures that can be called once. All closures implement\n   at least this trait, because all closures can be called. A closure that\n   moves captured values out of its body will only implement `FnOnce` and none\n   of the other `Fn` traits, because it can only be called once.\n2. `FnMut` applies to closures that don’t move captured values out of their\n   body, but that might mutate the captured values. These closures can be\n   called more than once.\n3. `Fn` applies to closures that don’t move captured values out of their body\n   and that don’t mutate captured values, as well as closures that capture\n   nothing from their environment. These closures can be called more than once\n   without mutating their environment, which is important in cases such as\n   calling a closure multiple times concurrently.\n\nLet’s look at the definition of the `unwrap_or_else` method on `Option<T>` that\nwe used in Listing 13-1:\n\n```rust,ignore\nimpl<T> Option<T> {\n    pub fn unwrap_or_else<F>(self, f: F) -> T\n    where\n        F: FnOnce() -> T\n    {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n}\n```\n\nRecall that `T` is the generic type representing the type of the value in the\n`Some` variant of an `Option`. That type `T` is also the return type of the\n`unwrap_or_else` function: code that calls `unwrap_or_else` on an\n`Option<String>`, for example, will get a `String`.\n\nNext, notice that the `unwrap_or_else` function has the additional generic type\nparameter `F`. The `F` type is the type of the parameter named `f`, which is\nthe closure we provide when calling `unwrap_or_else`.\n\nThe trait bound specified on the generic type `F` is `FnOnce() -> T`, which\nmeans `F` must be able to be called once, take no arguments, and return a `T`.\nUsing `FnOnce` in the trait bound expresses the constraint that\n`unwrap_or_else` is only going to call `f` at most one time. In the body of\n`unwrap_or_else`, we can see that if the `Option` is `Some`, `f` won’t be\ncalled. If the `Option` is `None`, `f` will be called once. Because all\nclosures implement `FnOnce`, `unwrap_or_else` accepts the most different kinds\nof closures and is as flexible as it can be.\n\n> Note: Functions can implement all three of the `Fn` traits too. If what we\n> want to do doesn’t require capturing a value from the environment, we can use\n> the name of a function rather than a closure where we need something that\n> implements one of the `Fn` traits. For example, on an `Option<Vec<T>>` value,\n> we could call `unwrap_or_else(Vec::new)` to get a new, empty vector if the\n> value is `None`.\n\nNow let’s look at the standard library method `sort_by_key` defined on slices,\nto see how that differs from `unwrap_or_else` and why `sort_by_key` uses\n`FnMut` instead of `FnOnce` for the trait bound. The closure gets one argument\nin the form of a reference to the current item in the slice being considered,\nand returns a value of type `K` that can be ordered. This function is useful\nwhen you want to sort a slice by a particular attribute of each item. In\nListing 13-7, we have a list of `Rectangle` instances and we use `sort_by_key`\nto order them by their `width` attribute from low to high:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 13-7: Using `sort_by_key` to order rectangles by\nwidth</span>\n\nThis code prints:\n\n```console\n{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}\n```\n\nThe reason `sort_by_key` is defined to take an `FnMut` closure is that it calls\nthe closure multiple times: once for each item in the slice. The closure `|r|\nr.width` doesn’t capture, mutate, or move out anything from its environment, so\nit meets the trait bound requirements.\n\nIn contrast, Listing 13-8 shows an example of a closure that implements just\nthe `FnOnce` trait, because it moves a value out of the environment. The\ncompiler won’t let us use this closure with `sort_by_key`:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 13-8: Attempting to use an `FnOnce` closure with\n`sort_by_key`</span>\n\nThis is a contrived, convoluted way (that doesn’t work) to try and count the\nnumber of times `sort_by_key` gets called when sorting `list`. This code\nattempts to do this counting by pushing `value`—a `String` from the closure’s\nenvironment—into the `sort_operations` vector. The closure captures `value`\nthen moves `value` out of the closure by transferring ownership of `value` to\nthe `sort_operations` vector. This closure can be called once; trying to call\nit a second time wouldn’t work because `value` would no longer be in the\nenvironment to be pushed into `sort_operations` again! Therefore, this closure\nonly implements `FnOnce`. When we try to compile this code, we get this error\nthat `value` can’t be moved out of the closure because the closure must\nimplement `FnMut`:\n\n```console\n{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}\n```\n\nThe error points to the line in the closure body that moves `value` out of the\nenvironment. To fix this, we need to change the closure body so that it doesn’t\nmove values out of the environment. To count the number of times `sort_by_key`\nis called, keeping a counter in the environment and incrementing its value in\nthe closure body is a more straightforward way to calculate that. The closure\nin Listing 13-9 works with `sort_by_key` because it is only capturing a mutable\nreference to the `num_sort_operations` counter and can therefore be called more\nthan once:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 13-9: Using an `FnMut` closure with `sort_by_key`\nis allowed</span>\n\nThe `Fn` traits are important when defining or using functions or types that\nmake use of closures. In the next section, we’ll discuss iterators. Many\niterator methods take closure arguments, so keep these closure details in mind\nas we continue!\n\n[unwrap-or-else]: ../std/option/enum.Option.html#method.unwrap_or_else\n",
          "document_id": 63
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What is the purpose of an iterator?",
              "id": 2176,
              "answers": [
                {
                  "answer_id": 2181,
                  "document_id": 64,
                  "question_id": 2176,
                  "text": "allows you to perform some task on a sequence of items in\nturn",
                  "answer_start": 69,
                  "answer_end": 131,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is iterator responsible for?",
              "id": 2177,
              "answers": [
                {
                  "answer_id": 2182,
                  "document_id": 64,
                  "question_id": 2177,
                  "text": "for the logic of iterating over each item and\ndetermining when the sequence has finished",
                  "answer_start": 160,
                  "answer_end": 248,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Are iterators in Rust eager?",
              "id": 2178,
              "answers": [
                {
                  "answer_id": 2183,
                  "document_id": 64,
                  "question_id": 2178,
                  "text": "In Rust, iterators are *lazy*",
                  "answer_start": 326,
                  "answer_end": 355,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does it mean that iterators are lazy?",
              "id": 2179,
              "answers": [
                {
                  "answer_id": 2184,
                  "document_id": 64,
                  "question_id": 2179,
                  "text": "they have no effect until you call\nmethods that consume the iterator to use it up",
                  "answer_start": 365,
                  "answer_end": 446,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Processing a Series of Items with Iterators\n\nThe iterator pattern allows you to perform some task on a sequence of items in\nturn. An iterator is responsible for the logic of iterating over each item and\ndetermining when the sequence has finished. When you use iterators, you don’t\nhave to reimplement that logic yourself.\n\nIn Rust, iterators are *lazy*, meaning they have no effect until you call\nmethods that consume the iterator to use it up. For example, the code in\nListing 13-10 creates an iterator over the items in the vector `v1` by calling\nthe `iter` method defined on `Vec<T>`. This code by itself doesn’t do anything\nuseful.\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 13-10: Creating an iterator</span>\n\nThe iterator is stored in the `v1_iter` variable. Once we’ve created an\niterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we\niterated over an array using a `for` loop to execute some code on each of its\nitems. Under the hood this implicitly created and then consumed an iterator,\nbut we glossed over how exactly that works until now.\n\nIn the example in Listing 13-11, we separate the creation of the iterator from\nthe use of the iterator in the `for` loop. When the `for` loop is called using\nthe iterator in `v1_iter`, each element in the iterator is used in one\niteration of the loop, which prints out each value.\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 13-11: Using an iterator in a `for` loop</span>\n\nIn languages that don’t have iterators provided by their standard libraries,\nyou would likely write this same functionality by starting a variable at index\n0, using that variable to index into the vector to get a value, and\nincrementing the variable value in a loop until it reached the total number of\nitems in the vector.\n\nIterators handle all that logic for you, cutting down on repetitive code you\ncould potentially mess up. Iterators give you more flexibility to use the same\nlogic with many different kinds of sequences, not just data structures you can\nindex into, like vectors. Let’s examine how iterators do that.\n\n### The `Iterator` Trait and the `next` Method\n\nAll iterators implement a trait named `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this:\n\n```rust\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // methods with default implementations elided\n}\n```\n\nNotice this definition uses some new syntax: `type Item` and `Self::Item`,\nwhich are defining an *associated type* with this trait. We’ll talk about\nassociated types in depth in Chapter 19. For now, all you need to know is that\nthis code says implementing the `Iterator` trait requires that you also define\nan `Item` type, and this `Item` type is used in the return type of the `next`\nmethod. In other words, the `Item` type will be the type returned from the\niterator.\n\nThe `Iterator` trait only requires implementors to define one method: the\n`next` method, which returns one item of the iterator at a time wrapped in\n`Some` and, when iteration is over, returns `None`.\n\nWe can call the `next` method on iterators directly; Listing 13-12 demonstrates\nwhat values are returned from repeated calls to `next` on the iterator created\nfrom the vector.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 13-12: Calling the `next` method on an\niterator</span>\n\nNote that we needed to make `v1_iter` mutable: calling the `next` method on an\niterator changes internal state that the iterator uses to keep track of where\nit is in the sequence. In other words, this code *consumes*, or uses up, the\niterator. Each call to `next` eats up an item from the iterator. We didn’t need\nto make `v1_iter` mutable when we used a `for` loop because the loop took\nownership of `v1_iter` and made it mutable behind the scenes.\n\nAlso note that the values we get from the calls to `next` are immutable\nreferences to the values in the vector. The `iter` method produces an iterator\nover immutable references. If we want to create an iterator that takes\nownership of `v1` and returns owned values, we can call `into_iter` instead of\n`iter`. Similarly, if we want to iterate over mutable references, we can call\n`iter_mut` instead of `iter`.\n\n### Methods that Consume the Iterator\n\nThe `Iterator` trait has a number of different methods with default\nimplementations provided by the standard library; you can find out about these\nmethods by looking in the standard library API documentation for the `Iterator`\ntrait. Some of these methods call the `next` method in their definition, which\nis why you’re required to implement the `next` method when implementing the\n`Iterator` trait.\n\nMethods that call `next` are called *consuming adaptors*, because calling them\nuses up the iterator. One example is the `sum` method, which takes ownership of\nthe iterator and iterates through the items by repeatedly calling `next`, thus\nconsuming the iterator. As it iterates through, it adds each item to a running\ntotal and returns the total when iteration is complete. Listing 13-13 has a\ntest illustrating a use of the `sum` method:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-13/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 13-13: Calling the `sum` method to get the total\nof all items in the iterator</span>\n\nWe aren’t allowed to use `v1_iter` after the call to `sum` because `sum` takes\nownership of the iterator we call it on.\n\n### Methods that Produce Other Iterators\n\n*Iterator adaptors* are methods defined on the `Iterator` trait that don’t\nconsume the iterator. Instead, they produce different iterators by changing\nsome aspect of the original iterator.\n\nListing 13-14 shows an example of calling the iterator adaptor method `map`,\nwhich takes a closure to call on each item as the items are iterated through.\nThe `map` method returns a new iterator that produces the modified items. The\nclosure here creates a new iterator in which each item from the vector will be\nincremented by 1:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,not_desired_behavior\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-14/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 13-14: Calling the iterator adaptor `map` to\ncreate a new iterator</span>\n\nHowever, this code produces a warning:\n\n```console\n{{#include ../listings/ch13-functional-features/listing-13-14/output.txt}}\n```\n\nThe code in Listing 13-14 doesn’t do anything; the closure we’ve specified\nnever gets called. The warning reminds us why: iterator adaptors are lazy, and\nwe need to consume the iterator here.\n\nTo fix this warning and consume the iterator, we’ll use the `collect` method,\nwhich we used in Chapter 12 with `env::args` in Listing 12-1. This method\nconsumes the iterator and collects the resulting values into a collection data\ntype.\n\nIn Listing 13-15, we collect the results of iterating over the iterator that’s\nreturned from the call to `map` into a vector. This vector will end up\ncontaining each item from the original vector incremented by 1.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-15/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 13-15: Calling the `map` method to create a new\niterator and then calling the `collect` method to consume the new iterator and\ncreate a vector</span>\n\nBecause `map` takes a closure, we can specify any operation we want to perform\non each item. This is a great example of how closures let you customize some\nbehavior while reusing the iteration behavior that the `Iterator` trait\nprovides.\n\nYou can chain multiple calls to iterator adaptors to perform complex actions in\na readable way. But because all iterators are lazy, you have to call one of the\nconsuming adaptor methods to get results from calls to iterator adaptors.\n\n### Using Closures that Capture Their Environment\n\nMany iterator adapters take closures as arguments, and commonly the closures\nwe’ll specify as arguments to iterator adapters will be closures that capture\ntheir environment.\n\nFor this example, we’ll use the `filter` method that takes a closure. The\nclosure gets an item from the iterator and returns a `bool`. If the closure\nreturns `true`, the value will be included in the iteration produced by\n`filter`. If the closure returns `false`, the value won’t be included.\n\nIn Listing 13-16, we use `filter` with a closure that captures the `shoe_size`\nvariable from its environment to iterate over a collection of `Shoe` struct\ninstances. It will return only shoes that are the specified size.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-16/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 13-16: Using the `filter` method with a closure\nthat captures `shoe_size`</span>\n\nThe `shoes_in_size` function takes ownership of a vector of shoes and a shoe\nsize as parameters. It returns a vector containing only shoes of the specified\nsize.\n\nIn the body of `shoes_in_size`, we call `into_iter` to create an iterator\nthat takes ownership of the vector. Then we call `filter` to adapt that\niterator into a new iterator that only contains elements for which the closure\nreturns `true`.\n\nThe closure captures the `shoe_size` parameter from the environment and\ncompares the value with each shoe’s size, keeping only shoes of the size\nspecified. Finally, calling `collect` gathers the values returned by the\nadapted iterator into a vector that’s returned by the function.\n\nThe test shows that when we call `shoes_in_size`, we get back only shoes\nthat have the same size as the value we specified.\n",
          "document_id": 64
        }
      ]
    }
  ]
}