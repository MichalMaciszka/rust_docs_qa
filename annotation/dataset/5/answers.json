{
  "data": [
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What is state pattern?",
              "id": 24,
              "answers": [
                {
                  "answer_id": 25,
                  "document_id": 3,
                  "question_id": 24,
                  "text": "The *state pattern* is an object-oriented design pattern. The crux of the\npattern is that we define a set of states a value can have internally. The\nstates are represented by a set of *state objects*, and the value’s behavior\nchanges based on its state.",
                  "answer_start": 51,
                  "answer_end": 304,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the advantage of using the state pattern?",
              "id": 25,
              "answers": [
                {
                  "answer_id": 26,
                  "document_id": 3,
                  "question_id": 25,
                  "text": "The advantage of using the state pattern is that, when the business\nrequirements of the program change, we won’t need to change the code of the\nvalue holding the state or the code that uses the value. We’ll only need to\nupdate the code inside one of the state objects to change its rules or perhaps\nadd more state objects.",
                  "answer_start": 848,
                  "answer_end": 1170,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the downside of the state pattern?",
              "id": 26,
              "answers": [
                {
                  "answer_id": 27,
                  "document_id": 3,
                  "question_id": 26,
                  "text": "the states implement the\ntransitions between states, some of the states are coupled to each other.",
                  "answer_start": 17385,
                  "answer_end": 17483,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What gives the programmer dynamic dispatch?",
              "id": 27,
              "answers": [
                {
                  "answer_id": 28,
                  "document_id": 3,
                  "question_id": 27,
                  "text": "Dynamic dispatch can give your code some\nflexibility in exchange for a bit of runtime performance.",
                  "answer_start": 25623,
                  "answer_end": 25721,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Implementing an Object-Oriented Design Pattern\n\nThe *state pattern* is an object-oriented design pattern. The crux of the\npattern is that we define a set of states a value can have internally. The\nstates are represented by a set of *state objects*, and the value’s behavior\nchanges based on its state. We’re going to work through an example of a blog\npost struct that has a field to hold its state, which will be a state object\nfrom the set \"draft\", \"review\", or \"published\".\n\nThe state objects share functionality: in Rust, of course, we use structs and\ntraits rather than objects and inheritance. Each state object is responsible\nfor its own behavior and for governing when it should change into another\nstate. The value that holds a state object knows nothing about the different\nbehavior of the states or when to transition between states.\n\nThe advantage of using the state pattern is that, when the business\nrequirements of the program change, we won’t need to change the code of the\nvalue holding the state or the code that uses the value. We’ll only need to\nupdate the code inside one of the state objects to change its rules or perhaps\nadd more state objects.\n\nFirst, we’re going to implement the state pattern in a more traditional\nobject-oriented way, then we’ll use an approach that’s a bit more natural in\nRust. Let’s dig in to incrementally implementing a blog post workflow using the\nstate pattern.\n\nThe final functionality will look like this:\n\n1. A blog post starts as an empty draft.\n2. When the draft is done, a review of the post is requested.\n3. When the post is approved, it gets published.\n4. Only published blog posts return content to print, so unapproved posts can’t\n   accidentally be published.\n\nAny other changes attempted on a post should have no effect. For example, if we\ntry to approve a draft blog post before we’ve requested a review, the post\nshould remain an unpublished draft.\n\nListing 17-11 shows this workflow in code form: this is an example usage of the\nAPI we’ll implement in a library crate named `blog`. This won’t compile yet\nbecause we haven’t implemented the `blog` crate.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch17-oop/listing-17-11/src/main.rs:all}}\n```\n\n<span class=\"caption\">Listing 17-11: Code that demonstrates the desired\nbehavior we want our `blog` crate to have</span>\n\nWe want to allow the user to create a new draft blog post with `Post::new`. We\nwant to allow text to be added to the blog post. If we try to get the post’s\ncontent immediately, before approval, we shouldn’t get any text because the\npost is still a draft. We’ve added `assert_eq!` in the code for demonstration\npurposes. An excellent unit test for this would be to assert that a draft blog\npost returns an empty string from the `content` method, but we’re not going to\nwrite tests for this example.\n\nNext, we want to enable a request for a review of the post, and we want\n`content` to return an empty string while waiting for the review. When the post\nreceives approval, it should get published, meaning the text of the post will\nbe returned when `content` is called.\n\nNotice that the only type we’re interacting with from the crate is the `Post`\ntype. This type will use the state pattern and will hold a value that will be\none of three state objects representing the various states a post can be\nin—draft, waiting for review, or published. Changing from one state to another\nwill be managed internally within the `Post` type. The states change in\nresponse to the methods called by our library’s users on the `Post` instance,\nbut they don’t have to manage the state changes directly. Also, users can’t\nmake a mistake with the states, like publishing a post before it’s reviewed.\n\n### Defining `Post` and Creating a New Instance in the Draft State\n\nLet’s get started on the implementation of the library! We know we need a\npublic `Post` struct that holds some content, so we’ll start with the\ndefinition of the struct and an associated public `new` function to create an\ninstance of `Post`, as shown in Listing 17-12. We’ll also make a private\n`State` trait that will define the behavior that all state objects for a `Post`\nmust have.\n\nThen `Post` will hold a trait object of `Box<dyn State>` inside an `Option<T>`\nin a private field named `state` to hold the state object. You’ll see why the\n`Option<T>` is necessary in a bit.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-12/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 17-12: Definition of a `Post` struct and a `new`\nfunction that creates a new `Post` instance, a `State` trait, and a `Draft`\nstruct</span>\n\nThe `State` trait defines the behavior shared by different post states. The\nstate objects are `Draft`, `PendingReview`, and `Published`, and they will all\nimplement the `State` trait. For now, the trait doesn’t have any methods, and\nwe’ll start by defining just the `Draft` state because that is the state we\nwant a post to start in.\n\nWhen we create a new `Post`, we set its `state` field to a `Some` value that\nholds a `Box`. This `Box` points to a new instance of the `Draft` struct.\nThis ensures whenever we create a new instance of `Post`, it will start out as\na draft. Because the `state` field of `Post` is private, there is no way to\ncreate a `Post` in any other state! In the `Post::new` function, we set the\n`content` field to a new, empty `String`.\n\n### Storing the Text of the Post Content\n\nWe saw in Listing 17-11 that we want to be able to call a method named\n`add_text` and pass it a `&str` that is then added as the text content of the\nblog post. We implement this as a method, rather than exposing the `content`\nfield as `pub`, so that later we can implement a method that will control how\nthe `content` field’s data is read. The `add_text` method is pretty\nstraightforward, so let’s add the implementation in Listing 17-13 to the `impl\nPost` block:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-13/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-13: Implementing the `add_text` method to add\ntext to a post’s `content`</span>\n\nThe `add_text` method takes a mutable reference to `self`, because we’re\nchanging the `Post` instance that we’re calling `add_text` on. We then call\n`push_str` on the `String` in `content` and pass the `text` argument to add to\nthe saved `content`. This behavior doesn’t depend on the state the post is in,\nso it’s not part of the state pattern. The `add_text` method doesn’t interact\nwith the `state` field at all, but it is part of the behavior we want to\nsupport.\n\n### Ensuring the Content of a Draft Post Is Empty\n\nEven after we’ve called `add_text` and added some content to our post, we still\nwant the `content` method to return an empty string slice because the post is\nstill in the draft state, as shown on line 7 of Listing 17-11. For now, let’s\nimplement the `content` method with the simplest thing that will fulfill this\nrequirement: always returning an empty string slice. We’ll change this later\nonce we implement the ability to change a post’s state so it can be published.\nSo far, posts can only be in the draft state, so the post content should always\nbe empty. Listing 17-14 shows this placeholder implementation:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-14/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-14: Adding a placeholder implementation for\nthe `content` method on `Post` that always returns an empty string slice</span>\n\nWith this added `content` method, everything in Listing 17-11 up to line 7\nworks as intended.\n\n### Requesting a Review of the Post Changes Its State\n\nNext, we need to add functionality to request a review of a post, which should\nchange its state from `Draft` to `PendingReview`. Listing 17-15 shows this code:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-15/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-15: Implementing `request_review` methods on\n`Post` and the `State` trait</span>\n\nWe give `Post` a public method named `request_review` that will take a mutable\nreference to `self`. Then we call an internal `request_review` method on the\ncurrent state of `Post`, and this second `request_review` method consumes the\ncurrent state and returns a new state.\n\nWe add the `request_review` method to the `State` trait; all types that\nimplement the trait will now need to implement the `request_review` method.\nNote that rather than having `self`, `&self`, or `&mut self` as the first\nparameter of the method, we have `self: Box<Self>`. This syntax means the\nmethod is only valid when called on a `Box` holding the type. This syntax takes\nownership of `Box<Self>`, invalidating the old state so the state value of the\n`Post` can transform into a new state.\n\nTo consume the old state, the `request_review` method needs to take ownership\nof the state value. This is where the `Option` in the `state` field of `Post`\ncomes in: we call the `take` method to take the `Some` value out of the `state`\nfield and leave a `None` in its place, because Rust doesn’t let us have\nunpopulated fields in structs. This lets us move the `state` value out of\n`Post` rather than borrowing it. Then we’ll set the post’s `state` value to the\nresult of this operation.\n\nWe need to set `state` to `None` temporarily rather than setting it directly\nwith code like `self.state = self.state.request_review();` to get ownership of\nthe `state` value. This ensures `Post` can’t use the old `state` value after\nwe’ve transformed it into a new state.\n\nThe `request_review` method on `Draft` returns a new, boxed instance of a new\n`PendingReview` struct, which represents the state when a post is waiting for a\nreview. The `PendingReview` struct also implements the `request_review` method\nbut doesn’t do any transformations. Rather, it returns itself, because when we\nrequest a review on a post already in the `PendingReview` state, it should stay\nin the `PendingReview` state.\n\nNow we can start seeing the advantages of the state pattern: the\n`request_review` method on `Post` is the same no matter its `state` value. Each\nstate is responsible for its own rules.\n\nWe’ll leave the `content` method on `Post` as is, returning an empty string\nslice. We can now have a `Post` in the `PendingReview` state as well as in the\n`Draft` state, but we want the same behavior in the `PendingReview` state.\nListing 17-11 now works up to line 10!\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"adding-the-approve-method-that-changes-the-behavior-of-content\"></a>\n\n### Adding `approve` to Change the Behavior of `content`\n\nThe `approve` method will be similar to the `request_review` method: it will\nset `state` to the value that the current state says it should have when that\nstate is approved, as shown in Listing 17-16:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-16/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-16: Implementing the `approve` method on\n`Post` and the `State` trait</span>\n\nWe add the `approve` method to the `State` trait and add a new struct that\nimplements `State`, the `Published` state.\n\nSimilar to the way `request_review` on `PendingReview` works, if we call the\n`approve` method on a `Draft`, it will have no effect because `approve` will\nreturn `self`. When we call `approve` on `PendingReview`, it returns a new,\nboxed instance of the `Published` struct. The `Published` struct implements the\n`State` trait, and for both the `request_review` method and the `approve`\nmethod, it returns itself, because the post should stay in the `Published`\nstate in those cases.\n\nNow we need to update the `content` method on `Post`. We want the value\nreturned from `content` to depend on the current state of the `Post`, so we’re\ngoing to have the `Post` delegate to a `content` method defined on its `state`,\nas shown in Listing 17-17:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch17-oop/listing-17-17/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-17: Updating the `content` method on `Post` to\ndelegate to a `content` method on `State`</span>\n\nBecause the goal is to keep all these rules inside the structs that implement\n`State`, we call a `content` method on the value in `state` and pass the post\ninstance (that is, `self`) as an argument. Then we return the value that’s\nreturned from using the `content` method on the `state` value.\n\nWe call the `as_ref` method on the `Option` because we want a reference to the\nvalue inside the `Option` rather than ownership of the value. Because `state`\nis an `Option<Box<dyn State>>`, when we call `as_ref`, an `Option<&Box<dyn\nState>>` is returned. If we didn’t call `as_ref`, we would get an error because\nwe can’t move `state` out of the borrowed `&self` of the function parameter.\n\nWe then call the `unwrap` method, which we know will never panic, because we\nknow the methods on `Post` ensure that `state` will always contain a `Some`\nvalue when those methods are done. This is one of the cases we talked about in\nthe [“Cases In Which You Have More Information Than the\nCompiler”][more-info-than-rustc]<!-- ignore --> section of Chapter 9 when we\nknow that a `None` value is never possible, even though the compiler isn’t able\nto understand that.\n\nAt this point, when we call `content` on the `&Box<dyn State>`, deref coercion\nwill take effect on the `&` and the `Box` so the `content` method will\nultimately be called on the type that implements the `State` trait. That means\nwe need to add `content` to the `State` trait definition, and that is where\nwe’ll put the logic for what content to return depending on which state we\nhave, as shown in Listing 17-18:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-18/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-18: Adding the `content` method to the `State`\ntrait</span>\n\nWe add a default implementation for the `content` method that returns an empty\nstring slice. That means we don’t need to implement `content` on the `Draft`\nand `PendingReview` structs. The `Published` struct will override the `content`\nmethod and return the value in `post.content`.\n\nNote that we need lifetime annotations on this method, as we discussed in\nChapter 10. We’re taking a reference to a `post` as an argument and returning a\nreference to part of that `post`, so the lifetime of the returned reference is\nrelated to the lifetime of the `post` argument.\n\nAnd we’re done—all of Listing 17-11 now works! We’ve implemented the state\npattern with the rules of the blog post workflow. The logic related to the\nrules lives in the state objects rather than being scattered throughout `Post`.\n\n> #### Why Not An Enum?\n>\n> You may have been wondering why we didn’t use an `enum` with the different\n> possible post states as variants. That’s certainly a possible solution, try\n> it and compare the end results to see which you prefer! One disadvantage of\n> using an enum is every place that checks the value of the enum will need a\n> `match` expression or similar to handle every possible variant. This could\n> get more repetitive than this trait object solution.\n\n### Trade-offs of the State Pattern\n\nWe’ve shown that Rust is capable of implementing the object-oriented state\npattern to encapsulate the different kinds of behavior a post should have in\neach state. The methods on `Post` know nothing about the various behaviors. The\nway we organized the code, we have to look in only one place to know the\ndifferent ways a published post can behave: the implementation of the `State`\ntrait on the `Published` struct.\n\nIf we were to create an alternative implementation that didn’t use the state\npattern, we might instead use `match` expressions in the methods on `Post` or\neven in the `main` code that checks the state of the post and changes behavior\nin those places. That would mean we would have to look in several places to\nunderstand all the implications of a post being in the published state! This\nwould only increase the more states we added: each of those `match` expressions\nwould need another arm.\n\nWith the state pattern, the `Post` methods and the places we use `Post` don’t\nneed `match` expressions, and to add a new state, we would only need to add a\nnew struct and implement the trait methods on that one struct.\n\nThe implementation using the state pattern is easy to extend to add more\nfunctionality. To see the simplicity of maintaining code that uses the state\npattern, try a few of these suggestions:\n\n* Add a `reject` method that changes the post’s state from `PendingReview` back\n  to `Draft`.\n* Require two calls to `approve` before the state can be changed to `Published`.\n* Allow users to add text content only when a post is in the `Draft` state.\n  Hint: have the state object responsible for what might change about the\n  content but not responsible for modifying the `Post`.\n\nOne downside of the state pattern is that, because the states implement the\ntransitions between states, some of the states are coupled to each other. If we\nadd another state between `PendingReview` and `Published`, such as `Scheduled`,\nwe would have to change the code in `PendingReview` to transition to\n`Scheduled` instead. It would be less work if `PendingReview` didn’t need to\nchange with the addition of a new state, but that would mean switching to\nanother design pattern.\n\nAnother downside is that we’ve duplicated some logic. To eliminate some of the\nduplication, we might try to make default implementations for the\n`request_review` and `approve` methods on the `State` trait that return `self`;\nhowever, this would violate object safety, because the trait doesn’t know what\nthe concrete `self` will be exactly. We want to be able to use `State` as a\ntrait object, so we need its methods to be object safe.\n\nOther duplication includes the similar implementations of the `request_review`\nand `approve` methods on `Post`. Both methods delegate to the implementation of\nthe same method on the value in the `state` field of `Option` and set the new\nvalue of the `state` field to the result. If we had a lot of methods on `Post`\nthat followed this pattern, we might consider defining a macro to eliminate the\nrepetition (see the [“Macros”][macros]<!-- ignore --> section in Chapter 19).\n\nBy implementing the state pattern exactly as it’s defined for object-oriented\nlanguages, we’re not taking as full advantage of Rust’s strengths as we could.\nLet’s look at some changes we can make to the `blog` crate that can make\ninvalid states and transitions into compile time errors.\n\n#### Encoding States and Behavior as Types\n\nWe’ll show you how to rethink the state pattern to get a different set of\ntrade-offs. Rather than encapsulating the states and transitions completely so\noutside code has no knowledge of them, we’ll encode the states into different\ntypes. Consequently, Rust’s type checking system will prevent attempts to use\ndraft posts where only published posts are allowed by issuing a compiler error.\n\nLet’s consider the first part of `main` in Listing 17-11:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch17-oop/listing-17-11/src/main.rs:here}}\n```\n\nWe still enable the creation of new posts in the draft state using `Post::new`\nand the ability to add text to the post’s content. But instead of having a\n`content` method on a draft post that returns an empty string, we’ll make it so\ndraft posts don’t have the `content` method at all. That way, if we try to get\na draft post’s content, we’ll get a compiler error telling us the method\ndoesn’t exist. As a result, it will be impossible for us to accidentally\ndisplay draft post content in production, because that code won’t even compile.\nListing 17-19 shows the definition of a `Post` struct and a `DraftPost` struct,\nas well as methods on each:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-19/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 17-19: A `Post` with a `content` method and a\n`DraftPost` without a `content` method</span>\n\nBoth the `Post` and `DraftPost` structs have a private `content` field that\nstores the blog post text. The structs no longer have the `state` field because\nwe’re moving the encoding of the state to the types of the structs. The `Post`\nstruct will represent a published post, and it has a `content` method that\nreturns the `content`.\n\nWe still have a `Post::new` function, but instead of returning an instance of\n`Post`, it returns an instance of `DraftPost`. Because `content` is private\nand there aren’t any functions that return `Post`, it’s not possible to create\nan instance of `Post` right now.\n\nThe `DraftPost` struct has an `add_text` method, so we can add text to\n`content` as before, but note that `DraftPost` does not have a `content` method\ndefined! So now the program ensures all posts start as draft posts, and draft\nposts don’t have their content available for display. Any attempt to get around\nthese constraints will result in a compiler error.\n\n#### Implementing Transitions as Transformations into Different Types\n\nSo how do we get a published post? We want to enforce the rule that a draft\npost has to be reviewed and approved before it can be published. A post in the\npending review state should still not display any content. Let’s implement\nthese constraints by adding another struct, `PendingReviewPost`, defining the\n`request_review` method on `DraftPost` to return a `PendingReviewPost`, and\ndefining an `approve` method on `PendingReviewPost` to return a `Post`, as\nshown in Listing 17-20:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-20/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-20: A `PendingReviewPost` that gets created by\ncalling `request_review` on `DraftPost` and an `approve` method that turns a\n`PendingReviewPost` into a published `Post`</span>\n\nThe `request_review` and `approve` methods take ownership of `self`, thus\nconsuming the `DraftPost` and `PendingReviewPost` instances and transforming\nthem into a `PendingReviewPost` and a published `Post`, respectively. This way,\nwe won’t have any lingering `DraftPost` instances after we’ve called\n`request_review` on them, and so forth. The `PendingReviewPost` struct doesn’t\nhave a `content` method defined on it, so attempting to read its content\nresults in a compiler error, as with `DraftPost`. Because the only way to get a\npublished `Post` instance that does have a `content` method defined is to call\nthe `approve` method on a `PendingReviewPost`, and the only way to get a\n`PendingReviewPost` is to call the `request_review` method on a `DraftPost`,\nwe’ve now encoded the blog post workflow into the type system.\n\nBut we also have to make some small changes to `main`. The `request_review` and\n`approve` methods return new instances rather than modifying the struct they’re\ncalled on, so we need to add more `let post =` shadowing assignments to save\nthe returned instances. We also can’t have the assertions about the draft and\npending review posts’ contents be empty strings, nor do we need them: we can’t\ncompile code that tries to use the content of posts in those states any longer.\nThe updated code in `main` is shown in Listing 17-21:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch17-oop/listing-17-21/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 17-21: Modifications to `main` to use the new\nimplementation of the blog post workflow</span>\n\nThe changes we needed to make to `main` to reassign `post` mean that this\nimplementation doesn’t quite follow the object-oriented state pattern anymore:\nthe transformations between the states are no longer encapsulated entirely\nwithin the `Post` implementation. However, our gain is that invalid states are\nnow impossible because of the type system and the type checking that happens at\ncompile time! This ensures that certain bugs, such as display of the content of\nan unpublished post, will be discovered before they make it to production.\n\nTry the tasks suggested at the start of this section on the `blog` crate as it\nis after Listing 17-21 to see what you think about the design of this version\nof the code. Note that some of the tasks might be completed already in this\ndesign.\n\nWe’ve seen that even though Rust is capable of implementing object-oriented\ndesign patterns, other patterns, such as encoding state into the type system,\nare also available in Rust. These patterns have different trade-offs. Although\nyou might be very familiar with object-oriented patterns, rethinking the\nproblem to take advantage of Rust’s features can provide benefits, such as\npreventing some bugs at compile time. Object-oriented patterns won’t always be\nthe best solution in Rust due to certain features, like ownership, that\nobject-oriented languages don’t have.\n\n## Summary\n\nNo matter whether or not you think Rust is an object-oriented language after\nreading this chapter, you now know that you can use trait objects to get some\nobject-oriented features in Rust. Dynamic dispatch can give your code some\nflexibility in exchange for a bit of runtime performance. You can use this\nflexibility to implement object-oriented patterns that can help your code’s\nmaintainability. Rust also has other features, like ownership, that\nobject-oriented languages don’t have. An object-oriented pattern won’t always\nbe the best way to take advantage of Rust’s strengths, but is an available\noption.\n\nNext, we’ll look at patterns, which are another of Rust’s features that enable\nlots of flexibility. We’ve looked at them briefly throughout the book but\nhaven’t seen their full capability yet. Let’s go!\n\n[more-info-than-rustc]: ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler\n[macros]: ch19-06-macros.html#macros\n",
          "document_id": 3
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "How to use patterns in the arms of `match` expressions?",
              "id": 30,
              "answers": [
                {
                  "answer_id": 31,
                  "document_id": 5,
                  "question_id": 30,
                  "text": "match VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}",
                  "answer_start": 530,
                  "answer_end": 626,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How can I be sure that I covered every possibility in arms of match expression?",
              "id": 31,
              "answers": [
                {
                  "answer_id": 33,
                  "document_id": 5,
                  "question_id": 31,
                  "text": "One way to ensure you’ve covered every possibility is to have\na catchall pattern for the last arm: for example, a variable name matching any\nvalue can never fail and thus covers every remaining case.\n\nThe particular pattern `_` will match anything, but it never binds to a\nvariable, so it’s often used in the last match arm. The `_` pattern can be\nuseful when you want to ignore any value not specified, for example.",
                  "answer_start": 1104,
                  "answer_end": 1520,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the downside of using `if let` expressions?",
              "id": 32,
              "answers": [
                {
                  "answer_id": 34,
                  "document_id": 5,
                  "question_id": 32,
                  "text": "The downside of using `if let` expressions is that the compiler doesn’t check\nfor exhaustiveness, whereas with `match` expressions it does. If we omitted the\nlast `else` block and therefore missed handling some cases, the compiler would\nnot alert us to the possible logic bug.",
                  "answer_start": 3909,
                  "answer_end": 4185,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How does `while let` conditional Loop works?",
              "id": 33,
              "answers": [
                {
                  "answer_id": 35,
                  "document_id": 5,
                  "question_id": 33,
                  "text": "`while let` conditional loop allows a\n`while` loop to run for as long as a pattern continues to match.",
                  "answer_start": 4263,
                  "answer_end": 4365,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is there a loop with pattern in Rust?",
              "id": 34,
              "answers": [
                {
                  "answer_id": 36,
                  "document_id": 5,
                  "question_id": 34,
                  "text": "In a `for` loop, the value that directly follows the keyword `for` is a\npattern. For example, in `for x in y` the `x` is the pattern.",
                  "answer_start": 5137,
                  "answer_end": 5270,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What happens when pattern doesn’t match the number of elements in the tuple?",
              "id": 35,
              "answers": [
                {
                  "answer_id": 37,
                  "document_id": 5,
                  "question_id": 35,
                  "text": "If the number of elements in the pattern doesn’t match the number of elements\nin the tuple, the overall type won’t match and we’ll get a compiler error.",
                  "answer_start": 7715,
                  "answer_end": 7867,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## All the Places Patterns Can Be Used\n\nPatterns pop up in a number of places in Rust, and you’ve been using them a lot\nwithout realizing it! This section discusses all the places where patterns are\nvalid.\n\n### `match` Arms\n\nAs discussed in Chapter 6, we use patterns in the arms of `match` expressions.\nFormally, `match` expressions are defined as the keyword `match`, a value to\nmatch on, and one or more match arms that consist of a pattern and an\nexpression to run if the value matches that arm’s pattern, like this:\n\n```text\nmatch VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}\n```\n\nFor example, here's the `match` expression from Listing 6-5 that matches on an\n`Option<i32>` value in the variable `x`:\n\n```rust,ignore\nmatch x {\n    None => None,\n    Some(i) => Some(i + 1),\n}\n```\n\nThe patterns in this `match` expression are the `None` and `Some(i)` on the\nleft of each arrow.\n\nOne requirement for `match` expressions is that they need to be *exhaustive* in\nthe sense that all possibilities for the value in the `match` expression must\nbe accounted for. One way to ensure you’ve covered every possibility is to have\na catchall pattern for the last arm: for example, a variable name matching any\nvalue can never fail and thus covers every remaining case.\n\nThe particular pattern `_` will match anything, but it never binds to a\nvariable, so it’s often used in the last match arm. The `_` pattern can be\nuseful when you want to ignore any value not specified, for example. We’ll\ncover the `_` pattern in more detail in the [“Ignoring Values in a\nPattern”][ignoring-values-in-a-pattern]<!-- ignore --> section later in this\nchapter.\n\n### Conditional `if let` Expressions\n\nIn Chapter 6 we discussed how to use `if let` expressions mainly as a shorter\nway to write the equivalent of a `match` that only matches one case.\nOptionally, `if let` can have a corresponding `else` containing code to run if\nthe pattern in the `if let` doesn’t match.\n\nListing 18-1 shows that it’s also possible to mix and match `if let`, `else\nif`, and `else if let` expressions. Doing so gives us more flexibility than a\n`match` expression in which we can express only one value to compare with the\npatterns. Also, Rust doesn't require that the conditions in a series of `if\nlet`, `else if`, `else if let` arms relate to each other.\n\nThe code in Listing 18-1 determines what color to make your background based on\na series of checks for several conditions. For this example, we’ve created\nvariables with hardcoded values that a real program might receive from user\ninput.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-01/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-1: Mixing `if let`, `else if`, `else if let`,\nand `else`</span>\n\nIf the user specifies a favorite color, that color is used as the background.\nIf no favorite color is specified and today is Tuesday, the background color is\ngreen. Otherwise, if the user specifies their age as a string and we can parse\nit as a number successfully, the color is either purple or orange depending on\nthe value of the number. If none of these conditions apply, the background\ncolor is blue.\n\nThis conditional structure lets us support complex requirements. With the\nhardcoded values we have here, this example will print `Using purple as the\nbackground color`.\n\nYou can see that `if let` can also introduce shadowed variables in the same way\nthat `match` arms can: the line `if let Ok(age) = age` introduces a new\nshadowed `age` variable that contains the value inside the `Ok` variant. This\nmeans we need to place the `if age > 30` condition within that block: we can’t\ncombine these two conditions into `if let Ok(age) = age && age > 30`. The\nshadowed `age` we want to compare to 30 isn’t valid until the new scope starts\nwith the curly bracket.\n\nThe downside of using `if let` expressions is that the compiler doesn’t check\nfor exhaustiveness, whereas with `match` expressions it does. If we omitted the\nlast `else` block and therefore missed handling some cases, the compiler would\nnot alert us to the possible logic bug.\n\n### `while let` Conditional Loops\n\nSimilar in construction to `if let`, the `while let` conditional loop allows a\n`while` loop to run for as long as a pattern continues to match. In Listing\n18-2 we code a `while let` loop that uses a vector as a stack and prints the\nvalues in the vector in the opposite order in which they were pushed.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-02/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-2: Using a `while let` loop to print values\nfor as long as `stack.pop()` returns `Some`</span>\n\nThis example prints 3, 2, and then 1. The `pop` method takes the last element\nout of the vector and returns `Some(value)`. If the vector is empty, `pop`\nreturns `None`. The `while` loop continues running the code in its block as\nlong as `pop` returns `Some`. When `pop` returns `None`, the loop stops. We can\nuse `while let` to pop every element off our stack.\n\n### `for` Loops\n\nIn a `for` loop, the value that directly follows the keyword `for` is a\npattern. For example, in `for x in y` the `x` is the pattern. Listing 18-3\ndemonstrates how to use a pattern in a `for` loop to destructure, or break\napart, a tuple as part of the `for` loop.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-03/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-3: Using a pattern in a `for` loop to\ndestructure a tuple</span>\n\nThe code in Listing 18-3 will print the following:\n\n```console\n{{#include ../listings/ch18-patterns-and-matching/listing-18-03/output.txt}}\n```\n\nWe adapt an iterator using the `enumerate` method so it produces a value and\nthe index for that value, placed into a tuple. The first value produced is the\ntuple `(0, 'a')`. When this value is matched to the pattern `(index, value)`,\n`index` will be `0` and `value` will be `'a'`, printing the first line of the\noutput.\n\n### `let` Statements\n\nPrior to this chapter, we had only explicitly discussed using patterns with\n`match` and `if let`, but in fact, we’ve used patterns in other places as well,\nincluding in `let` statements. For example, consider this straightforward\nvariable assignment with `let`:\n\n```rust\nlet x = 5;\n```\n\nEvery time you've used a `let` statement like this you've been using patterns,\nalthough you might not have realized it! More formally, a `let` statement looks\nlike this:\n\n```text\nlet PATTERN = EXPRESSION;\n```\n\nIn statements like `let x = 5;` with a variable name in the `PATTERN` slot, the\nvariable name is just a particularly simple form of a pattern. Rust compares\nthe expression against the pattern and assigns any names it finds. So in the\n`let x = 5;` example, `x` is a pattern that means “bind what matches here to\nthe variable `x`.” Because the name `x` is the whole pattern, this pattern\neffectively means “bind everything to the variable `x`, whatever the value is.”\n\nTo see the pattern matching aspect of `let` more clearly, consider Listing\n18-4, which uses a pattern with `let` to destructure a tuple.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-04/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-4: Using a pattern to destructure a tuple and\ncreate three variables at once</span>\n\nHere, we match a tuple against a pattern. Rust compares the value `(1, 2, 3)`\nto the pattern `(x, y, z)` and sees that the value matches the pattern, so Rust\nbinds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this tuple\npattern as nesting three individual variable patterns inside it.\n\nIf the number of elements in the pattern doesn’t match the number of elements\nin the tuple, the overall type won’t match and we’ll get a compiler error. For\nexample, Listing 18-5 shows an attempt to destructure a tuple with three\nelements into two variables, which won’t work.\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-05/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-5: Incorrectly constructing a pattern whose\nvariables don’t match the number of elements in the tuple</span>\n\nAttempting to compile this code results in this type error:\n\n```console\n{{#include ../listings/ch18-patterns-and-matching/listing-18-05/output.txt}}\n```\n\nTo fix the error, we could ignore one or more of the values in the tuple using\n`_` or `..`, as you’ll see in the [“Ignoring Values in a\nPattern”][ignoring-values-in-a-pattern]<!-- ignore --> section. If the problem\nis that we have too many variables in the pattern, the solution is to make the\ntypes match by removing variables so the number of variables equals the number\nof elements in the tuple.\n\n### Function Parameters\n\nFunction parameters can also be patterns. The code in Listing 18-6, which\ndeclares a function named `foo` that takes one parameter named `x` of type\n`i32`, should by now look familiar.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-06/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-6: A function signature uses patterns in the\nparameters</span>\n\nThe `x` part is a pattern! As we did with `let`, we could match a tuple in a\nfunction’s arguments to the pattern. Listing 18-7 splits the values in a tuple\nas we pass it to a function.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-07/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-7: A function with parameters that destructure\na tuple</span>\n\nThis code prints `Current location: (3, 5)`. The values `&(3, 5)` match the\npattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`.\n\nWe can also use patterns in closure parameter lists in the same way as in\nfunction parameter lists, because closures are similar to functions, as\ndiscussed in Chapter 13.\n\nAt this point, you’ve seen several ways of using patterns, but patterns don’t\nwork the same in every place we can use them. In some places, the patterns must\nbe irrefutable; in other circumstances, they can be refutable. We’ll discuss\nthese two concepts next.\n\n[ignoring-values-in-a-pattern]:\nch18-03-pattern-syntax.html#ignoring-values-in-a-pattern\n",
          "document_id": 5
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What differs rust from other languages?",
              "id": 14,
              "answers": [
                {
                  "answer_id": 14,
                  "document_id": 2,
                  "question_id": 14,
                  "text": "In a struct or\nenum, the data in the struct fields and the behavior in `impl` blocks are\nseparated, whereas in other languages, the data and behavior combined into one\nconcept is often labeled an object.",
                  "answer_start": 3534,
                  "answer_end": 3737,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the purpose of trait?",
              "id": 15,
              "answers": [
                {
                  "answer_id": 15,
                  "document_id": 2,
                  "question_id": 15,
                  "text": "their specific purpose is to allow abstraction across common\nbehavior.",
                  "answer_start": 4021,
                  "answer_end": 4091,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What differs generic type from trait object?",
              "id": 16,
              "answers": [
                {
                  "answer_id": 16,
                  "document_id": 2,
                  "question_id": 16,
                  "text": "A generic type parameter can only be substituted\nwith one concrete type at a time, whereas trait objects allow for multiple\nconcrete types to fill in for the trait object at runtime.",
                  "answer_start": 5583,
                  "answer_end": 5765,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What type of objects should I use in my application if  I have homogeneous collections?",
              "id": 17,
              "answers": [
                {
                  "answer_id": 17,
                  "document_id": 2,
                  "question_id": 17,
                  "text": "If you’ll only ever have homogeneous\ncollections, using generics and trait bounds is preferable because the\ndefinitions will be monomorphized at compile time to use the concrete types.",
                  "answer_start": 6299,
                  "answer_end": 6483,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is duck typing?",
              "id": 18,
              "answers": [
                {
                  "answer_id": 18,
                  "document_id": 2,
                  "question_id": 18,
                  "text": "if it walks like a duck and quacks\nlike a duck, then it must be a duck!",
                  "answer_start": 9616,
                  "answer_end": 9687,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the advantage of using trait objects and Rust’s type system to write code?",
              "id": 19,
              "answers": [
                {
                  "answer_id": 19,
                  "document_id": 2,
                  "question_id": 19,
                  "text": "we never have to check whether a\nvalue implements a particular method at runtime or worry about getting errors\nif a value doesn’t implement a method but we call it anyway. Rust won’t compile\nour code if the values don’t implement the traits that the trait objects need.",
                  "answer_start": 10232,
                  "answer_end": 10501,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is dynamic dispatch?",
              "id": 21,
              "answers": [
                {
                  "answer_id": 21,
                  "document_id": 2,
                  "question_id": 21,
                  "text": "which is when the compiler can’t tell at compile time which method\nyou’re calling.",
                  "answer_start": 11877,
                  "answer_end": 11959,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What happens in dynamic dispatch?",
              "id": 22,
              "answers": [
                {
                  "answer_id": 22,
                  "document_id": 2,
                  "question_id": 22,
                  "text": "When we use trait objects, Rust must use dynamic dispatch.",
                  "answer_start": 12066,
                  "answer_end": 12124,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does compilerdo during monomorphization process when we use trait bounds on generics?",
              "id": 20,
              "answers": [
                {
                  "answer_id": 20,
                  "document_id": 2,
                  "question_id": 20,
                  "text": "the compiler generates\nnongeneric implementations of functions and methods for each concrete type that\nwe use in place of a generic type parameter",
                  "answer_start": 11541,
                  "answer_end": 11687,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why when we use trait objects, Rust must use dynamic dispatch?",
              "id": 23,
              "answers": [
                {
                  "answer_id": 23,
                  "document_id": 2,
                  "question_id": 23,
                  "text": " The compiler doesn’t\nknow all the types that might be used with the code that’s using trait objects,\nso it doesn’t know which method implemented on which type to call. Instead, at\nruntime, Rust uses the pointers inside the trait object to know which method to\ncall. This lookup incurs a runtime cost that doesn’t occur with static\ndispatch. Dynamic dispatch also prevents the compiler from choosing to inline a\nmethod’s code, which in turn prevents some optimizations.",
                  "answer_start": 12124,
                  "answer_end": 12593,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Using Trait Objects That Allow for Values of Different Types\n\nIn Chapter 8, we mentioned that one limitation of vectors is that they can\nstore elements of only one type. We created a workaround in Listing 8-9 where\nwe defined a `SpreadsheetCell` enum that had variants to hold integers, floats,\nand text. This meant we could store different types of data in each cell and\nstill have a vector that represented a row of cells. This is a perfectly good\nsolution when our interchangeable items are a fixed set of types that we know\nwhen our code is compiled.\n\nHowever, sometimes we want our library user to be able to extend the set of\ntypes that are valid in a particular situation. To show how we might achieve\nthis, we’ll create an example graphical user interface (GUI) tool that iterates\nthrough a list of items, calling a `draw` method on each one to draw it to the\nscreen—a common technique for GUI tools. We’ll create a library crate called\n`gui` that contains the structure of a GUI library. This crate might include\nsome types for people to use, such as `Button` or `TextField`. In addition,\n`gui` users will want to create their own types that can be drawn: for\ninstance, one programmer might add an `Image` and another might add a\n`SelectBox`.\n\nWe won’t implement a fully fledged GUI library for this example but will show\nhow the pieces would fit together. At the time of writing the library, we can’t\nknow and define all the types other programmers might want to create. But we do\nknow that `gui` needs to keep track of many values of different types, and it\nneeds to call a `draw` method on each of these differently typed values. It\ndoesn’t need to know exactly what will happen when we call the `draw` method,\njust that the value will have that method available for us to call.\n\nTo do this in a language with inheritance, we might define a class named\n`Component` that has a method named `draw` on it. The other classes, such as\n`Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus\ninherit the `draw` method. They could each override the `draw` method to define\ntheir custom behavior, but the framework could treat all of the types as if\nthey were `Component` instances and call `draw` on them. But because Rust\ndoesn’t have inheritance, we need another way to structure the `gui` library to\nallow users to extend it with new types.\n\n### Defining a Trait for Common Behavior\n\nTo implement the behavior we want `gui` to have, we’ll define a trait named\n`Draw` that will have one method named `draw`. Then we can define a vector that\ntakes a *trait object*. A trait object points to both an instance of a type\nimplementing our specified trait and a table used to look up trait methods on\nthat type at runtime. We create a trait object by specifying some sort of\npointer, such as a `&` reference or a `Box<T>` smart pointer, then the `dyn`\nkeyword, and then specifying the relevant trait. (We’ll talk about the reason\ntrait objects must use a pointer in Chapter 19 in the section [“Dynamically\nSized Types and the `Sized` Trait.”][dynamically-sized]<!-- ignore -->) We can\nuse trait objects in place of a generic or concrete type. Wherever we use a\ntrait object, Rust’s type system will ensure at compile time that any value\nused in that context will implement the trait object’s trait. Consequently, we\ndon’t need to know all the possible types at compile time.\n\nWe’ve mentioned that, in Rust, we refrain from calling structs and enums\n“objects” to distinguish them from other languages’ objects. In a struct or\nenum, the data in the struct fields and the behavior in `impl` blocks are\nseparated, whereas in other languages, the data and behavior combined into one\nconcept is often labeled an object. However, trait objects *are* more like\nobjects in other languages in the sense that they combine data and behavior.\nBut trait objects differ from traditional objects in that we can’t add data to\na trait object. Trait objects aren’t as generally useful as objects in other\nlanguages: their specific purpose is to allow abstraction across common\nbehavior.\n\nListing 17-3 shows how to define a trait named `Draw` with one method named\n`draw`:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-03/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 17-3: Definition of the `Draw` trait</span>\n\nThis syntax should look familiar from our discussions on how to define traits\nin Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named\n`Screen` that holds a vector named `components`. This vector is of type\n`Box<dyn Draw>`, which is a trait object; it’s a stand-in for any type inside\na `Box` that implements the `Draw` trait.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-04/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-4: Definition of the `Screen` struct with a\n`components` field holding a vector of trait objects that implement the `Draw`\ntrait</span>\n\nOn the `Screen` struct, we’ll define a method named `run` that will call the\n`draw` method on each of its `components`, as shown in Listing 17-5:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-05/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-5: A `run` method on `Screen` that calls the\n`draw` method on each component</span>\n\nThis works differently from defining a struct that uses a generic type\nparameter with trait bounds. A generic type parameter can only be substituted\nwith one concrete type at a time, whereas trait objects allow for multiple\nconcrete types to fill in for the trait object at runtime. For example, we\ncould have defined the `Screen` struct using a generic type and a trait bound\nas in Listing 17-6:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-06/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-6: An alternate implementation of the `Screen`\nstruct and its `run` method using generics and trait bounds</span>\n\nThis restricts us to a `Screen` instance that has a list of components all of\ntype `Button` or all of type `TextField`. If you’ll only ever have homogeneous\ncollections, using generics and trait bounds is preferable because the\ndefinitions will be monomorphized at compile time to use the concrete types.\n\nOn the other hand, with the method using trait objects, one `Screen` instance\ncan hold a `Vec<T>` that contains a `Box<Button>` as well as a\n`Box<TextField>`. Let’s look at how this works, and then we’ll talk about the\nruntime performance implications.\n\n### Implementing the Trait\n\nNow we’ll add some types that implement the `Draw` trait. We’ll provide the\n`Button` type. Again, actually implementing a GUI library is beyond the scope\nof this book, so the `draw` method won’t have any useful implementation in its\nbody. To imagine what the implementation might look like, a `Button` struct\nmight have fields for `width`, `height`, and `label`, as shown in Listing 17-7:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-07/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-7: A `Button` struct that implements the\n`Draw` trait</span>\n\nThe `width`, `height`, and `label` fields on `Button` will differ from the\nfields on other components; for example, a `TextField` type might have those\nsame fields plus a `placeholder` field. Each of the types we want to draw on\nthe screen will implement the `Draw` trait but will use different code in the\n`draw` method to define how to draw that particular type, as `Button` has here\n(without the actual GUI code, as mentioned). The `Button` type, for instance,\nmight have an additional `impl` block containing methods related to what\nhappens when a user clicks the button. These kinds of methods won’t apply to\ntypes like `TextField`.\n\nIf someone using our library decides to implement a `SelectBox` struct that has\n`width`, `height`, and `options` fields, they implement the `Draw` trait on the\n`SelectBox` type as well, as shown in Listing 17-8:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch17-oop/listing-17-08/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-8: Another crate using `gui` and implementing\nthe `Draw` trait on a `SelectBox` struct</span>\n\nOur library’s user can now write their `main` function to create a `Screen`\ninstance. To the `Screen` instance, they can add a `SelectBox` and a `Button`\nby putting each in a `Box<T>` to become a trait object. They can then call the\n`run` method on the `Screen` instance, which will call `draw` on each of the\ncomponents. Listing 17-9 shows this implementation:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch17-oop/listing-17-09/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-9: Using trait objects to store values of\ndifferent types that implement the same trait</span>\n\nWhen we wrote the library, we didn’t know that someone might add the\n`SelectBox` type, but our `Screen` implementation was able to operate on the\nnew type and draw it because `SelectBox` implements the `Draw` trait, which\nmeans it implements the `draw` method.\n\nThis concept—of being concerned only with the messages a value responds to\nrather than the value’s concrete type—is similar to the concept of *duck\ntyping* in dynamically typed languages: if it walks like a duck and quacks\nlike a duck, then it must be a duck! In the implementation of `run` on `Screen`\nin Listing 17-5, `run` doesn’t need to know what the concrete type of each\ncomponent is. It doesn’t check whether a component is an instance of a `Button`\nor a `SelectBox`, it just calls the `draw` method on the component. By\nspecifying `Box<dyn Draw>` as the type of the values in the `components`\nvector, we’ve defined `Screen` to need values that we can call the `draw`\nmethod on.\n\nThe advantage of using trait objects and Rust’s type system to write code\nsimilar to code using duck typing is that we never have to check whether a\nvalue implements a particular method at runtime or worry about getting errors\nif a value doesn’t implement a method but we call it anyway. Rust won’t compile\nour code if the values don’t implement the traits that the trait objects need.\n\nFor example, Listing 17-10 shows what happens if we try to create a `Screen`\nwith a `String` as a component:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch17-oop/listing-17-10/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 17-10: Attempting to use a type that doesn’t\nimplement the trait object’s trait</span>\n\nWe’ll get this error because `String` doesn’t implement the `Draw` trait:\n\n```console\n{{#include ../listings/ch17-oop/listing-17-10/output.txt}}\n```\n\nThis error lets us know that either we’re passing something to `Screen` we\ndidn’t mean to pass and so should pass a different type or we should implement\n`Draw` on `String` so that `Screen` is able to call `draw` on it.\n\n### Trait Objects Perform Dynamic Dispatch\n\nRecall in the [“Performance of Code Using\nGenerics”][performance-of-code-using-generics]<!-- ignore --> section in\nChapter 10 our discussion on the monomorphization process performed by the\ncompiler when we use trait bounds on generics: the compiler generates\nnongeneric implementations of functions and methods for each concrete type that\nwe use in place of a generic type parameter. The code that results from\nmonomorphization is doing *static dispatch*, which is when the compiler knows\nwhat method you’re calling at compile time. This is opposed to *dynamic\ndispatch*, which is when the compiler can’t tell at compile time which method\nyou’re calling. In dynamic dispatch cases, the compiler emits code that at\nruntime will figure out which method to call.\n\nWhen we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t\nknow all the types that might be used with the code that’s using trait objects,\nso it doesn’t know which method implemented on which type to call. Instead, at\nruntime, Rust uses the pointers inside the trait object to know which method to\ncall. This lookup incurs a runtime cost that doesn’t occur with static\ndispatch. Dynamic dispatch also prevents the compiler from choosing to inline a\nmethod’s code, which in turn prevents some optimizations. However, we did get\nextra flexibility in the code that we wrote in Listing 17-5 and were able to\nsupport in Listing 17-9, so it’s a trade-off to consider.\n\n[performance-of-code-using-generics]:\nch10-01-syntax.html#performance-of-code-using-generics\n[dynamically-sized]: ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n",
          "document_id": 2
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What are irrefutable patterns?",
              "id": 36,
              "answers": [
                {
                  "answer_id": 39,
                  "document_id": 6,
                  "question_id": 36,
                  "text": "Patterns that will match\nfor any possible value passed are *irrefutable*. An example would be `x` in the\nstatement `let x = 5;` because `x` matches anything and therefore cannot fail\nto match.",
                  "answer_start": 111,
                  "answer_end": 303,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are refutable patterns?",
              "id": 37,
              "answers": [
                {
                  "answer_id": 40,
                  "document_id": 6,
                  "question_id": 37,
                  "text": "Patterns that can fail to match for some possible value are\n*refutable*. An example would be `Some(x)` in the expression `if let Some(x) =\na_value` because if the value in the `a_value` variable is `None` rather than\n`Some`, the `Some(x)` pattern will not match.",
                  "answer_start": 304,
                  "answer_end": 566,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why function parameters, `let` statements, and `for` loops can accept only irrefutable patterns?",
              "id": 38,
              "answers": [
                {
                  "answer_id": 41,
                  "document_id": 6,
                  "question_id": 38,
                  "text": "Function parameters, `let` statements, and `for` loops can only accept\nirrefutable patterns, because the program cannot do anything meaningful when\nvalues don’t match. ",
                  "answer_start": 568,
                  "answer_end": 736,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which patterns can accept the `if let` and `while let` expressions?",
              "id": 39,
              "answers": [
                {
                  "answer_id": 42,
                  "document_id": 6,
                  "question_id": 39,
                  "text": "The `if let` and `while let` expressions accept\nrefutable and irrefutable patterns, but the compiler warns against\nirrefutable patterns because by definition they’re intended to handle possible\nfailure: the functionality of a conditional is in its ability to perform\ndifferently depending on success or failure.",
                  "answer_start": 736,
                  "answer_end": 1047,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Does each arm in match arms must use refutable patterns?",
              "id": 40,
              "answers": [
                {
                  "answer_id": 43,
                  "document_id": 6,
                  "question_id": 40,
                  "text": "match arms must use refutable patterns, except for the last\narm, which should match any remaining values with an irrefutable pattern.",
                  "answer_start": 3809,
                  "answer_end": 3942,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Does Rust allow to use an irrefutable pattern in a `match` with only one arm?",
              "id": 41,
              "answers": [
                {
                  "answer_id": 44,
                  "document_id": 6,
                  "question_id": 41,
                  "text": "Rust\nallows us to use an irrefutable pattern in a `match` with only one arm, but\nthis syntax isn’t particularly useful and could be replaced with a simpler\n`let` statement.",
                  "answer_start": 3943,
                  "answer_end": 4115,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Refutability: Whether a Pattern Might Fail to Match\n\nPatterns come in two forms: refutable and irrefutable. Patterns that will match\nfor any possible value passed are *irrefutable*. An example would be `x` in the\nstatement `let x = 5;` because `x` matches anything and therefore cannot fail\nto match. Patterns that can fail to match for some possible value are\n*refutable*. An example would be `Some(x)` in the expression `if let Some(x) =\na_value` because if the value in the `a_value` variable is `None` rather than\n`Some`, the `Some(x)` pattern will not match.\n\nFunction parameters, `let` statements, and `for` loops can only accept\nirrefutable patterns, because the program cannot do anything meaningful when\nvalues don’t match. The `if let` and `while let` expressions accept\nrefutable and irrefutable patterns, but the compiler warns against\nirrefutable patterns because by definition they’re intended to handle possible\nfailure: the functionality of a conditional is in its ability to perform\ndifferently depending on success or failure.\n\nIn general, you shouldn’t have to worry about the distinction between refutable\nand irrefutable patterns; however, you do need to be familiar with the concept\nof refutability so you can respond when you see it in an error message. In\nthose cases, you’ll need to change either the pattern or the construct you’re\nusing the pattern with, depending on the intended behavior of the code.\n\nLet’s look at an example of what happens when we try to use a refutable pattern\nwhere Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a\n`let` statement, but for the pattern we’ve specified `Some(x)`, a refutable\npattern. As you might expect, this code will not compile.\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-08/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-8: Attempting to use a refutable pattern with\n`let`</span>\n\nIf `some_option_value` was a `None` value, it would fail to match the pattern\n`Some(x)`, meaning the pattern is refutable. However, the `let` statement can\nonly accept an irrefutable pattern because there is nothing valid the code can\ndo with a `None` value. At compile time, Rust will complain that we’ve tried to\nuse a refutable pattern where an irrefutable pattern is required:\n\n```console\n{{#include ../listings/ch18-patterns-and-matching/listing-18-08/output.txt}}\n```\n\nBecause we didn’t cover (and couldn’t cover!) every valid value with the\npattern `Some(x)`, Rust rightfully produces a compiler error.\n\nIf we have a refutable pattern where an irrefutable pattern is needed, we can\nfix it by changing the code that uses the pattern: instead of using `let`, we\ncan use `if let`. Then if the pattern doesn’t match, the code will just skip\nthe code in the curly brackets, giving it a way to continue validly. Listing\n18-9 shows how to fix the code in Listing 18-8.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-09/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-9: Using `if let` and a block with refutable\npatterns instead of `let`</span>\n\nWe’ve given the code an out! This code is perfectly valid, although it means we\ncannot use an irrefutable pattern without receiving an error. If we give `if\nlet` a pattern that will always match, such as `x`, as shown in Listing 18-10,\nthe compiler will give a warning.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-10/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-10: Attempting to use an irrefutable pattern\nwith `if let`</span>\n\nRust complains that it doesn’t make sense to use `if let` with an irrefutable\npattern:\n\n```console\n{{#include ../listings/ch18-patterns-and-matching/listing-18-10/output.txt}}\n```\n\nFor this reason, match arms must use refutable patterns, except for the last\narm, which should match any remaining values with an irrefutable pattern. Rust\nallows us to use an irrefutable pattern in a `match` with only one arm, but\nthis syntax isn’t particularly useful and could be replaced with a simpler\n`let` statement.\n\nNow that you know where to use patterns and the difference between refutable\nand irrefutable patterns, let’s cover all the syntax we can use to create\npatterns.\n",
          "document_id": 6
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What complications caused using named variables in `match` expressions?",
              "id": 42,
              "answers": [
                {
                  "answer_id": 45,
                  "document_id": 7,
                  "question_id": 42,
                  "text": "However, there is a complication when you use\nnamed variables in `match` expressions. Because `match` starts a new scope,\nvariables declared as part of a pattern inside the `match` expression will\nshadow those with the same name outside the `match` construct, as is the case\nwith all variables",
                  "answer_start": 685,
                  "answer_end": 978,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to match multiple patterns?",
              "id": 43,
              "answers": [
                {
                  "answer_id": 46,
                  "document_id": 7,
                  "question_id": 43,
                  "text": "you can match multiple patterns using the `|` syntax,\nwhich is the pattern *or* operator.",
                  "answer_start": 3196,
                  "answer_end": 3285,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "With what types are ranges allowed?",
              "id": 44,
              "answers": [
                {
                  "answer_id": 47,
                  "document_id": 7,
                  "question_id": 44,
                  "text": "ranges are only allowed with numeric or `char` values",
                  "answer_start": 4507,
                  "answer_end": 4560,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What other use cases have patterns?",
              "id": 45,
              "answers": [
                {
                  "answer_id": 48,
                  "document_id": 7,
                  "question_id": 45,
                  "text": "We can also use patterns to destructure structs, enums, and tuples to use\ndifferent parts of these values.",
                  "answer_start": 4869,
                  "answer_end": 4975,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "When the `match` expression stops checking arms?",
              "id": 46,
              "answers": [
                {
                  "answer_id": 49,
                  "document_id": 7,
                  "question_id": 46,
                  "text": "a `match` expression stops checking arms once it has found the\nfirst matching pattern",
                  "answer_start": 8079,
                  "answer_end": 8164,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are the ways to ignore entire values or parts of values in a pattern?",
              "id": 47,
              "answers": [
                {
                  "answer_id": 50,
                  "document_id": 7,
                  "question_id": 47,
                  "text": "There are a few\nways to ignore entire values or parts of values in a pattern: using the `_`\npattern (which you’ve seen), using the `_` pattern within another pattern,\nusing a name that starts with an underscore, or using `..` to ignore remaining\nparts of a value.",
                  "answer_start": 11789,
                  "answer_end": 12052,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is it possible to use underscores in multiple places of pattern?",
              "id": 48,
              "answers": [
                {
                  "answer_id": 51,
                  "document_id": 7,
                  "question_id": 48,
                  "text": "We can also use underscores in multiple places within one pattern to ignore\nparticular values",
                  "answer_start": 14659,
                  "answer_end": 14752,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What happens when I create a variable but don’t use it anywhere?",
              "id": 49,
              "answers": [
                {
                  "answer_id": 52,
                  "document_id": 7,
                  "question_id": 49,
                  "text": "If you create a variable but don’t use it anywhere, Rust will usually issue a\nwarning because an unused variable could be a bug. However, sometimes it’s\nuseful to be able to create a variable you won’t use yet, such as when you’re\nprototyping or just starting a project. In this situation, you can tell Rust\nnot to warn you about the unused variable by starting the name of the variable\nwith an underscore",
                  "answer_start": 15190,
                  "answer_end": 15595,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is match guard?",
              "id": 50,
              "answers": [
                {
                  "answer_id": 53,
                  "document_id": 7,
                  "question_id": 50,
                  "text": "A *match guard* is an additional `if` condition, specified after the pattern in\na `match` arm, that must also match for that arm to be chosen. Match guards are\nuseful for expressing more complex ideas than a pattern alone allows.",
                  "answer_start": 19991,
                  "answer_end": 20220,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to specify multiple patterns in match guard?",
              "id": 51,
              "answers": [
                {
                  "answer_id": 54,
                  "document_id": 7,
                  "question_id": 51,
                  "text": "You can also use the *or* operator `|` in a match guard to specify multiple\npatterns; the match guard condition will apply to all the patterns. ",
                  "answer_start": 22853,
                  "answer_end": 22997,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does at* operator do?",
              "id": 52,
              "answers": [
                {
                  "answer_id": 55,
                  "document_id": 7,
                  "question_id": 52,
                  "text": "The *at* operator `@` lets us create a variable that holds a value at the same\ntime as we’re testing that value for a pattern match.",
                  "answer_start": 24361,
                  "answer_end": 24493,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Pattern Syntax\n\nIn this section, we gather all the syntax valid in patterns and discuss why and\nwhen you might want to use each one.\n\n### Matching Literals\n\nAs you saw in Chapter 6, you can match patterns against literals directly. The\nfollowing code gives some examples:\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-01-literals/src/main.rs:here}}\n```\n\nThis code prints `one` because the value in `x` is 1. This syntax is useful\nwhen you want your code to take an action if it gets a particular concrete\nvalue.\n\n### Matching Named Variables\n\nNamed variables are irrefutable patterns that match any value, and we’ve used\nthem many times in the book. However, there is a complication when you use\nnamed variables in `match` expressions. Because `match` starts a new scope,\nvariables declared as part of a pattern inside the `match` expression will\nshadow those with the same name outside the `match` construct, as is the case\nwith all variables. In Listing 18-11, we declare a variable named `x` with the\nvalue `Some(5)` and a variable `y` with the value `10`. We then create a\n`match` expression on the value `x`. Look at the patterns in the match arms and\n`println!` at the end, and try to figure out what the code will print before\nrunning this code or reading further.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-11/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-11: A `match` expression with an arm that\nintroduces a shadowed variable `y`</span>\n\nLet’s walk through what happens when the `match` expression runs. The pattern\nin the first match arm doesn’t match the defined value of `x`, so the code\ncontinues.\n\nThe pattern in the second match arm introduces a new variable named `y` that\nwill match any value inside a `Some` value. Because we’re in a new scope inside\nthe `match` expression, this is a new `y` variable, not the `y` we declared at\nthe beginning with the value 10. This new `y` binding will match any value\ninside a `Some`, which is what we have in `x`. Therefore, this new `y` binds to\nthe inner value of the `Some` in `x`. That value is `5`, so the expression for\nthat arm executes and prints `Matched, y = 5`.\n\nIf `x` had been a `None` value instead of `Some(5)`, the patterns in the first\ntwo arms wouldn’t have matched, so the value would have matched to the\nunderscore. We didn’t introduce the `x` variable in the pattern of the\nunderscore arm, so the `x` in the expression is still the outer `x` that hasn’t\nbeen shadowed. In this hypothetical case, the `match` would print `Default\ncase, x = None`.\n\nWhen the `match` expression is done, its scope ends, and so does the scope of\nthe inner `y`. The last `println!` produces `at the end: x = Some(5), y = 10`.\n\nTo create a `match` expression that compares the values of the outer `x` and\n`y`, rather than introducing a shadowed variable, we would need to use a match\nguard conditional instead. We’ll talk about match guards later in the [“Extra\nConditionals with Match Guards”](#extra-conditionals-with-match-guards)<!--\nignore --> section.\n\n### Multiple Patterns\n\nIn `match` expressions, you can match multiple patterns using the `|` syntax,\nwhich is the pattern *or* operator. For example, in the following code we match\nthe value of `x` against the match arms, the first of which has an *or* option,\nmeaning if the value of `x` matches either of the values in that arm, that\narm’s code will run:\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-02-multiple-patterns/src/main.rs:here}}\n```\n\nThis code prints `one or two`.\n\n### Matching Ranges of Values with `..=`\n\nThe `..=` syntax allows us to match to an inclusive range of values. In the\nfollowing code, when a pattern matches any of the values within the given\nrange, that arm will execute:\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-03-ranges/src/main.rs:here}}\n```\n\nIf `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more\nconvenient for multiple match values than using the `|` operator to express the\nsame idea; if we were to use `|` we would have to specify `1 | 2 | 3 | 4 | 5`.\nSpecifying a range is much shorter, especially if we want to match, say, any\nnumber between 1 and 1,000!\n\nThe compiler checks that the range isn’t empty at compile time, and because the\nonly types for which Rust can tell if a range is empty or not are `char` and\nnumeric values, ranges are only allowed with numeric or `char` values.\n\nHere is an example using ranges of `char` values:\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-04-ranges-of-char/src/main.rs:here}}\n```\n\nRust can tell that `'c'` is within the first pattern’s range and prints `early\nASCII letter`.\n\n### Destructuring to Break Apart Values\n\nWe can also use patterns to destructure structs, enums, and tuples to use\ndifferent parts of these values. Let’s walk through each value.\n\n#### Destructuring Structs\n\nListing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we can\nbreak apart using a pattern with a `let` statement.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-12/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-12: Destructuring a struct’s fields into\nseparate variables</span>\n\nThis code creates the variables `a` and `b` that match the values of the `x`\nand `y` fields of the `p` struct. This example shows that the names of the\nvariables in the pattern don’t have to match the field names of the struct.\nHowever, it’s common to match the variable names to the field names to make it\neasier to remember which variables came from which fields. Because of this\ncommon usage, and because writing `let Point { x: x, y: y } = p;` contains a\nlot of duplication, Rust has a shorthand for patterns that match struct fields:\nyou only need to list the name of the struct field, and the variables created\nfrom the pattern will have the same names. Listing 18-13 behaves in the same\nway as the code in Listing 18-12, but the variables created in the `let`\npattern are `x` and `y` instead of `a` and `b`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-13/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-13: Destructuring struct fields using struct\nfield shorthand</span>\n\nThis code creates the variables `x` and `y` that match the `x` and `y` fields\nof the `p` variable. The outcome is that the variables `x` and `y` contain the\nvalues from the `p` struct.\n\nWe can also destructure with literal values as part of the struct pattern\nrather than creating variables for all the fields. Doing so allows us to test\nsome of the fields for particular values while creating variables to\ndestructure the other fields.\n\nIn Listing 18-14, we have a `match` expression that separates `Point` values\ninto three cases: points that lie directly on the `x` axis (which is true when\n`y = 0`), on the `y` axis (`x = 0`), or neither.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-14/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-14: Destructuring and matching literal values\nin one pattern</span>\n\nThe first arm will match any point that lies on the `x` axis by specifying that\nthe `y` field matches if its value matches the literal `0`. The pattern still\ncreates an `x` variable that we can use in the code for this arm.\n\nSimilarly, the second arm matches any point on the `y` axis by specifying that\nthe `x` field matches if its value is `0` and creates a variable `y` for the\nvalue of the `y` field. The third arm doesn’t specify any literals, so it\nmatches any other `Point` and creates variables for both the `x` and `y` fields.\n\nIn this example, the value `p` matches the second arm by virtue of `x`\ncontaining a 0, so this code will print `On the y axis at 7`.\n\nRemember that a `match` expression stops checking arms once it has found the\nfirst matching pattern, so even though `Point { x: 0, y: 0}` is on the `x` axis\nand the `y` axis, this code would only print `On the x axis at 0`.\n\n#### Destructuring Enums\n\nWe've destructured enums in this book (for example, Listing 6-5 in Chapter 6),\nbut haven’t yet explicitly discussed that the pattern to destructure an enum\ncorresponds to the way the data stored within the enum is defined. As an\nexample, in Listing 18-15 we use the `Message` enum from Listing 6-2 and write\na `match` with patterns that will destructure each inner value.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-15/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-15: Destructuring enum variants that hold\ndifferent kinds of values</span>\n\nThis code will print `Change the color to red 0, green 160, and blue 255`. Try\nchanging the value of `msg` to see the code from the other arms run.\n\nFor enum variants without any data, like `Message::Quit`, we can’t destructure\nthe value any further. We can only match on the literal `Message::Quit` value,\nand no variables are in that pattern.\n\nFor struct-like enum variants, such as `Message::Move`, we can use a pattern\nsimilar to the pattern we specify to match structs. After the variant name, we\nplace curly brackets and then list the fields with variables so we break apart\nthe pieces to use in the code for this arm. Here we use the shorthand form as\nwe did in Listing 18-13.\n\nFor tuple-like enum variants, like `Message::Write` that holds a tuple with one\nelement and `Message::ChangeColor` that holds a tuple with three elements, the\npattern is similar to the pattern we specify to match tuples. The number of\nvariables in the pattern must match the number of elements in the variant we’re\nmatching.\n\n#### Destructuring Nested Structs and Enums\n\nSo far, our examples have all been matching structs or enums one level deep,\nbut matching can work on nested items too! For example, we can refactor the\ncode in Listing 18-15 to support RGB and HSV colors in the `ChangeColor`\nmessage, as shown in Listing 18-16.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-16/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-16: Matching on nested enums</span>\n\nThe pattern of the first arm in the `match` expression matches a\n`Message::ChangeColor` enum variant that contains a `Color::Rgb` variant; then\nthe pattern binds to the three inner `i32` values. The pattern of the second\narm also matches a `Message::ChangeColor` enum variant, but the inner enum\nmatches `Color::Hsv` instead. We can specify these complex conditions in one\n`match` expression, even though two enums are involved.\n\n#### Destructuring Structs and Tuples\n\nWe can mix, match, and nest destructuring patterns in even more complex ways.\nThe following example shows a complicated destructure where we nest structs and\ntuples inside a tuple and destructure all the primitive values out:\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-05-destructuring-structs-and-tuples/src/main.rs:here}}\n```\n\nThis code lets us break complex types into their component parts so we can use\nthe values we’re interested in separately.\n\nDestructuring with patterns is a convenient way to use pieces of values, such\nas the value from each field in a struct, separately from each other.\n\n### Ignoring Values in a Pattern\n\nYou’ve seen that it’s sometimes useful to ignore values in a pattern, such as\nin the last arm of a `match`, to get a catchall that doesn’t actually do\nanything but does account for all remaining possible values. There are a few\nways to ignore entire values or parts of values in a pattern: using the `_`\npattern (which you’ve seen), using the `_` pattern within another pattern,\nusing a name that starts with an underscore, or using `..` to ignore remaining\nparts of a value. Let’s explore how and why to use each of these patterns.\n\n#### Ignoring an Entire Value with `_`\n\nWe’ve used the underscore as a wildcard pattern that will match any value but\nnot bind to the value. This is especially useful as the last arm in a `match`\nexpression, but we can also use it in any pattern, including function\nparameters, as shown in Listing 18-17.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-17/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-17: Using `_` in a function signature</span>\n\nThis code will completely ignore the value `3` passed as the first argument,\nand will print `This code only uses the y parameter: 4`.\n\nIn most cases when you no longer need a particular function parameter, you\nwould change the signature so it doesn’t include the unused parameter. Ignoring\na function parameter can be especially useful in cases when, for example,\nyou're implementing a trait when you need a certain type signature but the\nfunction body in your implementation doesn’t need one of the parameters. You\nthen avoid getting a compiler warning about unused function parameters, as you\nwould if you used a name instead.\n\n#### Ignoring Parts of a Value with a Nested `_`\n\nWe can also use `_` inside another pattern to ignore just part of a value, for\nexample, when we want to test for only part of a value but have no use for the\nother parts in the corresponding code we want to run. Listing 18-18 shows code\nresponsible for managing a setting’s value. The business requirements are that\nthe user should not be allowed to overwrite an existing customization of a\nsetting but can unset the setting and give it a value if it is currently unset.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-18/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-18: Using an underscore within patterns that\nmatch `Some` variants when we don’t need to use the value inside the\n`Some`</span>\n\nThis code will print `Can't overwrite an existing customized value` and then\n`setting is Some(5)`. In the first match arm, we don’t need to match on or use\nthe values inside either `Some` variant, but we do need to test for the case\nwhen `setting_value` and `new_setting_value` are the `Some` variant. In that\ncase, we print the reason for not changing `setting_value`, and it doesn’t get\nchanged.\n\nIn all other cases (if either `setting_value` or `new_setting_value` are\n`None`) expressed by the `_` pattern in the second arm, we want to allow\n`new_setting_value` to become `setting_value`.\n\nWe can also use underscores in multiple places within one pattern to ignore\nparticular values. Listing 18-19 shows an example of ignoring the second and\nfourth values in a tuple of five items.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-19/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-19: Ignoring multiple parts of a tuple</span>\n\nThis code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will be\nignored.\n\n#### Ignoring an Unused Variable by Starting Its Name with `_`\n\nIf you create a variable but don’t use it anywhere, Rust will usually issue a\nwarning because an unused variable could be a bug. However, sometimes it’s\nuseful to be able to create a variable you won’t use yet, such as when you’re\nprototyping or just starting a project. In this situation, you can tell Rust\nnot to warn you about the unused variable by starting the name of the variable\nwith an underscore. In Listing 18-20, we create two unused variables, but when\nwe compile this code, we should only get a warning about one of them.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-20/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-20: Starting a variable name with an\nunderscore to avoid getting unused variable warnings</span>\n\nHere we get a warning about not using the variable `y`, but we don’t get a\nwarning about not using `_x`.\n\nNote that there is a subtle difference between using only `_` and using a name\nthat starts with an underscore. The syntax `_x` still binds the value to the\nvariable, whereas `_` doesn’t bind at all. To show a case where this\ndistinction matters, Listing 18-21 will provide us with an error.\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-21/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-21: An unused variable starting with an\nunderscore still binds the value, which might take ownership of the value</span>\n\nWe’ll receive an error because the `s` value will still be moved into `_s`,\nwhich prevents us from using `s` again. However, using the underscore by itself\ndoesn’t ever bind to the value. Listing 18-22 will compile without any errors\nbecause `s` doesn’t get moved into `_`.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-22/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-22: Using an underscore does not bind the\nvalue</span>\n\nThis code works just fine because we never bind `s` to anything; it isn’t moved.\n\n#### Ignoring Remaining Parts of a Value with `..`\n\nWith values that have many parts, we can use the `..` syntax to use specific\nparts and ignore the rest, avoiding the need to list underscores for each\nignored value. The `..` pattern ignores any parts of a value that we haven’t\nexplicitly matched in the rest of the pattern. In Listing 18-23, we have a\n`Point` struct that holds a coordinate in three-dimensional space. In the\n`match` expression, we want to operate only on the `x` coordinate and ignore\nthe values in the `y` and `z` fields.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-23/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-23: Ignoring all fields of a `Point` except\nfor `x` by using `..`</span>\n\nWe list the `x` value and then just include the `..` pattern. This is quicker\nthan having to list `y: _` and `z: _`, particularly when we’re working with\nstructs that have lots of fields in situations where only one or two fields are\nrelevant.\n\nThe syntax `..` will expand to as many values as it needs to be. Listing 18-24\nshows how to use `..` with a tuple.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-24/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-24: Matching only the first and last values in\na tuple and ignoring all other values</span>\n\nIn this code, the first and last value are matched with `first` and `last`. The\n`..` will match and ignore everything in the middle.\n\nHowever, using `..` must be unambiguous. If it is unclear which values are\nintended for matching and which should be ignored, Rust will give us an error.\nListing 18-25 shows an example of using `..` ambiguously, so it will not\ncompile.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-25/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-25: An attempt to use `..` in an ambiguous\nway</span>\n\nWhen we compile this example, we get this error:\n\n```console\n{{#include ../listings/ch18-patterns-and-matching/listing-18-25/output.txt}}\n```\n\nIt’s impossible for Rust to determine how many values in the tuple to ignore\nbefore matching a value with `second` and then how many further values to\nignore thereafter. This code could mean that we want to ignore `2`, bind\n`second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to ignore\n`2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so forth.\nThe variable name `second` doesn’t mean anything special to Rust, so we get a\ncompiler error because using `..` in two places like this is ambiguous.\n\n### Extra Conditionals with Match Guards\n\nA *match guard* is an additional `if` condition, specified after the pattern in\na `match` arm, that must also match for that arm to be chosen. Match guards are\nuseful for expressing more complex ideas than a pattern alone allows.\n\nThe condition can use variables created in the pattern. Listing 18-26 shows a\n`match` where the first arm has the pattern `Some(x)` and also has a match\nguard of `if x % 2 == 0` (which will be true if the number is even).\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-26/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-26: Adding a match guard to a pattern</span>\n\nThis example will print `The number 4 is even`. When `num` is compared to the\npattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. Then\nthe match guard checks whether the remainder of dividing `x` by 2 is equal to\n0, and because it is, the first arm is selected.\n\nIf `num` had been `Some(5)` instead, the match guard in the first arm would\nhave been false because the remainder of 5 divided by 2 is 1, which is not\nequal to 0. Rust would then go to the second arm, which would match because the\nsecond arm doesn’t have a match guard and therefore matches any `Some` variant.\n\nThere is no way to express the `if x % 2 == 0` condition within a pattern, so\nthe match guard gives us the ability to express this logic. The downside of\nthis additional expressiveness is that the compiler doesn't try to check for\nexhaustiveness when match guard expressions are involved.\n\nIn Listing 18-11, we mentioned that we could use match guards to solve our\npattern-shadowing problem. Recall that we created a new variable inside the\npattern in the `match` expression instead of using the variable outside the\n`match`. That new variable meant we couldn’t test against the value of the\nouter variable. Listing 18-27 shows how we can use a match guard to fix this\nproblem.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-27/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 18-27: Using a match guard to test for equality\nwith an outer variable</span>\n\nThis code will now print `Default case, x = Some(5)`. The pattern in the second\nmatch arm doesn’t introduce a new variable `y` that would shadow the outer `y`,\nmeaning we can use the outer `y` in the match guard. Instead of specifying the\npattern as `Some(y)`, which would have shadowed the outer `y`, we specify\n`Some(n)`. This creates a new variable `n` that doesn’t shadow anything because\nthere is no `n` variable outside the `match`.\n\nThe match guard `if n == y` is not a pattern and therefore doesn’t introduce\nnew variables. This `y` *is* the outer `y` rather than a new shadowed `y`, and\nwe can look for a value that has the same value as the outer `y` by comparing\n`n` to `y`.\n\nYou can also use the *or* operator `|` in a match guard to specify multiple\npatterns; the match guard condition will apply to all the patterns. Listing\n18-28 shows the precedence when combining a pattern that uses `|` with a match\nguard. The important part of this example is that the `if y` match guard\napplies to `4`, `5`, *and* `6`, even though it might look like `if y` only\napplies to `6`.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-28/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-28: Combining multiple patterns with a match\nguard</span>\n\nThe match condition states that the arm only matches if the value of `x` is\nequal to `4`, `5`, or `6` *and* if `y` is `true`. When this code runs, the\npattern of the first arm matches because `x` is `4`, but the match guard `if y`\nis false, so the first arm is not chosen. The code moves on to the second arm,\nwhich does match, and this program prints `no`. The reason is that the `if`\ncondition applies to the whole pattern `4 | 5 | 6`, not only to the last value\n`6`. In other words, the precedence of a match guard in relation to a pattern\nbehaves like this:\n\n```text\n(4 | 5 | 6) if y => ...\n```\n\nrather than this:\n\n```text\n4 | 5 | (6 if y) => ...\n```\n\nAfter running the code, the precedence behavior is evident: if the match guard\nwere applied only to the final value in the list of values specified using the\n`|` operator, the arm would have matched and the program would have printed\n`yes`.\n\n### `@` Bindings\n\nThe *at* operator `@` lets us create a variable that holds a value at the same\ntime as we’re testing that value for a pattern match. In Listing 18-29, we want\nto test that a `Message::Hello` `id` field is within the range `3..=7`. We also\nwant to bind the value to the variable `id_variable` so we can use it in the\ncode associated with the arm. We could name this variable `id`, the same as the\nfield, but for this example we’ll use a different name.\n\n```rust\n{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-29/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 18-29: Using `@` to bind to a value in a pattern\nwhile also testing it</span>\n\nThis example will print `Found an id in range: 5`. By specifying `id_variable\n@` before the range `3..=7`, we’re capturing whatever value matched the range\nwhile also testing that the value matched the range pattern.\n\nIn the second arm, where we only have a range specified in the pattern, the code\nassociated with the arm doesn’t have a variable that contains the actual value\nof the `id` field. The `id` field’s value could have been 10, 11, or 12, but\nthe code that goes with that pattern doesn’t know which it is. The pattern code\nisn’t able to use the value from the `id` field, because we haven’t saved the\n`id` value in a variable.\n\nIn the last arm, where we’ve specified a variable without a range, we do have\nthe value available to use in the arm’s code in a variable named `id`. The\nreason is that we’ve used the struct field shorthand syntax. But we haven’t\napplied any test to the value in the `id` field in this arm, as we did with the\nfirst two arms: any value would match this pattern.\n\nUsing `@` lets us test a value and save it in a variable within one pattern.\n\n## Summary\n\nRust’s patterns are very useful in distinguishing between different kinds of\ndata. When used in `match` expressions, Rust ensures your patterns cover every\npossible value, or your program won’t compile. Patterns in `let` statements and\nfunction parameters make those constructs more useful, enabling the\ndestructuring of values into smaller parts at the same time as assigning to\nvariables. We can create simple or complex patterns to suit our needs.\n\nNext, for the penultimate chapter of the book, we’ll look at some advanced\naspects of a variety of Rust’s features.\n",
          "document_id": 7
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What are raw pointers?",
              "id": 58,
              "answers": [
                {
                  "answer_id": 61,
                  "document_id": 9,
                  "question_id": 58,
                  "text": "Unsafe Rust has two new types called *raw pointers* that are similar to\nreferences. As with references, raw pointers can be immutable or mutable and\nare written as `*const T` and `*mut T`, respectively. The asterisk isn’t the\ndereference operator; it’s part of the type name. In the context of raw\npointers, *immutable* means that the pointer can’t be directly assigned to\nafter being dereferenced.",
                  "answer_start": 3751,
                  "answer_end": 4149,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What it the history behind unsafe Rust?",
              "id": 53,
              "answers": [
                {
                  "answer_id": 56,
                  "document_id": 9,
                  "question_id": 53,
                  "text": "Unsafe Rust exists because, by nature, static analysis is conservative. When\nthe compiler tries to determine whether or not code upholds the guarantees,\nit’s better for it to reject some valid programs than to accept some invalid\nprograms. Although the code *might* be okay, if the Rust compiler doesn’t have\nenough information to be confident, it will reject the code. In these cases,\nyou can use unsafe code to tell the compiler, “Trust me, I know what I’m\ndoing.” Be warned, however, that you use unsafe Rust at your own risk: if you\nuse unsafe code incorrectly, problems can occur due to memory unsafety, such as\nnull pointer dereferencing.",
                  "answer_start": 317,
                  "answer_end": 961,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is unsafe Rust need for?",
              "id": 54,
              "answers": [
                {
                  "answer_id": 57,
                  "document_id": 9,
                  "question_id": 54,
                  "text": "Another reason Rust has an unsafe alter ego is that the underlying computer\nhardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you\ncouldn’t do certain tasks. Rust needs to allow you to do low-level systems\nprogramming, such as directly interacting with the operating system or even\nwriting your own operating system. Working with low-level systems programming\nis one of the goals of the language. Let’s explore what we can do with unsafe\nRust and how to do it.",
                  "answer_start": 963,
                  "answer_end": 1448,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to switch to unsafe Rust?",
              "id": 55,
              "answers": [
                {
                  "answer_id": 58,
                  "document_id": 9,
                  "question_id": 55,
                  "text": "To switch to unsafe Rust, use the `unsafe` keyword and then start a new block\nthat holds the unsafe code.",
                  "answer_start": 1474,
                  "answer_end": 1579,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What actions can I do within unsafe Rust?",
              "id": 56,
              "answers": [
                {
                  "answer_id": 59,
                  "document_id": 9,
                  "question_id": 56,
                  "text": "You can take five actions in unsafe Rust that you\ncan’t in safe Rust, which we call *unsafe superpowers*. Those superpowers\ninclude the ability to:\n\n* Dereference a raw pointer\n* Call an unsafe function or method\n* Access or modify a mutable static variable\n* Implement an unsafe trait\n* Access fields of `union`s",
                  "answer_start": 1580,
                  "answer_end": 1893,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Should the code in unsafe block be short?",
              "id": 57,
              "answers": [
                {
                  "answer_id": 60,
                  "document_id": 9,
                  "question_id": 57,
                  "text": "Keep\n`unsafe` blocks small; you’ll be thankful later when you investigate memory\nbugs.",
                  "answer_start": 2768,
                  "answer_end": 2854,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What differs references and smart pointers from raw pointers?",
              "id": 59,
              "answers": [
                {
                  "answer_id": 62,
                  "document_id": 9,
                  "question_id": 59,
                  "text": "Different from references and smart pointers, raw pointers:\n\n* Are allowed to ignore the borrowing rules by having both immutable and\n  mutable pointers or multiple mutable pointers to the same location\n* Aren’t guaranteed to point to valid memory\n* Are allowed to be null\n* Don’t implement any automatic cleanup",
                  "answer_start": 4151,
                  "answer_end": 4463,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What danger araises when using raw pointers?",
              "id": 60,
              "answers": [
                {
                  "answer_id": 63,
                  "document_id": 9,
                  "question_id": 60,
                  "text": "With\nraw pointers, we can create a mutable pointer and an immutable pointer to the\nsame location and change data through the mutable pointer, potentially creating\na data race.",
                  "answer_start": 7105,
                  "answer_end": 7280,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What differs unsafe functions and methods from regular functions and methods?",
              "id": 61,
              "answers": [
                {
                  "answer_id": 64,
                  "document_id": 9,
                  "question_id": 61,
                  "text": "Unsafe functions and methods look exactly like regular\nfunctions and methods, but they have an extra `unsafe` before the rest of the\ndefinition. The `unsafe` keyword in this context indicates the function has\nrequirements we need to uphold when we call this function, because Rust can’t\nguarantee we’ve met these requirements. By calling an unsafe function within an\n`unsafe` block, we’re saying that we’ve read this function’s documentation and\ntake responsibility for upholding the function’s contracts.",
                  "answer_start": 7878,
                  "answer_end": 8383,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Does Rust can interact with code written in another languages?",
              "id": 62,
              "answers": [
                {
                  "answer_id": 65,
                  "document_id": 9,
                  "question_id": 62,
                  "text": "Sometimes, your Rust code might need to interact with code written in another\nlanguage. For this, Rust has the keyword `extern` that facilitates the creation\nand use of a *Foreign Function Interface (FFI)*. An FFI is a way for a\nprogramming language to define functions and enable a different (foreign)\nprogramming language to call those functions.",
                  "answer_start": 14480,
                  "answer_end": 14828,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can I call Rust Functions from Other Languages?",
              "id": 63,
              "answers": [
                {
                  "answer_id": 66,
                  "document_id": 9,
                  "question_id": 63,
                  "text": "We can also use `extern` to create an interface that allows other languages\n> to call Rust functions. Instead of creating a whole `extern` block, we add\n> the `extern` keyword and specify the ABI to use just before the `fn` keyword\n> for the relevant function. We also need to add a `#[no_mangle]` annotation to\n> tell the Rust compiler not to mangle the name of this function.",
                  "answer_start": 15869,
                  "answer_end": 16246,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is mangling?",
              "id": 64,
              "answers": [
                {
                  "answer_id": 67,
                  "document_id": 9,
                  "question_id": 64,
                  "text": "*Mangling* is\n> when a compiler changes the name we’ve given a function to a different name\n> that contains more information for other parts of the compilation process to\n> consume but is less human readable. Every programming language compiler\n> mangles names slightly differently, so for a Rust function to be nameable by\n> other languages, we must disable the Rust compiler’s name mangling.",
                  "answer_start": 16247,
                  "answer_end": 16640,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How global variables are called in Rust?",
              "id": 65,
              "answers": [
                {
                  "answer_id": 68,
                  "document_id": 9,
                  "question_id": 65,
                  "text": "In Rust, global variables are called *static* variables.",
                  "answer_start": 17255,
                  "answer_end": 17311,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What danger hides behind using global variables?",
              "id": 66,
              "answers": [
                {
                  "answer_id": 69,
                  "document_id": 9,
                  "question_id": 66,
                  "text": "If two threads are\naccessing the same mutable global variable, it can cause a data race.",
                  "answer_start": 17165,
                  "answer_end": 17253,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How are the names of static variables written in Rust?",
              "id": 67,
              "answers": [
                {
                  "answer_id": 70,
                  "document_id": 9,
                  "question_id": 67,
                  "text": "The names of static variables are in `SCREAMING_SNAKE_CASE` by\nconvention.",
                  "answer_start": 17855,
                  "answer_end": 17929,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are the differences between between constants and immutable static variables in Rust?",
              "id": 68,
              "answers": [
                {
                  "answer_id": 71,
                  "document_id": 9,
                  "question_id": 68,
                  "text": "A subtle difference between constants and immutable static variables is that\nvalues in a static variable have a fixed address in memory. Using the value\nwill always access the same data. Constants, on the other hand, are allowed to\nduplicate their data whenever they’re used. Another difference is that static\nvariables can be mutable. Accessing and modifying mutable static variables is\n*unsafe*.",
                  "answer_start": 18159,
                  "answer_end": 18556,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Does Rust have unsafe traits?",
              "id": 69,
              "answers": [
                {
                  "answer_id": 72,
                  "document_id": 9,
                  "question_id": 69,
                  "text": "We can use `unsafe` to implement an unsafe trait. A trait is unsafe when at\nleast one of its methods has some invariant that the compiler can’t verify. We\ndeclare that a trait is `unsafe` by adding the `unsafe` keyword before `trait`\nand marking the implementation of the trait as `unsafe` too",
                  "answer_start": 19638,
                  "answer_end": 19931,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What differs union from struct?",
              "id": 70,
              "answers": [
                {
                  "answer_id": 73,
                  "document_id": 9,
                  "question_id": 70,
                  "text": " A `union` is similar to a `struct`, but only one declared field is\nused in a particular instance at one time. Unions are primarily used to\ninterface with unions in C code. Accessing union fields is unsafe because Rust\ncan’t guarantee the type of the data currently being stored in the union\ninstance.",
                  "answer_start": 21092,
                  "answer_end": 21393,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": " When to Use Unsafe Code?",
              "id": 71,
              "answers": [
                {
                  "answer_id": 74,
                  "document_id": 9,
                  "question_id": 71,
                  "text": "Using `unsafe` to take one of the five actions (superpowers) just discussed\nisn’t wrong or even frowned upon. But it is trickier to get `unsafe` code\ncorrect because the compiler can’t help uphold memory safety. When you have a\nreason to use `unsafe` code, you can do so, and having the explicit `unsafe`\nannotation makes it easier to track down the source of problems when they occur.",
                  "answer_start": 21492,
                  "answer_end": 21877,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Unsafe Rust\n\nAll the code we’ve discussed so far has had Rust’s memory safety guarantees\nenforced at compile time. However, Rust has a second language hidden inside it\nthat doesn’t enforce these memory safety guarantees: it’s called *unsafe Rust*\nand works just like regular Rust, but gives us extra superpowers.\n\nUnsafe Rust exists because, by nature, static analysis is conservative. When\nthe compiler tries to determine whether or not code upholds the guarantees,\nit’s better for it to reject some valid programs than to accept some invalid\nprograms. Although the code *might* be okay, if the Rust compiler doesn’t have\nenough information to be confident, it will reject the code. In these cases,\nyou can use unsafe code to tell the compiler, “Trust me, I know what I’m\ndoing.” Be warned, however, that you use unsafe Rust at your own risk: if you\nuse unsafe code incorrectly, problems can occur due to memory unsafety, such as\nnull pointer dereferencing.\n\nAnother reason Rust has an unsafe alter ego is that the underlying computer\nhardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you\ncouldn’t do certain tasks. Rust needs to allow you to do low-level systems\nprogramming, such as directly interacting with the operating system or even\nwriting your own operating system. Working with low-level systems programming\nis one of the goals of the language. Let’s explore what we can do with unsafe\nRust and how to do it.\n\n### Unsafe Superpowers\n\nTo switch to unsafe Rust, use the `unsafe` keyword and then start a new block\nthat holds the unsafe code. You can take five actions in unsafe Rust that you\ncan’t in safe Rust, which we call *unsafe superpowers*. Those superpowers\ninclude the ability to:\n\n* Dereference a raw pointer\n* Call an unsafe function or method\n* Access or modify a mutable static variable\n* Implement an unsafe trait\n* Access fields of `union`s\n\nIt’s important to understand that `unsafe` doesn’t turn off the borrow checker\nor disable any other of Rust’s safety checks: if you use a reference in unsafe\ncode, it will still be checked. The `unsafe` keyword only gives you access to\nthese five features that are then not checked by the compiler for memory\nsafety. You’ll still get some degree of safety inside of an unsafe block.\n\nIn addition, `unsafe` does not mean the code inside the block is necessarily\ndangerous or that it will definitely have memory safety problems: the intent is\nthat as the programmer, you’ll ensure the code inside an `unsafe` block will\naccess memory in a valid way.\n\nPeople are fallible, and mistakes will happen, but by requiring these five\nunsafe operations to be inside blocks annotated with `unsafe` you’ll know that\nany errors related to memory safety must be within an `unsafe` block. Keep\n`unsafe` blocks small; you’ll be thankful later when you investigate memory\nbugs.\n\nTo isolate unsafe code as much as possible, it’s best to enclose unsafe code\nwithin a safe abstraction and provide a safe API, which we’ll discuss later in\nthe chapter when we examine unsafe functions and methods. Parts of the standard\nlibrary are implemented as safe abstractions over unsafe code that has been\naudited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe`\nfrom leaking out into all the places that you or your users might want to use\nthe functionality implemented with `unsafe` code, because using a safe\nabstraction is safe.\n\nLet’s look at each of the five unsafe superpowers in turn. We’ll also look at\nsome abstractions that provide a safe interface to unsafe code.\n\n### Dereferencing a Raw Pointer\n\nIn Chapter 4, in the [“Dangling References”][dangling-references]<!-- ignore\n--> section, we mentioned that the compiler ensures references are always\nvalid. Unsafe Rust has two new types called *raw pointers* that are similar to\nreferences. As with references, raw pointers can be immutable or mutable and\nare written as `*const T` and `*mut T`, respectively. The asterisk isn’t the\ndereference operator; it’s part of the type name. In the context of raw\npointers, *immutable* means that the pointer can’t be directly assigned to\nafter being dereferenced.\n\nDifferent from references and smart pointers, raw pointers:\n\n* Are allowed to ignore the borrowing rules by having both immutable and\n  mutable pointers or multiple mutable pointers to the same location\n* Aren’t guaranteed to point to valid memory\n* Are allowed to be null\n* Don’t implement any automatic cleanup\n\nBy opting out of having Rust enforce these guarantees, you can give up\nguaranteed safety in exchange for greater performance or the ability to\ninterface with another language or hardware where Rust’s guarantees don’t apply.\n\nListing 19-1 shows how to create an immutable and a mutable raw pointer from\nreferences.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-01/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-1: Creating raw pointers from references</span>\n\nNotice that we don’t include the `unsafe` keyword in this code. We can create\nraw pointers in safe code; we just can’t dereference raw pointers outside an\nunsafe block, as you’ll see in a bit.\n\nWe’ve created raw pointers by using `as` to cast an immutable and a mutable\nreference into their corresponding raw pointer types. Because we created them\ndirectly from references guaranteed to be valid, we know these particular raw\npointers are valid, but we can’t make that assumption about just any raw\npointer.\n\nTo demonstrate this, next we’ll create a raw pointer whose validity we can’t be\nso certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary\nlocation in memory. Trying to use arbitrary memory is undefined: there might be\ndata at that address or there might not, the compiler might optimize the code\nso there is no memory access, or the program might error with a segmentation\nfault. Usually, there is no good reason to write code like this, but it is\npossible.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-02/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-2: Creating a raw pointer to an arbitrary\nmemory address</span>\n\nRecall that we can create raw pointers in safe code, but we can’t *dereference*\nraw pointers and read the data being pointed to. In Listing 19-3, we use the\ndereference operator `*` on a raw pointer that requires an `unsafe` block.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-03/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-3: Dereferencing raw pointers within an\n`unsafe` block</span>\n\nCreating a pointer does no harm; it’s only when we try to access the value that\nit points at that we might end up dealing with an invalid value.\n\nNote also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32`\nraw pointers that both pointed to the same memory location, where `num` is\nstored. If we instead tried to create an immutable and a mutable reference to\n`num`, the code would not have compiled because Rust’s ownership rules don’t\nallow a mutable reference at the same time as any immutable references. With\nraw pointers, we can create a mutable pointer and an immutable pointer to the\nsame location and change data through the mutable pointer, potentially creating\na data race. Be careful!\n\nWith all of these dangers, why would you ever use raw pointers? One major use\ncase is when interfacing with C code, as you’ll see in the next section,\n[“Calling an Unsafe Function or\nMethod.”](#calling-an-unsafe-function-or-method)<!-- ignore --> Another case is\nwhen building up safe abstractions that the borrow checker doesn’t understand.\nWe’ll introduce unsafe functions and then look at an example of a safe\nabstraction that uses unsafe code.\n\n### Calling an Unsafe Function or Method\n\nThe second type of operation you can perform in an unsafe block is calling\nunsafe functions. Unsafe functions and methods look exactly like regular\nfunctions and methods, but they have an extra `unsafe` before the rest of the\ndefinition. The `unsafe` keyword in this context indicates the function has\nrequirements we need to uphold when we call this function, because Rust can’t\nguarantee we’ve met these requirements. By calling an unsafe function within an\n`unsafe` block, we’re saying that we’ve read this function’s documentation and\ntake responsibility for upholding the function’s contracts.\n\nHere is an unsafe function named `dangerous` that doesn’t do anything in its\nbody:\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-01-unsafe-fn/src/main.rs:here}}\n```\n\nWe must call the `dangerous` function within a separate `unsafe` block. If we\ntry to call `dangerous` without the `unsafe` block, we’ll get an error:\n\n```console\n{{#include ../listings/ch19-advanced-features/output-only-01-missing-unsafe/output.txt}}\n```\n\nWith the `unsafe` block, we’re asserting to Rust that we’ve read the function’s\ndocumentation, we understand how to use it properly, and we’ve verified that\nwe’re fulfilling the contract of the function.\n\nBodies of unsafe functions are effectively `unsafe` blocks, so to perform other\nunsafe operations within an unsafe function, we don’t need to add another\n`unsafe` block.\n\n#### Creating a Safe Abstraction over Unsafe Code\n\nJust because a function contains unsafe code doesn’t mean we need to mark the\nentire function as unsafe. In fact, wrapping unsafe code in a safe function is\na common abstraction. As an example, let’s study the `split_at_mut` function\nfrom the standard library, which requires some unsafe code. We’ll explore how\nwe might implement it. This safe method is defined on mutable slices: it takes\none slice and makes it two by splitting the slice at the index given as an\nargument. Listing 19-4 shows how to use `split_at_mut`.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-04/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-4: Using the safe `split_at_mut`\nfunction</span>\n\nWe can’t implement this function using only safe Rust. An attempt might look\nsomething like Listing 19-5, which won’t compile. For simplicity, we’ll\nimplement `split_at_mut` as a function rather than a method and only for slices\nof `i32` values rather than for a generic type `T`.\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-05/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-5: An attempted implementation of\n`split_at_mut` using only safe Rust</span>\n\nThis function first gets the total length of the slice. Then it asserts that\nthe index given as a parameter is within the slice by checking whether it’s\nless than or equal to the length. The assertion means that if we pass an index\nthat is greater than the length to split the slice at, the function will panic\nbefore it attempts to use that index.\n\nThen we return two mutable slices in a tuple: one from the start of the\noriginal slice to the `mid` index and another from `mid` to the end of the\nslice.\n\nWhen we try to compile the code in Listing 19-5, we’ll get an error.\n\n```console\n{{#include ../listings/ch19-advanced-features/listing-19-05/output.txt}}\n```\n\nRust’s borrow checker can’t understand that we’re borrowing different parts of\nthe slice; it only knows that we’re borrowing from the same slice twice.\nBorrowing different parts of a slice is fundamentally okay because the two\nslices aren’t overlapping, but Rust isn’t smart enough to know this. When we\nknow code is okay, but Rust doesn’t, it’s time to reach for unsafe code.\n\nListing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls\nto unsafe functions to make the implementation of `split_at_mut` work.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-06/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-6: Using unsafe code in the implementation of\nthe `split_at_mut` function</span>\n\nRecall from [“The Slice Type”][the-slice-type]<!-- ignore --> section in\nChapter 4 that slices are a pointer to some data and the length of the slice.\nWe use the `len` method to get the length of a slice and the `as_mut_ptr`\nmethod to access the raw pointer of a slice. In this case, because we have a\nmutable slice to `i32` values, `as_mut_ptr` returns a raw pointer with the type\n`*mut i32`, which we’ve stored in the variable `ptr`.\n\nWe keep the assertion that the `mid` index is within the slice. Then we get to\nthe unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer\nand a length, and it creates a slice. We use this function to create a slice\nthat starts from `ptr` and is `mid` items long. Then we call the `add`\nmethod on `ptr` with `mid` as an argument to get a raw pointer that starts at\n`mid`, and we create a slice using that pointer and the remaining number of\nitems after `mid` as the length.\n\nThe function `slice::from_raw_parts_mut` is unsafe because it takes a raw\npointer and must trust that this pointer is valid. The `add` method on raw\npointers is also unsafe, because it must trust that the offset location is also\na valid pointer. Therefore, we had to put an `unsafe` block around our calls to\n`slice::from_raw_parts_mut` and `add` so we could call them. By looking at\nthe code and by adding the assertion that `mid` must be less than or equal to\n`len`, we can tell that all the raw pointers used within the `unsafe` block\nwill be valid pointers to data within the slice. This is an acceptable and\nappropriate use of `unsafe`.\n\nNote that we don’t need to mark the resulting `split_at_mut` function as\n`unsafe`, and we can call this function from safe Rust. We’ve created a safe\nabstraction to the unsafe code with an implementation of the function that uses\n`unsafe` code in a safe way, because it creates only valid pointers from the\ndata this function has access to.\n\nIn contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would\nlikely crash when the slice is used. This code takes an arbitrary memory\nlocation and creates a slice 10,000 items long.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-07/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-7: Creating a slice from an arbitrary memory\nlocation</span>\n\nWe don’t own the memory at this arbitrary location, and there is no guarantee\nthat the slice this code creates contains valid `i32` values. Attempting to use\n`values` as though it’s a valid slice results in undefined behavior.\n\n#### Using `extern` Functions to Call External Code\n\nSometimes, your Rust code might need to interact with code written in another\nlanguage. For this, Rust has the keyword `extern` that facilitates the creation\nand use of a *Foreign Function Interface (FFI)*. An FFI is a way for a\nprogramming language to define functions and enable a different (foreign)\nprogramming language to call those functions.\n\nListing 19-8 demonstrates how to set up an integration with the `abs` function\nfrom the C standard library. Functions declared within `extern` blocks are\nalways unsafe to call from Rust code. The reason is that other languages don’t\nenforce Rust’s rules and guarantees, and Rust can’t check them, so\nresponsibility falls on the programmer to ensure safety.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-08/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-8: Declaring and calling an `extern` function\ndefined in another language</span>\n\nWithin the `extern \"C\"` block, we list the names and signatures of external\nfunctions from another language we want to call. The `\"C\"` part defines which\n*application binary interface (ABI)* the external function uses: the ABI\ndefines how to call the function at the assembly level. The `\"C\"` ABI is the\nmost common and follows the C programming language’s ABI.\n\n> #### Calling Rust Functions from Other Languages\n>\n> We can also use `extern` to create an interface that allows other languages\n> to call Rust functions. Instead of creating a whole `extern` block, we add\n> the `extern` keyword and specify the ABI to use just before the `fn` keyword\n> for the relevant function. We also need to add a `#[no_mangle]` annotation to\n> tell the Rust compiler not to mangle the name of this function. *Mangling* is\n> when a compiler changes the name we’ve given a function to a different name\n> that contains more information for other parts of the compilation process to\n> consume but is less human readable. Every programming language compiler\n> mangles names slightly differently, so for a Rust function to be nameable by\n> other languages, we must disable the Rust compiler’s name mangling.\n>\n> In the following example, we make the `call_from_c` function accessible from\n> C code, after it’s compiled to a shared library and linked from C:\n>\n> ```rust\n> #[no_mangle]\n> pub extern \"C\" fn call_from_c() {\n>     println!(\"Just called a Rust function from C!\");\n> }\n> ```\n>\n> This usage of `extern` does not require `unsafe`.\n\n### Accessing or Modifying a Mutable Static Variable\n\nIn this book, we’ve not yet talked about *global variables*, which Rust does\nsupport but can be problematic with Rust’s ownership rules. If two threads are\naccessing the same mutable global variable, it can cause a data race.\n\nIn Rust, global variables are called *static* variables. Listing 19-9 shows an\nexample declaration and use of a static variable with a string slice as a\nvalue.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-09/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-9: Defining and using an immutable static\nvariable</span>\n\nStatic variables are similar to constants, which we discussed in the\n[“Differences Between Variables and\nConstants”][differences-between-variables-and-constants]<!-- ignore --> section\nin Chapter 3. The names of static variables are in `SCREAMING_SNAKE_CASE` by\nconvention. Static variables can only store references with the `'static`\nlifetime, which means the Rust compiler can figure out the lifetime and we\naren’t required to annotate it explicitly. Accessing an immutable static\nvariable is safe.\n\nA subtle difference between constants and immutable static variables is that\nvalues in a static variable have a fixed address in memory. Using the value\nwill always access the same data. Constants, on the other hand, are allowed to\nduplicate their data whenever they’re used. Another difference is that static\nvariables can be mutable. Accessing and modifying mutable static variables is\n*unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable\nstatic variable named `COUNTER`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-10/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-10: Reading from or writing to a mutable\nstatic variable is unsafe</span>\n\nAs with regular variables, we specify mutability using the `mut` keyword. Any\ncode that reads or writes from `COUNTER` must be within an `unsafe` block. This\ncode compiles and prints `COUNTER: 3` as we would expect because it’s single\nthreaded. Having multiple threads access `COUNTER` would likely result in data\nraces.\n\nWith mutable data that is globally accessible, it’s difficult to ensure there\nare no data races, which is why Rust considers mutable static variables to be\nunsafe. Where possible, it’s preferable to use the concurrency techniques and\nthread-safe smart pointers we discussed in Chapter 16 so the compiler checks\nthat data accessed from different threads is done safely.\n\n### Implementing an Unsafe Trait\n\nWe can use `unsafe` to implement an unsafe trait. A trait is unsafe when at\nleast one of its methods has some invariant that the compiler can’t verify. We\ndeclare that a trait is `unsafe` by adding the `unsafe` keyword before `trait`\nand marking the implementation of the trait as `unsafe` too, as shown in\nListing 19-11.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-11/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-11: Defining and implementing an unsafe\ntrait</span>\n\nBy using `unsafe impl`, we’re promising that we’ll uphold the invariants that\nthe compiler can’t verify.\n\nAs an example, recall the `Sync` and `Send` marker traits we discussed in the\n[“Extensible Concurrency with the `Sync` and `Send`\nTraits”][extensible-concurrency-with-the-sync-and-send-traits]<!-- ignore -->\nsection in Chapter 16: the compiler implements these traits automatically if\nour types are composed entirely of `Send` and `Sync` types. If we implement a\ntype that contains a type that is not `Send` or `Sync`, such as raw pointers,\nand we want to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust\ncan’t verify that our type upholds the guarantees that it can be safely sent\nacross threads or accessed from multiple threads; therefore, we need to do\nthose checks manually and indicate as such with `unsafe`.\n\n### Accessing Fields of a Union\n\nThe final action that works only with `unsafe` is accessing fields of a\n*union*. A `union` is similar to a `struct`, but only one declared field is\nused in a particular instance at one time. Unions are primarily used to\ninterface with unions in C code. Accessing union fields is unsafe because Rust\ncan’t guarantee the type of the data currently being stored in the union\ninstance. You can learn more about unions in [the Rust Reference][reference].\n\n### When to Use Unsafe Code\n\nUsing `unsafe` to take one of the five actions (superpowers) just discussed\nisn’t wrong or even frowned upon. But it is trickier to get `unsafe` code\ncorrect because the compiler can’t help uphold memory safety. When you have a\nreason to use `unsafe` code, you can do so, and having the explicit `unsafe`\nannotation makes it easier to track down the source of problems when they occur.\n\n[dangling-references]:\nch04-02-references-and-borrowing.html#dangling-references\n[differences-between-variables-and-constants]:\nch03-01-variables-and-mutability.html#constants\n[extensible-concurrency-with-the-sync-and-send-traits]:\nch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits\n[the-slice-type]: ch04-03-slices.html#the-slice-type\n[reference]: ../reference/items/unions.html\n",
          "document_id": 9
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What differs associated types from generics?",
              "id": 72,
              "answers": [
                {
                  "answer_id": 75,
                  "document_id": 10,
                  "question_id": 72,
                  "text": "Associated types might seem like a similar concept to generics, in that the\nlatter allow us to define a function without specifying what types it can\nhandle.",
                  "answer_start": 1907,
                  "answer_end": 2064,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What gives us a generic parameter in a trait?",
              "id": 73,
              "answers": [
                {
                  "answer_id": 76,
                  "document_id": 10,
                  "question_id": 73,
                  "text": "when a trait has a\ngeneric parameter, it can be implemented for a type multiple times, changing\nthe concrete types of the generic type parameters each time.",
                  "answer_start": 3053,
                  "answer_end": 3209,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What give me a default Generic Type Parameters?",
              "id": 74,
              "answers": [
                {
                  "answer_id": 78,
                  "document_id": 10,
                  "question_id": 74,
                  "text": "When we use generic type parameters, we can specify a default concrete type for\nthe generic type. This eliminates the need for implementors of the trait to\nspecify a concrete type if the default type works. You specify a default type\nwhen declaring a generic type with the `‹PlaceholderType=ConcreteType>` syntax.\n\nA great example of a situation where this technique is useful is with *operator\noverloading*, in which you customize the behavior of an operator (such as `+`)\nin particular situations.",
                  "answer_start": 4142,
                  "answer_end": 4641,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can I create my own operators in Rust?",
              "id": 75,
              "answers": [
                {
                  "answer_id": 79,
                  "document_id": 10,
                  "question_id": 75,
                  "text": "Rust doesn’t allow you to create your own operators or overload arbitrary\noperators. But you can overload the operations and corresponding traits listed\nin `std::ops` by implementing the traits associated with the operator.",
                  "answer_start": 4643,
                  "answer_end": 4866,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can I have two methods with the same name in Rust?",
              "id": 76,
              "answers": [
                {
                  "answer_id": 80,
                  "document_id": 10,
                  "question_id": 76,
                  "text": "Nothing in Rust prevents a trait from having a method with the same name as\nanother trait’s method, nor does Rust prevent you from implementing both traits\non one type. It’s also possible to implement a method directly on the type with\nthe same name as methods from traits.\n\nWhen calling methods with the same name, you’ll need to tell Rust which one you\nwant to use. ",
                  "answer_start": 8339,
                  "answer_end": 8707,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can I use trait inside another trait?",
              "id": 77,
              "answers": [
                {
                  "answer_id": 81,
                  "document_id": 10,
                  "question_id": 77,
                  "text": "Sometimes, you might write a trait definition that depends on another trait:\nfor a type to implement the first trait, you want to require that type to also\nimplement the second trait. You would do this so that your trait definition can\nmake use of the associated items of the second trait. The trait your trait\ndefinition is relying on is called a *supertrait* of your trait.",
                  "answer_start": 15218,
                  "answer_end": 15593,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Advanced Traits\n\nWe first covered traits in the [“Traits: Defining Shared\nBehavior”][traits-defining-shared-behavior]<!-- ignore --> section of Chapter\n10, but we didn’t discuss the more advanced details. Now that you know more\nabout Rust, we can get into the nitty-gritty.\n\n### Specifying Placeholder Types in Trait Definitions with Associated Types\n\n*Associated types* connect a type placeholder with a trait such that the trait\nmethod definitions can use these placeholder types in their signatures. The\nimplementor of a trait will specify the concrete type to be used instead of the\nplaceholder type for the particular implementation. That way, we can define a\ntrait that uses some types without needing to know exactly what those types are\nuntil the trait is implemented.\n\nWe’ve described most of the advanced features in this chapter as being rarely\nneeded. Associated types are somewhere in the middle: they’re used more rarely\nthan features explained in the rest of the book but more commonly than many of\nthe other features discussed in this chapter.\n\nOne example of a trait with an associated type is the `Iterator` trait that the\nstandard library provides. The associated type is named `Item` and stands in\nfor the type of the values the type implementing the `Iterator` trait is\niterating over. The definition of the `Iterator` trait is as shown in Listing\n19-12.\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 19-12: The definition of the `Iterator` trait\nthat has an associated type `Item`</span>\n\nThe type `Item` is a placeholder, and the `next` method’s definition shows that\nit will return values of type `Option<Self::Item>`. Implementors of the\n`Iterator` trait will specify the concrete type for `Item`, and the `next`\nmethod will return an `Option` containing a value of that concrete type.\n\nAssociated types might seem like a similar concept to generics, in that the\nlatter allow us to define a function without specifying what types it can\nhandle. To examine the difference between the two concepts, we’ll look at an\nimplementation of the `Iterator` trait on a type named `Counter` that specifies\nthe `Item` type is `u32`:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}\n```\n\nThis syntax seems comparable to that of generics. So why not just define the\n`Iterator` trait with generics, as shown in Listing 19-13?\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 19-13: A hypothetical definition of the\n`Iterator` trait using generics</span>\n\nThe difference is that when using generics, as in Listing 19-13, we must\nannotate the types in each implementation; because we can also implement\n`Iterator<String> for Counter` or any other type, we could have multiple\nimplementations of `Iterator` for `Counter`. In other words, when a trait has a\ngeneric parameter, it can be implemented for a type multiple times, changing\nthe concrete types of the generic type parameters each time. When we use the\n`next` method on `Counter`, we would have to provide type annotations to\nindicate which implementation of `Iterator` we want to use.\n\nWith associated types, we don’t need to annotate types because we can’t\nimplement a trait on a type multiple times. In Listing 19-12 with the\ndefinition that uses associated types, we can only choose what the type of\n`Item` will be once, because there can only be one `impl Iterator for Counter`.\nWe don’t have to specify that we want an iterator of `u32` values everywhere\nthat we call `next` on `Counter`.\n\nAssociated types also become part of the trait’s contract: implementors of the\ntrait must provide a type to stand in for the associated type placeholder.\nAssociated types often have a name that describes how the type will be used,\nand documenting the associated type in the API documentation is good practice.\n\n### Default Generic Type Parameters and Operator Overloading\n\nWhen we use generic type parameters, we can specify a default concrete type for\nthe generic type. This eliminates the need for implementors of the trait to\nspecify a concrete type if the default type works. You specify a default type\nwhen declaring a generic type with the `<PlaceholderType=ConcreteType>` syntax.\n\nA great example of a situation where this technique is useful is with *operator\noverloading*, in which you customize the behavior of an operator (such as `+`)\nin particular situations.\n\nRust doesn’t allow you to create your own operators or overload arbitrary\noperators. But you can overload the operations and corresponding traits listed\nin `std::ops` by implementing the traits associated with the operator. For\nexample, in Listing 19-14 we overload the `+` operator to add two `Point`\ninstances together. We do this by implementing the `Add` trait on a `Point`\nstruct:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-14: Implementing the `Add` trait to overload\nthe `+` operator for `Point` instances</span>\n\nThe `add` method adds the `x` values of two `Point` instances and the `y`\nvalues of two `Point` instances to create a new `Point`. The `Add` trait has an\nassociated type named `Output` that determines the type returned from the `add`\nmethod.\n\nThe default generic type in this code is within the `Add` trait. Here is its\ndefinition:\n\n```rust\ntrait Add<Rhs=Self> {\n    type Output;\n\n    fn add(self, rhs: Rhs) -> Self::Output;\n}\n```\n\nThis code should look generally familiar: a trait with one method and an\nassociated type. The new part is `Rhs=Self`: this syntax is called *default\ntype parameters*. The `Rhs` generic type parameter (short for “right hand\nside”) defines the type of the `rhs` parameter in the `add` method. If we don’t\nspecify a concrete type for `Rhs` when we implement the `Add` trait, the type\nof `Rhs` will default to `Self`, which will be the type we’re implementing\n`Add` on.\n\nWhen we implemented `Add` for `Point`, we used the default for `Rhs` because we\nwanted to add two `Point` instances. Let’s look at an example of implementing\nthe `Add` trait where we want to customize the `Rhs` type rather than using the\ndefault.\n\nWe have two structs, `Millimeters` and `Meters`, holding values in different\nunits. This thin wrapping of an existing type in another struct is known as the\n*newtype pattern*, which we describe in more detail in the [“Using the Newtype\nPattern to Implement External Traits on External Types”][newtype]<!-- ignore\n--> section. We want to add values in millimeters to values in meters and have\nthe implementation of `Add` do the conversion correctly. We can implement `Add`\nfor `Millimeters` with `Meters` as the `Rhs`, as shown in Listing 19-15.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 19-15: Implementing the `Add` trait on\n`Millimeters` to add `Millimeters` to `Meters`</span>\n\nTo add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the\nvalue of the `Rhs` type parameter instead of using the default of `Self`.\n\nYou’ll use default type parameters in two main ways:\n\n* To extend a type without breaking existing code\n* To allow customization in specific cases most users won’t need\n\nThe standard library’s `Add` trait is an example of the second purpose:\nusually, you’ll add two like types, but the `Add` trait provides the ability to\ncustomize beyond that. Using a default type parameter in the `Add` trait\ndefinition means you don’t have to specify the extra parameter most of the\ntime. In other words, a bit of implementation boilerplate isn’t needed, making\nit easier to use the trait.\n\nThe first purpose is similar to the second but in reverse: if you want to add a\ntype parameter to an existing trait, you can give it a default to allow\nextension of the functionality of the trait without breaking the existing\nimplementation code.\n\n### Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name\n\nNothing in Rust prevents a trait from having a method with the same name as\nanother trait’s method, nor does Rust prevent you from implementing both traits\non one type. It’s also possible to implement a method directly on the type with\nthe same name as methods from traits.\n\nWhen calling methods with the same name, you’ll need to tell Rust which one you\nwant to use. Consider the code in Listing 19-16 where we’ve defined two traits,\n`Pilot` and `Wizard`, that both have a method called `fly`. We then implement\nboth traits on a type `Human` that already has a method named `fly` implemented\non it. Each `fly` method does something different.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-16: Two traits are defined to have a `fly`\nmethod and are implemented on the `Human` type, and a `fly` method is\nimplemented on `Human` directly</span>\n\nWhen we call `fly` on an instance of `Human`, the compiler defaults to calling\nthe method that is directly implemented on the type, as shown in Listing 19-17.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-17: Calling `fly` on an instance of\n`Human`</span>\n\nRunning this code will print `*waving arms furiously*`, showing that Rust\ncalled the `fly` method implemented on `Human` directly.\n\nTo call the `fly` methods from either the `Pilot` trait or the `Wizard` trait,\nwe need to use more explicit syntax to specify which `fly` method we mean.\nListing 19-18 demonstrates this syntax.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-18: Specifying which trait’s `fly` method we\nwant to call</span>\n\nSpecifying the trait name before the method name clarifies to Rust which\nimplementation of `fly` we want to call. We could also write\n`Human::fly(&person)`, which is equivalent to the `person.fly()` that we used\nin Listing 19-18, but this is a bit longer to write if we don’t need to\ndisambiguate.\n\nRunning this code prints the following:\n\n```console\n{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}\n```\n\nBecause the `fly` method takes a `self` parameter, if we had two *types* that\nboth implement one *trait*, Rust could figure out which implementation of a\ntrait to use based on the type of `self`.\n\nHowever, associated functions that are not methods don’t have a `self`\nparameter. When there are multiple types or traits that define non-method\nfunctions with the same function name, Rust doesn't always know which type you\nmean unless you use *fully qualified syntax*. For example, in Listing 19-19 we\ncreate a trait for an animal shelter that wants to name all baby dogs *Spot*.\nWe make an `Animal` trait with an associated non-method function `baby_name`.\nThe `Animal` trait is implemented for the struct `Dog`, on which we also\nprovide an associated non-method function `baby_name` directly.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-19: A trait with an associated function and a\ntype with an associated function of the same name that also implements the\ntrait</span>\n\nWe implement the code for naming all puppies Spot in the `baby_name` associated\nfunction that is defined on `Dog`. The `Dog` type also implements the trait\n`Animal`, which describes characteristics that all animals have. Baby dogs are\ncalled puppies, and that is expressed in the implementation of the `Animal`\ntrait on `Dog` in the `baby_name` function associated with the `Animal` trait.\n\nIn `main`, we call the `Dog::baby_name` function, which calls the associated\nfunction defined on `Dog` directly. This code prints the following:\n\n```console\n{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}\n```\n\nThis output isn’t what we wanted. We want to call the `baby_name` function that\nis part of the `Animal` trait that we implemented on `Dog` so the code prints\n`A baby dog is called a puppy`. The technique of specifying the trait name that\nwe used in Listing 19-18 doesn’t help here; if we change `main` to the code in\nListing 19-20, we’ll get a compilation error.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-20: Attempting to call the `baby_name`\nfunction from the `Animal` trait, but Rust doesn’t know which implementation to\nuse</span>\n\nBecause `Animal::baby_name` doesn’t have a `self` parameter, and there could be\nother types that implement the `Animal` trait, Rust can’t figure out which\nimplementation of `Animal::baby_name` we want. We’ll get this compiler error:\n\n```console\n{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}\n```\n\nTo disambiguate and tell Rust that we want to use the implementation of\n`Animal` for `Dog` as opposed to the implementation of `Animal` for some other\ntype, we need to use fully qualified syntax. Listing 19-21 demonstrates how to\nuse fully qualified syntax.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-21: Using fully qualified syntax to specify\nthat we want to call the `baby_name` function from the `Animal` trait as\nimplemented on `Dog`</span>\n\nWe’re providing Rust with a type annotation within the angle brackets, which\nindicates we want to call the `baby_name` method from the `Animal` trait as\nimplemented on `Dog` by saying that we want to treat the `Dog` type as an\n`Animal` for this function call. This code will now print what we want:\n\n```console\n{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}\n```\n\nIn general, fully qualified syntax is defined as follows:\n\n```rust,ignore\n<Type as Trait>::function(receiver_if_method, next_arg, ...);\n```\n\nFor associated functions that aren’t methods, there would not be a `receiver`:\nthere would only be the list of other arguments. You could use fully qualified\nsyntax everywhere that you call functions or methods. However, you’re allowed\nto omit any part of this syntax that Rust can figure out from other information\nin the program. You only need to use this more verbose syntax in cases where\nthere are multiple implementations that use the same name and Rust needs help\nto identify which implementation you want to call.\n\n### Using Supertraits to Require One Trait’s Functionality Within Another Trait\n\nSometimes, you might write a trait definition that depends on another trait:\nfor a type to implement the first trait, you want to require that type to also\nimplement the second trait. You would do this so that your trait definition can\nmake use of the associated items of the second trait. The trait your trait\ndefinition is relying on is called a *supertrait* of your trait.\n\nFor example, let’s say we want to make an `OutlinePrint` trait with an\n`outline_print` method that will print a given value formatted so that it's\nframed in asterisks. That is, given a `Point` struct that implements the\nstandard library trait `Display` to result in `(x, y)`, when we call\n`outline_print` on a `Point` instance that has `1` for `x` and `3` for `y`, it\nshould print the following:\n\n```text\n**********\n*        *\n* (1, 3) *\n*        *\n**********\n```\n\nIn the implementation of the `outline_print` method, we want to use the\n`Display` trait’s functionality. Therefore, we need to specify that the\n`OutlinePrint` trait will work only for types that also implement `Display` and\nprovide the functionality that `OutlinePrint` needs. We can do that in the\ntrait definition by specifying `OutlinePrint: Display`. This technique is\nsimilar to adding a trait bound to the trait. Listing 19-22 shows an\nimplementation of the `OutlinePrint` trait.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-22: Implementing the `OutlinePrint` trait that\nrequires the functionality from `Display`</span>\n\nBecause we’ve specified that `OutlinePrint` requires the `Display` trait, we\ncan use the `to_string` function that is automatically implemented for any type\nthat implements `Display`. If we tried to use `to_string` without adding a\ncolon and specifying the `Display` trait after the trait name, we’d get an\nerror saying that no method named `to_string` was found for the type `&Self` in\nthe current scope.\n\nLet’s see what happens when we try to implement `OutlinePrint` on a type that\ndoesn’t implement `Display`, such as the `Point` struct:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}\n```\n\nWe get an error saying that `Display` is required but not implemented:\n\n```console\n{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}\n```\n\nTo fix this, we implement `Display` on `Point` and satisfy the constraint that\n`OutlinePrint` requires, like so:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}\n```\n\nThen implementing the `OutlinePrint` trait on `Point` will compile\nsuccessfully, and we can call `outline_print` on a `Point` instance to display\nit within an outline of asterisks.\n\n### Using the Newtype Pattern to Implement External Traits on External Types\n\nIn Chapter 10 in the [“Implementing a Trait on a\nType”][implementing-a-trait-on-a-type]<!-- ignore --> section, we mentioned the\norphan rule that states we’re only allowed to implement a trait on a type if\neither the trait or the type are local to our crate. It’s possible to get\naround this restriction using the *newtype pattern*, which involves creating a\nnew type in a tuple struct. (We covered tuple structs in the [“Using Tuple\nStructs without Named Fields to Create Different Types”][tuple-structs]<!--\nignore --> section of Chapter 5.) The tuple struct will have one field and be a\nthin wrapper around the type we want to implement a trait for. Then the wrapper\ntype is local to our crate, and we can implement the trait on the wrapper.\n*Newtype* is a term that originates from the Haskell programming language.\nThere is no runtime performance penalty for using this pattern, and the wrapper\ntype is elided at compile time.\n\nAs an example, let’s say we want to implement `Display` on `Vec<T>`, which the\norphan rule prevents us from doing directly because the `Display` trait and the\n`Vec<T>` type are defined outside our crate. We can make a `Wrapper` struct\nthat holds an instance of `Vec<T>`; then we can implement `Display` on\n`Wrapper` and use the `Vec<T>` value, as shown in Listing 19-23.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-23: Creating a `Wrapper` type around\n`Vec<String>` to implement `Display`</span>\n\nThe implementation of `Display` uses `self.0` to access the inner `Vec<T>`,\nbecause `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in the\ntuple. Then we can use the functionality of the `Display` type on `Wrapper`.\n\nThe downside of using this technique is that `Wrapper` is a new type, so it\ndoesn’t have the methods of the value it’s holding. We would have to implement\nall the methods of `Vec<T>` directly on `Wrapper` such that the methods\ndelegate to `self.0`, which would allow us to treat `Wrapper` exactly like a\n`Vec<T>`. If we wanted the new type to have every method the inner type has,\nimplementing the `Deref` trait (discussed in Chapter 15 in the [“Treating Smart\nPointers Like Regular References with the `Deref`\nTrait”][smart-pointer-deref]<!-- ignore --> section) on the `Wrapper` to return\nthe inner type would be a solution. If we don’t want the `Wrapper` type to have\nall the methods of the inner type—for example, to restrict the `Wrapper` type’s\nbehavior—we would have to implement just the methods we do want manually.\n\nThis newtype pattern is also useful even when traits are not involved. Let’s\nswitch focus and look at some advanced ways to interact with Rust’s type system.\n\n[newtype]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types\n[implementing-a-trait-on-a-type]:\nch10-02-traits.html#implementing-a-trait-on-a-type\n[traits-defining-shared-behavior]:\nch10-02-traits.html#traits-defining-shared-behavior\n[smart-pointer-deref]: ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait\n[tuple-structs]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types\n",
          "document_id": 10
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What other usage has newtype pattern?",
              "id": 79,
              "answers": [
                {
                  "answer_id": 83,
                  "document_id": 11,
                  "question_id": 79,
                  "text": "The newtype pattern is also useful for tasks beyond those we’ve discussed so\nfar, including statically enforcing that values are never confused and\nindicating the units of a value.",
                  "answer_start": 623,
                  "answer_end": 803,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is example usage of newtype pattern?",
              "id": 80,
              "answers": [
                {
                  "answer_id": 84,
                  "document_id": 11,
                  "question_id": 80,
                  "text": "We can also use the newtype pattern to abstract away some implementation\ndetails of a type: the new type can expose a public API that is different from\nthe API of the private inner type.",
                  "answer_start": 1151,
                  "answer_end": 1337,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Can I give to an existing type another name?",
              "id": 81,
              "answers": [
                {
                  "answer_id": 85,
                  "document_id": 11,
                  "question_id": 81,
                  "text": "Rust provides the ability to declare a *type alias* to give an existing type\nanother name. For this we use the `type` keyword.",
                  "answer_start": 2048,
                  "answer_end": 2174,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are the pros of using type aliases?",
              "id": 82,
              "answers": [
                {
                  "answer_id": 86,
                  "document_id": 11,
                  "question_id": 82,
                  "text": "The type alias helps in two ways: it makes code easier to write *and* it gives\nus a consistent interface across all of `std::io`.",
                  "answer_start": 5529,
                  "answer_end": 5658,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How the Never Type in Rust works?",
              "id": 83,
              "answers": [
                {
                  "answer_id": 87,
                  "document_id": 11,
                  "question_id": 83,
                  "text": "Rust has a special type named `!` that’s known in type theory lingo as the\n*empty type* because it has no values. We prefer to call it the *never type*\nbecause it stands in the place of the return type when a function will never\nreturn.",
                  "answer_start": 5877,
                  "answer_end": 6113,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are dynamically Sized Types?",
              "id": 84,
              "answers": [
                {
                  "answer_id": 88,
                  "document_id": 11,
                  "question_id": 84,
                  "text": "Rust needs to know certain details about its types, such as how much space to\nallocate for a value of a particular type. This leaves one corner of its type\nsystem a little confusing at first: the concept of *dynamically sized types*.\nSometimes referred to as *DSTs* or *unsized types*, these types let us write\ncode using values whose size we can know only at runtime.",
                  "answer_start": 9229,
                  "answer_end": 9597,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to work with dst in Rust?",
              "id": 85,
              "answers": [
                {
                  "answer_id": 89,
                  "document_id": 11,
                  "question_id": 85,
                  "text": "To work with DSTs, Rust provides the `Sized` trait to determine whether or not\na type’s size is known at compile time. This trait is automatically implemented\nfor everything whose size is known at compile time. In addition, Rust\nimplicitly adds a bound on `Sized` to every generic function.",
                  "answer_start": 12084,
                  "answer_end": 12374,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Advanced Types\n\nThe Rust type system has some features that we’ve so far mentioned but haven’t\nyet discussed. We’ll start by discussing newtypes in general as we examine why\nnewtypes are useful as types. Then we’ll move on to type aliases, a feature\nsimilar to newtypes but with slightly different semantics. We’ll also discuss\nthe `!` type and dynamically sized types.\n\n### Using the Newtype Pattern for Type Safety and Abstraction\n\n> Note: This section assumes you’ve read the earlier section [“Using the\n> Newtype Pattern to Implement External Traits on External\n> Types.”][using-the-newtype-pattern]<!-- ignore -->\n\nThe newtype pattern is also useful for tasks beyond those we’ve discussed so\nfar, including statically enforcing that values are never confused and\nindicating the units of a value. You saw an example of using newtypes to\nindicate units in Listing 19-15: recall that the `Millimeters` and `Meters`\nstructs wrapped `u32` values in a newtype. If we wrote a function with a\nparameter of type `Millimeters`, we couldn’t compile a program that\naccidentally tried to call that function with a value of type `Meters` or a\nplain `u32`.\n\nWe can also use the newtype pattern to abstract away some implementation\ndetails of a type: the new type can expose a public API that is different from\nthe API of the private inner type.\n\nNewtypes can also hide internal implementation. For example, we could provide a\n`People` type to wrap a `HashMap<i32, String>` that stores a person’s ID\nassociated with their name. Code using `People` would only interact with the\npublic API we provide, such as a method to add a name string to the `People`\ncollection; that code wouldn’t need to know that we assign an `i32` ID to names\ninternally. The newtype pattern is a lightweight way to achieve encapsulation\nto hide implementation details, which we discussed in the [“Encapsulation that\nHides Implementation\nDetails”][encapsulation-that-hides-implementation-details]<!-- ignore -->\nsection of Chapter 17.\n\n### Creating Type Synonyms with Type Aliases\n\nRust provides the ability to declare a *type alias* to give an existing type\nanother name. For this we use the `type` keyword. For example, we can create\nthe alias `Kilometers` to `i32` like so:\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:here}}\n```\n\nNow, the alias `Kilometers` is a *synonym* for `i32`; unlike the `Millimeters`\nand `Meters` types we created in Listing 19-15, `Kilometers` is not a separate,\nnew type. Values that have the type `Kilometers` will be treated the same as\nvalues of type `i32`:\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:there}}\n```\n\nBecause `Kilometers` and `i32` are the same type, we can add values of both\ntypes and we can pass `Kilometers` values to functions that take `i32`\nparameters. However, using this method, we don’t get the type checking benefits\nthat we get from the newtype pattern discussed earlier. In other words, if we\nmix up `Kilometers` and `i32` values somewhere, the compiler will not give us\nan error.\n\nThe main use case for type synonyms is to reduce repetition. For example, we\nmight have a lengthy type like this:\n\n```rust,ignore\nBox<dyn Fn() + Send + 'static>\n```\n\nWriting this lengthy type in function signatures and as type annotations all\nover the code can be tiresome and error prone. Imagine having a project full of\ncode like that in Listing 19-24.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-24/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-24: Using a long type in many places</span>\n\nA type alias makes this code more manageable by reducing the repetition. In\nListing 19-25, we’ve introduced an alias named `Thunk` for the verbose type and\ncan replace all uses of the type with the shorter alias `Thunk`.\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-25/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-25: Introducing a type alias `Thunk` to reduce\nrepetition</span>\n\nThis code is much easier to read and write! Choosing a meaningful name for a\ntype alias can help communicate your intent as well (*thunk* is a word for code\nto be evaluated at a later time, so it’s an appropriate name for a closure that\ngets stored).\n\nType aliases are also commonly used with the `Result<T, E>` type for reducing\nrepetition. Consider the `std::io` module in the standard library. I/O\noperations often return a `Result<T, E>` to handle situations when operations\nfail to work. This library has a `std::io::Error` struct that represents all\npossible I/O errors. Many of the functions in `std::io` will be returning\n`Result<T, E>` where the `E` is `std::io::Error`, such as these functions in\nthe `Write` trait:\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-05-write-trait/src/lib.rs}}\n```\n\nThe `Result<..., Error>` is repeated a lot. As such, `std::io` has this type\nalias declaration:\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:here}}\n```\n\nBecause this declaration is in the `std::io` module, we can use the fully\nqualified alias `std::io::Result<T>`; that is, a `Result<T, E>` with the `E`\nfilled in as `std::io::Error`. The `Write` trait function signatures end up\nlooking like this:\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:there}}\n```\n\nThe type alias helps in two ways: it makes code easier to write *and* it gives\nus a consistent interface across all of `std::io`. Because it’s an alias, it’s\njust another `Result<T, E>`, which means we can use any methods that work on\n`Result<T, E>` with it, as well as special syntax like the `?` operator.\n\n### The Never Type that Never Returns\n\nRust has a special type named `!` that’s known in type theory lingo as the\n*empty type* because it has no values. We prefer to call it the *never type*\nbecause it stands in the place of the return type when a function will never\nreturn. Here is an example:\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-07-never-type/src/lib.rs:here}}\n```\n\nThis code is read as “the function `bar` returns never.” Functions that return\nnever are called *diverging functions*. We can’t create values of the type `!`\nso `bar` can never possibly return.\n\nBut what use is a type you can never create values for? Recall the code from\nListing 2-5, part of the number guessing game; we’ve reproduced a bit of it\nhere in Listing 19-26.\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:ch19}}\n```\n\n<span class=\"caption\">Listing 19-26: A `match` with an arm that ends in\n`continue`</span>\n\nAt the time, we skipped over some details in this code. In Chapter 6 in [“The\n`match` Control Flow Operator”][the-match-control-flow-operator]<!-- ignore -->\nsection, we discussed that `match` arms must all return the same type. So, for\nexample, the following code doesn’t work:\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-08-match-arms-different-types/src/main.rs:here}}\n```\n\nThe type of `guess` in this code would have to be an integer *and* a string,\nand Rust requires that `guess` have only one type. So what does `continue`\nreturn? How were we allowed to return a `u32` from one arm and have another arm\nthat ends with `continue` in Listing 19-26?\n\nAs you might have guessed, `continue` has a `!` value. That is, when Rust\ncomputes the type of `guess`, it looks at both match arms, the former with a\nvalue of `u32` and the latter with a `!` value. Because `!` can never have a\nvalue, Rust decides that the type of `guess` is `u32`.\n\nThe formal way of describing this behavior is that expressions of type `!` can\nbe coerced into any other type. We’re allowed to end this `match` arm with\n`continue` because `continue` doesn’t return a value; instead, it moves control\nback to the top of the loop, so in the `Err` case, we never assign a value to\n`guess`.\n\nThe never type is useful with the `panic!` macro as well. Recall the `unwrap`\nfunction that we call on `Option<T>` values to produce a value or panic with\nthis definition:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-09-unwrap-definition/src/lib.rs:here}}\n```\n\nIn this code, the same thing happens as in the `match` in Listing 19-26: Rust\nsees that `val` has the type `T` and `panic!` has the type `!`, so the result\nof the overall `match` expression is `T`. This code works because `panic!`\ndoesn’t produce a value; it ends the program. In the `None` case, we won’t be\nreturning a value from `unwrap`, so this code is valid.\n\nOne final expression that has the type `!` is a `loop`:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-10-loop-returns-never/src/main.rs:here}}\n```\n\nHere, the loop never ends, so `!` is the value of the expression. However, this\nwouldn’t be true if we included a `break`, because the loop would terminate\nwhen it got to the `break`.\n\n### Dynamically Sized Types and the `Sized` Trait\n\nRust needs to know certain details about its types, such as how much space to\nallocate for a value of a particular type. This leaves one corner of its type\nsystem a little confusing at first: the concept of *dynamically sized types*.\nSometimes referred to as *DSTs* or *unsized types*, these types let us write\ncode using values whose size we can know only at runtime.\n\nLet’s dig into the details of a dynamically sized type called `str`, which\nwe’ve been using throughout the book. That’s right, not `&str`, but `str` on\nits own, is a DST. We can’t know how long the string is until runtime, meaning\nwe can’t create a variable of type `str`, nor can we take an argument of type\n`str`. Consider the following code, which does not work:\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-11-cant-create-str/src/main.rs:here}}\n```\n\nRust needs to know how much memory to allocate for any value of a particular\ntype, and all values of a type must use the same amount of memory. If Rust\nallowed us to write this code, these two `str` values would need to take up the\nsame amount of space. But they have different lengths: `s1` needs 12 bytes of\nstorage and `s2` needs 15. This is why it’s not possible to create a variable\nholding a dynamically sized type.\n\nSo what do we do? In this case, you already know the answer: we make the types\nof `s1` and `s2` a `&str` rather than a `str`. Recall from the [“String\nSlices”][string-slices]<!-- ignore --> section of Chapter 4 that the slice data\nstructure just stores the starting position and the length of the slice. So\nalthough a `&T` is a single value that stores the memory address of where the\n`T` is located, a `&str` is *two* values: the address of the `str` and its\nlength. As such, we can know the size of a `&str` value at compile time: it’s\ntwice the length of a `usize`. That is, we always know the size of a `&str`, no\nmatter how long the string it refers to is. In general, this is the way in\nwhich dynamically sized types are used in Rust: they have an extra bit of\nmetadata that stores the size of the dynamic information. The golden rule of\ndynamically sized types is that we must always put values of dynamically sized\ntypes behind a pointer of some kind.\n\nWe can combine `str` with all kinds of pointers: for example, `Box<str>` or\n`Rc<str>`. In fact, you’ve seen this before but with a different dynamically\nsized type: traits. Every trait is a dynamically sized type we can refer to by\nusing the name of the trait. In Chapter 17 in the [“Using Trait Objects That\nAllow for Values of Different\nTypes”][using-trait-objects-that-allow-for-values-of-different-types]<!--\nignore --> section, we mentioned that to use traits as trait objects, we must\nput them behind a pointer, such as `&dyn Trait` or `Box<dyn Trait>` (`Rc<dyn\nTrait>` would work too).\n\nTo work with DSTs, Rust provides the `Sized` trait to determine whether or not\na type’s size is known at compile time. This trait is automatically implemented\nfor everything whose size is known at compile time. In addition, Rust\nimplicitly adds a bound on `Sized` to every generic function. That is, a\ngeneric function definition like this:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-12-generic-fn-definition/src/lib.rs}}\n```\n\nis actually treated as though we had written this:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-13-generic-implicit-sized-bound/src/lib.rs}}\n```\n\nBy default, generic functions will work only on types that have a known size at\ncompile time. However, you can use the following special syntax to relax this\nrestriction:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-14-generic-maybe-sized/src/lib.rs}}\n```\n\nA trait bound on `?Sized` means “`T` may or may not be `Sized`” and this\nnotation overrides the default that generic types must have a known size at\ncompile time. The `?Trait` syntax with this meaning is only available for\n`Sized`, not any other traits.\n\nAlso note that we switched the type of the `t` parameter from `T` to `&T`.\nBecause the type might not be `Sized`, we need to use it behind some kind of\npointer. In this case, we’ve chosen a reference.\n\nNext, we’ll talk about functions and closures!\n\n[encapsulation-that-hides-implementation-details]:\nch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details\n[string-slices]: ch04-03-slices.html#string-slices\n[the-match-control-flow-operator]:\nch06-02-match.html#the-match-control-flow-operator\n[using-trait-objects-that-allow-for-values-of-different-types]:\nch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[using-the-newtype-pattern]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types\n",
          "document_id": 11
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "How to return a closure?",
              "id": 86,
              "answers": [
                {
                  "answer_id": 90,
                  "document_id": 12,
                  "question_id": 86,
                  "text": "Closures are represented by traits, which means you can’t return closures\ndirectly. In most cases where you might want to return a trait, you can instead\nuse the concrete type that implements the trait as the return value of the\nfunction. However, you can’t do that with closures because they don’t have a\nconcrete type that is returnable; you’re not allowed to use the function\npointer `fn` as a return type, for example.",
                  "answer_start": 4339,
                  "answer_end": 4761,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Advanced Functions and Closures\n\nThis section explores some advanced features related to functions and closures,\nincluding function pointers and returning closures.\n\n### Function Pointers\n\nWe’ve talked about how to pass closures to functions; you can also pass regular\nfunctions to functions! This technique is useful when you want to pass a\nfunction you’ve already defined rather than defining a new closure. Functions\ncoerce to the type `fn` (with a lowercase f), not to be confused with the `Fn`\nclosure trait. The `fn` type is called a *function pointer*. Passing functions\nwith function pointers will allow you to use functions as arguments to other\nfunctions.\n\nThe syntax for specifying that a parameter is a function pointer is similar to\nthat of closures, as shown in Listing 19-27, where we’ve defined a function\n`add_one` that adds one to its parameter. The function `do_twice` takes two\nparameters: a function pointer to any function that takes an `i32` parameter\nand returns an `i32`, and one `i32` value. The `do_twice` function calls the\nfunction `f` twice, passing it the `arg` value, then adds the two function call\nresults together. The `main` function calls `do_twice` with the arguments\n`add_one` and `5`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-27/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-27: Using the `fn` type to accept a function\npointer as an argument</span>\n\nThis code prints `The answer is: 12`. We specify that the parameter `f` in\n`do_twice` is an `fn` that takes one parameter of type `i32` and returns an\n`i32`. We can then call `f` in the body of `do_twice`. In `main`, we can pass\nthe function name `add_one` as the first argument to `do_twice`.\n\nUnlike closures, `fn` is a type rather than a trait, so we specify `fn` as the\nparameter type directly rather than declaring a generic type parameter with one\nof the `Fn` traits as a trait bound.\n\nFunction pointers implement all three of the closure traits (`Fn`, `FnMut`, and\n`FnOnce`), meaning you can always pass a function pointer as an argument for a\nfunction that expects a closure. It’s best to write functions using a generic\ntype and one of the closure traits so your functions can accept either\nfunctions or closures.\n\nThat said, one example of where you would want to only accept `fn` and not\nclosures is when interfacing with external code that doesn’t have closures: C\nfunctions can accept functions as arguments, but C doesn’t have closures.\n\nAs an example of where you could use either a closure defined inline or a named\nfunction, let’s look at a use of the `map` method provided by the `Iterator`\ntrait in the standard library. To use the `map` function to turn a vector of\nnumbers into a vector of strings, we could use a closure, like this:\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-15-map-closure/src/main.rs:here}}\n```\n\nOr we could name a function as the argument to `map` instead of the closure,\nlike this:\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-16-map-function/src/main.rs:here}}\n```\n\nNote that we must use the fully qualified syntax that we talked about earlier\nin the [“Advanced Traits”][advanced-traits]<!-- ignore --> section because\nthere are multiple functions available named `to_string`. Here, we’re using the\n`to_string` function defined in the `ToString` trait, which the standard\nlibrary has implemented for any type that implements `Display`.\n\nRecall from the [“Enum values”][enum-values]<!-- ignore --> section of Chapter\n6 that the name of each enum variant that we define also becomes an initializer\nfunction. We can use these initializer functions as function pointers that\nimplement the closure traits, which means we can specify the initializer\nfunctions as arguments for methods that take closures, like so:\n\n```rust\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-17-map-initializer/src/main.rs:here}}\n```\n\nHere we create `Status::Value` instances using each `u32` value in the range\nthat `map` is called on by using the initializer function of `Status::Value`.\nSome people prefer this style, and some people prefer to use closures. They\ncompile to the same code, so use whichever style is clearer to you.\n\n### Returning Closures\n\nClosures are represented by traits, which means you can’t return closures\ndirectly. In most cases where you might want to return a trait, you can instead\nuse the concrete type that implements the trait as the return value of the\nfunction. However, you can’t do that with closures because they don’t have a\nconcrete type that is returnable; you’re not allowed to use the function\npointer `fn` as a return type, for example.\n\nThe following code tries to return a closure directly, but it won’t compile:\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-18-returns-closure/src/lib.rs}}\n```\n\nThe compiler error is as follows:\n\n```console\n{{#include ../listings/ch19-advanced-features/no-listing-18-returns-closure/output.txt}}\n```\n\nThe error references the `Sized` trait again! Rust doesn’t know how much space\nit will need to store the closure. We saw a solution to this problem earlier.\nWe can use a trait object:\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-19-returns-closure-trait-object/src/lib.rs}}\n```\n\nThis code will compile just fine. For more about trait objects, refer to the\nsection [“Using Trait Objects That Allow for Values of Different\nTypes”][using-trait-objects-that-allow-for-values-of-different-types]<!--\nignore --> in Chapter 17.\n\nNext, let’s look at macros!\n\n[advanced-traits]:\nch19-03-advanced-traits.html#advanced-traits\n[enum-values]: ch06-01-defining-an-enum.html#enum-values\n[using-trait-objects-that-allow-for-values-of-different-types]:\nch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n",
          "document_id": 12
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What does term macro refers to?",
              "id": 87,
              "answers": [
                {
                  "answer_id": 91,
                  "document_id": 13,
                  "question_id": 87,
                  "text": "The term *macro* refers to a family\nof features in Rust: *declarative* macros with `macro_rules!` and three kinds\nof *procedural* macros:",
                  "answer_start": 131,
                  "answer_end": 268,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are the types of procedural macros?",
              "id": 88,
              "answers": [
                {
                  "answer_id": 92,
                  "document_id": 13,
                  "question_id": 88,
                  "text": "* Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums\n* Attribute-like macros that define custom attributes usable on any item\n* Function-like macros that look like function calls but operate on the tokens\n  specified as their argument",
                  "answer_start": 270,
                  "answer_end": 559,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are the Differences Between Macros and Functions?",
              "id": 89,
              "answers": [
                {
                  "answer_id": 93,
                  "document_id": 13,
                  "question_id": 89,
                  "text": "Fundamentally, macros are a way of writing code that writes other code, which\nis known as *metaprogramming*. In Appendix C, we discuss the `derive`\nattribute, which generates an implementation of various traits for you. We’ve\nalso used the `println!` and `vec!` macros throughout the book. All of these\nmacros *expand* to produce more code than the code you’ve written manually.\n\nMetaprogramming is useful for reducing the amount of code you have to write and\nmaintain, which is also one of the roles of functions. However, macros have\nsome additional powers that functions don’t.\n\nA function signature must declare the number and type of parameters the\nfunction has. Macros, on the other hand, can take a variable number of\nparameters: we can call `println!(\"hello\")` with one argument or\n`println!(\"hello {}\", name)` with two arguments. Also, macros are expanded\nbefore the compiler interprets the meaning of the code, so a macro can, for\nexample, implement a trait on a given type. A function can’t, because it gets\ncalled at runtime and a trait needs to be implemented at compile time.\n",
                  "answer_start": 732,
                  "answer_end": 1822,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is the downside to implementing a macro instead of a function?",
              "id": 90,
              "answers": [
                {
                  "answer_id": 94,
                  "document_id": 13,
                  "question_id": 90,
                  "text": "The downside to implementing a macro instead of a function is that macro\ndefinitions are more complex than function definitions because you’re writing\nRust code that writes Rust code. Due to this indirection, macro definitions are\ngenerally more difficult to read, understand, and maintain than function\ndefinitions.\n",
                  "answer_start": 1823,
                  "answer_end": 2140,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What differs macros and functions?",
              "id": 91,
              "answers": [
                {
                  "answer_id": 95,
                  "document_id": 13,
                  "question_id": 91,
                  "text": "Another important difference between macros and functions is that you must\ndefine macros or bring them into scope *before* you call them in a file, as\nopposed to functions you can define anywhere and call anywhere.",
                  "answer_start": 2141,
                  "answer_end": 2355,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What are Declarative Macros?",
              "id": 92,
              "answers": [
                {
                  "answer_id": 97,
                  "document_id": 13,
                  "question_id": 92,
                  "text": "The most widely used form of macros in Rust is the *declarative macro*. These\nare also sometimes referred to as “macros by example,” “`macro_rules!` macros,”\nor just plain “macros.” At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression. As discussed in Chapter 6,\n`match` expressions are control structures that take an expression, compare the\nresulting value of the expression to patterns, and then run the code associated\nwith the matching pattern. Macros also compare a value to patterns that are\nassociated with particular code: in this situation, the value is the literal\nRust source code passed to the macro; the patterns are compared with the\nstructure of that source code; and the code associated with each pattern, when\nmatched, replaces the code passed to the macro. This all happens during\ncompilation.",
                  "answer_start": 2429,
                  "answer_end": 3288,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to define a macro?",
              "id": 93,
              "answers": [
                {
                  "answer_id": 98,
                  "document_id": 13,
                  "question_id": 93,
                  "text": "To define a macro, you use the `macro_rules!` construct.",
                  "answer_start": 3290,
                  "answer_end": 3346,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does the macro '#[macro_export]' do?",
              "id": 94,
              "answers": [
                {
                  "answer_id": 99,
                  "document_id": 13,
                  "question_id": 94,
                  "text": "The `#[macro_export]` annotation indicates that this macro should be made\navailable whenever the crate in which the macro is defined is brought into\nscope. Without this annotation, the macro can’t be brought into scope.",
                  "answer_start": 4443,
                  "answer_end": 4662,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does dollar sign (`$`) mean in macro definition? ",
              "id": 95,
              "answers": [
                {
                  "answer_id": 100,
                  "document_id": 13,
                  "question_id": 95,
                  "text": "We use a\ndollar sign (`$`) to declare a variable in the macro system that will contain\nthe Rust code matching the pattern. The dollar sign makes it clear this is a\nmacro variable as opposed to a regular Rust variable.",
                  "answer_start": 5747,
                  "answer_end": 5964,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is procedural macro?",
              "id": 96,
              "answers": [
                {
                  "answer_id": 101,
                  "document_id": 13,
                  "question_id": 96,
                  "text": "The second form of macros is the *procedural macro*, which acts more like a\nfunction (and is a type of procedure). Procedural macros accept some code as an\ninput, operate on that code, and produce some code as an output rather than\nmatching against patterns and replacing the code with other code as declarative\nmacros do. The three kinds of procedural macros are custom derive,\nattribute-like, and function-like, and all work in a similar fashion.",
                  "answer_start": 7522,
                  "answer_end": 7970,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What will print the default HelloMacro implementation?",
              "id": 97,
              "answers": [
                {
                  "answer_id": 102,
                  "document_id": 13,
                  "question_id": 97,
                  "text": "The default implementation will print `Hello, Macro! My name is\nTypeName!` where `TypeName` is the name of the type on which this trait has\nbeen defined.",
                  "answer_start": 9738,
                  "answer_end": 9891,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does the `stringify!` macro?",
              "id": 98,
              "answers": [
                {
                  "answer_id": 103,
                  "document_id": 13,
                  "question_id": 98,
                  "text": "It takes a Rust\nexpression, such as `1 + 2`, and at compile time turns the expression into a\nstring literal, such as `\"1 + 2\"`. This is different than `format!` or\n`println!`, macros which evaluate the expression and then turn the result into\na `String`.",
                  "answer_start": 19465,
                  "answer_end": 19719,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What differs attribute-like macros from custom derive macros?",
              "id": 99,
              "answers": [
                {
                  "answer_id": 104,
                  "document_id": 13,
                  "question_id": 99,
                  "text": "Attribute-like macros are similar to custom derive macros, but instead of\ngenerating code for the `derive` attribute, they allow you to create new\nattributes. They’re also more flexible: `derive` only works for structs and\nenums; attributes can be applied to other items as well, such as functions.",
                  "answer_start": 21101,
                  "answer_end": 21399,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How function-like macros work?",
              "id": 100,
              "answers": [
                {
                  "answer_id": 106,
                  "document_id": 13,
                  "question_id": 100,
                  "text": "Function-like macros define macros that look like function calls. Similarly to\n`macro_rules!` macros, they’re more flexible than functions; for example, they\ncan take an unknown number of arguments. However, `macro_rules!` macros can be\ndefined only using the match-like syntax we discussed in the section\n[“Declarative Macros with `macro_rules!` for General\nMetaprogramming”][decl]‹!-- ignore --> earlier. Function-like macros take a\n`TokenStream` parameter and their definition manipulates that `TokenStream`\nusing Rust code as the other two types of procedural macros do.",
                  "answer_start": 22349,
                  "answer_end": 22923,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Macros\n\nWe’ve used macros like `println!` throughout this book, but we haven’t fully\nexplored what a macro is and how it works. The term *macro* refers to a family\nof features in Rust: *declarative* macros with `macro_rules!` and three kinds\nof *procedural* macros:\n\n* Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums\n* Attribute-like macros that define custom attributes usable on any item\n* Function-like macros that look like function calls but operate on the tokens\n  specified as their argument\n\nWe’ll talk about each of these in turn, but first, let’s look at why we even\nneed macros when we already have functions.\n\n### The Difference Between Macros and Functions\n\nFundamentally, macros are a way of writing code that writes other code, which\nis known as *metaprogramming*. In Appendix C, we discuss the `derive`\nattribute, which generates an implementation of various traits for you. We’ve\nalso used the `println!` and `vec!` macros throughout the book. All of these\nmacros *expand* to produce more code than the code you’ve written manually.\n\nMetaprogramming is useful for reducing the amount of code you have to write and\nmaintain, which is also one of the roles of functions. However, macros have\nsome additional powers that functions don’t.\n\nA function signature must declare the number and type of parameters the\nfunction has. Macros, on the other hand, can take a variable number of\nparameters: we can call `println!(\"hello\")` with one argument or\n`println!(\"hello {}\", name)` with two arguments. Also, macros are expanded\nbefore the compiler interprets the meaning of the code, so a macro can, for\nexample, implement a trait on a given type. A function can’t, because it gets\ncalled at runtime and a trait needs to be implemented at compile time.\n\nThe downside to implementing a macro instead of a function is that macro\ndefinitions are more complex than function definitions because you’re writing\nRust code that writes Rust code. Due to this indirection, macro definitions are\ngenerally more difficult to read, understand, and maintain than function\ndefinitions.\n\nAnother important difference between macros and functions is that you must\ndefine macros or bring them into scope *before* you call them in a file, as\nopposed to functions you can define anywhere and call anywhere.\n\n### Declarative Macros with `macro_rules!` for General Metaprogramming\n\nThe most widely used form of macros in Rust is the *declarative macro*. These\nare also sometimes referred to as “macros by example,” “`macro_rules!` macros,”\nor just plain “macros.” At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression. As discussed in Chapter 6,\n`match` expressions are control structures that take an expression, compare the\nresulting value of the expression to patterns, and then run the code associated\nwith the matching pattern. Macros also compare a value to patterns that are\nassociated with particular code: in this situation, the value is the literal\nRust source code passed to the macro; the patterns are compared with the\nstructure of that source code; and the code associated with each pattern, when\nmatched, replaces the code passed to the macro. This all happens during\ncompilation.\n\nTo define a macro, you use the `macro_rules!` construct. Let’s explore how to\nuse `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8\ncovered how we can use the `vec!` macro to create a new vector with particular\nvalues. For example, the following macro creates a new vector containing three\nintegers:\n\n```rust\nlet v: Vec<u32> = vec![1, 2, 3];\n```\n\nWe could also use the `vec!` macro to make a vector of two integers or a vector\nof five string slices. We wouldn’t be able to use a function to do the same\nbecause we wouldn’t know the number or type of values up front.\n\nListing 19-28 shows a slightly simplified definition of the `vec!` macro.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-28/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 19-28: A simplified version of the `vec!` macro\ndefinition</span>\n\n> Note: The actual definition of the `vec!` macro in the standard library\n> includes code to preallocate the correct amount of memory up front. That code\n> is an optimization that we don’t include here to make the example simpler.\n\nThe `#[macro_export]` annotation indicates that this macro should be made\navailable whenever the crate in which the macro is defined is brought into\nscope. Without this annotation, the macro can’t be brought into scope.\n\nWe then start the macro definition with `macro_rules!` and the name of the\nmacro we’re defining *without* the exclamation mark. The name, in this case\n`vec`, is followed by curly brackets denoting the body of the macro definition.\n\nThe structure in the `vec!` body is similar to the structure of a `match`\nexpression. Here we have one arm with the pattern `( $( $x:expr ),* )`,\nfollowed by `=>` and the block of code associated with this pattern. If the\npattern matches, the associated block of code will be emitted. Given that this\nis the only pattern in this macro, there is only one valid way to match; any\nother pattern will result in an error. More complex macros will have more than\none arm.\n\nValid pattern syntax in macro definitions is different than the pattern syntax\ncovered in Chapter 18 because macro patterns are matched against Rust code\nstructure rather than values. Let’s walk through what the pattern pieces in\nListing 19-28 mean; for the full macro pattern syntax, see the [Rust\nReference][ref].\n\nFirst, we use a set of parentheses to encompass the whole pattern. We use a\ndollar sign (`$`) to declare a variable in the macro system that will contain\nthe Rust code matching the pattern. The dollar sign makes it clear this is a\nmacro variable as opposed to a regular Rust variable. Next comes a set of\nparentheses that captures values that match the pattern within the parentheses\nfor use in the replacement code. Within `$()` is `$x:expr`, which matches any\nRust expression and gives the expression the name `$x`.\n\nThe comma following `$()` indicates that a literal comma separator character\ncould optionally appear after the code that matches the code in `$()`. The `*`\nspecifies that the pattern matches zero or more of whatever precedes the `*`.\n\nWhen we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three\ntimes with the three expressions `1`, `2`, and `3`.\n\nNow let’s look at the pattern in the body of the code associated with this arm:\n`temp_vec.push()` within `$()*` is generated for each part that matches `$()`\nin the pattern zero or more times depending on how many times the pattern\nmatches. The `$x` is replaced with each expression matched. When we call this\nmacro with `vec![1, 2, 3];`, the code generated that replaces this macro call\nwill be the following:\n\n```rust,ignore\n{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n```\n\nWe’ve defined a macro that can take any number of arguments of any type and can\ngenerate code to create a vector containing the specified elements.\n\nTo learn more about how to write macros, consult the online documentation or\nother resources, such as [“The Little Book of Rust Macros”][tlborm] started by\nDaniel Keep and continued by Lukas Wirth.\n\n### Procedural Macros for Generating Code from Attributes\n\nThe second form of macros is the *procedural macro*, which acts more like a\nfunction (and is a type of procedure). Procedural macros accept some code as an\ninput, operate on that code, and produce some code as an output rather than\nmatching against patterns and replacing the code with other code as declarative\nmacros do. The three kinds of procedural macros are custom derive,\nattribute-like, and function-like, and all work in a similar fashion.\n\nWhen creating procedural macros, the definitions must reside in their own crate\nwith a special crate type. This is for complex technical reasons that we hope\nto eliminate in the future. In Listing 19-29, we show how to define a\nprocedural macro, where `some_attribute` is a placeholder for using a specific\nmacro variety.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -> TokenStream {\n}\n```\n\n<span class=\"caption\">Listing 19-29: An example of defining a procedural\nmacro</span>\n\nThe function that defines a procedural macro takes a `TokenStream` as an input\nand produces a `TokenStream` as an output. The `TokenStream` type is defined by\nthe `proc_macro` crate that is included with Rust and represents a sequence of\ntokens. This is the core of the macro: the source code that the macro is\noperating on makes up the input `TokenStream`, and the code the macro produces\nis the output `TokenStream`. The function also has an attribute attached to it\nthat specifies which kind of procedural macro we’re creating. We can have\nmultiple kinds of procedural macros in the same crate.\n\nLet’s look at the different kinds of procedural macros. We’ll start with a\ncustom derive macro and then explain the small dissimilarities that make the\nother forms different.\n\n### How to Write a Custom `derive` Macro\n\nLet’s create a crate named `hello_macro` that defines a trait named\n`HelloMacro` with one associated function named `hello_macro`. Rather than\nmaking our users implement the `HelloMacro` trait for each of their types,\nwe’ll provide a procedural macro so users can annotate their type with\n`#[derive(HelloMacro)]` to get a default implementation of the `hello_macro`\nfunction. The default implementation will print `Hello, Macro! My name is\nTypeName!` where `TypeName` is the name of the type on which this trait has\nbeen defined. In other words, we’ll write a crate that enables another\nprogrammer to write code like Listing 19-30 using our crate.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-30/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 19-30: The code a user of our crate will be able\nto write when using our procedural macro</span>\n\nThis code will print `Hello, Macro! My name is Pancakes!` when we’re done. The\nfirst step is to make a new library crate, like this:\n\n```console\n$ cargo new hello_macro --lib\n```\n\nNext, we’ll define the `HelloMacro` trait and its associated function:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/hello_macro/src/lib.rs}}\n```\n\nWe have a trait and its function. At this point, our crate user could implement\nthe trait to achieve the desired functionality, like so:\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/pancakes/src/main.rs}}\n```\n\nHowever, they would need to write the implementation block for each type they\nwanted to use with `hello_macro`; we want to spare them from having to do this\nwork.\n\nAdditionally, we can’t yet provide the `hello_macro` function with default\nimplementation that will print the name of the type the trait is implemented\non: Rust doesn’t have reflection capabilities, so it can’t look up the type’s\nname at runtime. We need a macro to generate code at compile time.\n\nThe next step is to define the procedural macro. At the time of this writing,\nprocedural macros need to be in their own crate. Eventually, this restriction\nmight be lifted. The convention for structuring crates and macro crates is as\nfollows: for a crate named `foo`, a custom derive procedural macro crate is\ncalled `foo_derive`. Let’s start a new crate called `hello_macro_derive` inside\nour `hello_macro` project:\n\n```console\n$ cargo new hello_macro_derive --lib\n```\n\nOur two crates are tightly related, so we create the procedural macro crate\nwithin the directory of our `hello_macro` crate. If we change the trait\ndefinition in `hello_macro`, we’ll have to change the implementation of the\nprocedural macro in `hello_macro_derive` as well. The two crates will need to\nbe published separately, and programmers using these crates will need to add\nboth as dependencies and bring them both into scope. We could instead have the\n`hello_macro` crate use `hello_macro_derive` as a dependency and re-export the\nprocedural macro code. However, the way we’ve structured the project makes it\npossible for programmers to use `hello_macro` even if they don’t want the\n`derive` functionality.\n\nWe need to declare the `hello_macro_derive` crate as a procedural macro crate.\nWe’ll also need functionality from the `syn` and `quote` crates, as you’ll see\nin a moment, so we need to add them as dependencies. Add the following to the\n*Cargo.toml* file for `hello_macro_derive`:\n\n<span class=\"filename\">Filename: hello_macro_derive/Cargo.toml</span>\n\n```toml\n{{#include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/Cargo.toml:6:12}}\n```\n\nTo start defining the procedural macro, place the code in Listing 19-31 into\nyour *src/lib.rs* file for the `hello_macro_derive` crate. Note that this code\nwon’t compile until we add a definition for the `impl_hello_macro` function.\n\n<span class=\"filename\">Filename: hello_macro_derive/src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 19-31: Code that most procedural macro crates\nwill require in order to process Rust code</span>\n\nNotice that we’ve split the code into the `hello_macro_derive` function, which\nis responsible for parsing the `TokenStream`, and the `impl_hello_macro`\nfunction, which is responsible for transforming the syntax tree: this makes\nwriting a procedural macro more convenient. The code in the outer function\n(`hello_macro_derive` in this case) will be the same for almost every\nprocedural macro crate you see or create. The code you specify in the body of\nthe inner function (`impl_hello_macro` in this case) will be different\ndepending on your procedural macro’s purpose.\n\nWe’ve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. The\n`proc_macro` crate comes with Rust, so we didn’t need to add that to the\ndependencies in *Cargo.toml*. The `proc_macro` crate is the compiler’s API that\nallows us to read and manipulate Rust code from our code.\n\nThe `syn` crate parses Rust code from a string into a data structure that we\ncan perform operations on. The `quote` crate turns `syn` data structures back\ninto Rust code. These crates make it much simpler to parse any sort of Rust\ncode we might want to handle: writing a full parser for Rust code is no simple\ntask.\n\nThe `hello_macro_derive` function will be called when a user of our library\nspecifies `#[derive(HelloMacro)]` on a type. This is possible because we’ve\nannotated the `hello_macro_derive` function here with `proc_macro_derive` and\nspecified the name `HelloMacro`, which matches our trait name; this is the\nconvention most procedural macros follow.\n\nThe `hello_macro_derive` function first converts the `input` from a\n`TokenStream` to a data structure that we can then interpret and perform\noperations on. This is where `syn` comes into play. The `parse` function in\n`syn` takes a `TokenStream` and returns a `DeriveInput` struct representing the\nparsed Rust code. Listing 19-32 shows the relevant parts of the `DeriveInput`\nstruct we get from parsing the `struct Pancakes;` string:\n\n```rust,ignore\nDeriveInput {\n    // --snip--\n\n    ident: Ident {\n        ident: \"Pancakes\",\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n```\n\n<span class=\"caption\">Listing 19-32: The `DeriveInput` instance we get when\nparsing the code that has the macro’s attribute in Listing 19-30</span>\n\nThe fields of this struct show that the Rust code we’ve parsed is a unit struct\nwith the `ident` (identifier, meaning the name) of `Pancakes`. There are more\nfields on this struct for describing all sorts of Rust code; check the [`syn`\ndocumentation for `DeriveInput`][syn-docs] for more information.\n\nSoon we’ll define the `impl_hello_macro` function, which is where we’ll build\nthe new Rust code we want to include. But before we do, note that the output\nfor our derive macro is also a `TokenStream`. The returned `TokenStream` is\nadded to the code that our crate users write, so when they compile their crate,\nthey’ll get the extra functionality that we provide in the modified\n`TokenStream`.\n\nYou might have noticed that we’re calling `unwrap` to cause the\n`hello_macro_derive` function to panic if the call to the `syn::parse` function\nfails here. It’s necessary for our procedural macro to panic on errors because\n`proc_macro_derive` functions must return `TokenStream` rather than `Result` to\nconform to the procedural macro API. We’ve simplified this example by using\n`unwrap`; in production code, you should provide more specific error messages\nabout what went wrong by using `panic!` or `expect`.\n\nNow that we have the code to turn the annotated Rust code from a `TokenStream`\ninto a `DeriveInput` instance, let’s generate the code that implements the\n`HelloMacro` trait on the annotated type, as shown in Listing 19-33.\n\n<span class=\"filename\">Filename: hello_macro_derive/src/lib.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-33/hello_macro/hello_macro_derive/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 19-33: Implementing the `HelloMacro` trait using\nthe parsed Rust code</span>\n\nWe get an `Ident` struct instance containing the name (identifier) of the\nannotated type using `ast.ident`. The struct in Listing 19-32 shows that when\nwe run the `impl_hello_macro` function on the code in Listing 19-30, the\n`ident` we get will have the `ident` field with a value of `\"Pancakes\"`. Thus,\nthe `name` variable in Listing 19-33 will contain an `Ident` struct instance\nthat, when printed, will be the string `\"Pancakes\"`, the name of the struct in\nListing 19-30.\n\nThe `quote!` macro lets us define the Rust code that we want to return. The\ncompiler expects something different to the direct result of the `quote!`\nmacro’s execution, so we need to convert it to a `TokenStream`. We do this by\ncalling the `into` method, which consumes this intermediate representation and\nreturns a value of the required `TokenStream` type.\n\nThe `quote!` macro also provides some very cool templating mechanics: we can\nenter `#name`, and `quote!` will replace it with the value in the variable\n`name`. You can even do some repetition similar to the way regular macros work.\nCheck out [the `quote` crate’s docs][quote-docs] for a thorough introduction.\n\nWe want our procedural macro to generate an implementation of our `HelloMacro`\ntrait for the type the user annotated, which we can get by using `#name`. The\ntrait implementation has the one function `hello_macro`, whose body contains the\nfunctionality we want to provide: printing `Hello, Macro! My name is` and then\nthe name of the annotated type.\n\nThe `stringify!` macro used here is built into Rust. It takes a Rust\nexpression, such as `1 + 2`, and at compile time turns the expression into a\nstring literal, such as `\"1 + 2\"`. This is different than `format!` or\n`println!`, macros which evaluate the expression and then turn the result into\na `String`. There is a possibility that the `#name` input might be an\nexpression to print literally, so we use `stringify!`. Using `stringify!` also\nsaves an allocation by converting `#name` to a string literal at compile time.\n\nAt this point, `cargo build` should complete successfully in both `hello_macro`\nand `hello_macro_derive`. Let’s hook up these crates to the code in Listing\n19-30 to see the procedural macro in action! Create a new binary project in\nyour *projects* directory using `cargo new pancakes`. We need to add\n`hello_macro` and `hello_macro_derive` as dependencies in the `pancakes`\ncrate’s *Cargo.toml*. If you’re publishing your versions of `hello_macro` and\n`hello_macro_derive` to [crates.io](https://crates.io/), they would be regular\ndependencies; if not, you can specify them as `path` dependencies as follows:\n\n```toml\n{{#include ../listings/ch19-advanced-features/no-listing-21-pancakes/pancakes/Cargo.toml:7:9}}\n```\n\nPut the code in Listing 19-30 into *src/main.rs*, and run `cargo run`: it\nshould print `Hello, Macro! My name is Pancakes!` The implementation of the\n`HelloMacro` trait from the procedural macro was included without the\n`pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the\ntrait implementation.\n\nNext, let’s explore how the other kinds of procedural macros differ from custom\nderive macros.\n\n### Attribute-like macros\n\nAttribute-like macros are similar to custom derive macros, but instead of\ngenerating code for the `derive` attribute, they allow you to create new\nattributes. They’re also more flexible: `derive` only works for structs and\nenums; attributes can be applied to other items as well, such as functions.\nHere’s an example of using an attribute-like macro: say you have an attribute\nnamed `route` that annotates functions when using a web application framework:\n\n```rust,ignore\n#[route(GET, \"/\")]\nfn index() {\n```\n\nThis `#[route]` attribute would be defined by the framework as a procedural\nmacro. The signature of the macro definition function would look like this:\n\n```rust,ignore\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n```\n\nHere, we have two parameters of type `TokenStream`. The first is for the\ncontents of the attribute: the `GET, \"/\"` part. The second is the body of the\nitem the attribute is attached to: in this case, `fn index() {}` and the rest\nof the function’s body.\n\nOther than that, attribute-like macros work the same way as custom derive\nmacros: you create a crate with the `proc-macro` crate type and implement a\nfunction that generates the code you want!\n\n### Function-like macros\n\nFunction-like macros define macros that look like function calls. Similarly to\n`macro_rules!` macros, they’re more flexible than functions; for example, they\ncan take an unknown number of arguments. However, `macro_rules!` macros can be\ndefined only using the match-like syntax we discussed in the section\n[“Declarative Macros with `macro_rules!` for General\nMetaprogramming”][decl]<!-- ignore --> earlier. Function-like macros take a\n`TokenStream` parameter and their definition manipulates that `TokenStream`\nusing Rust code as the other two types of procedural macros do. An example of a\nfunction-like macro is an `sql!` macro that might be called like so:\n\n```rust,ignore\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n```\n\nThis macro would parse the SQL statement inside it and check that it’s\nsyntactically correct, which is much more complex processing than a\n`macro_rules!` macro can do. The `sql!` macro would be defined like this:\n\n```rust,ignore\n#[proc_macro]\npub fn sql(input: TokenStream) -> TokenStream {\n```\n\nThis definition is similar to the custom derive macro’s signature: we receive\nthe tokens that are inside the parentheses and return the code we wanted to\ngenerate.\n\n## Summary\n\nWhew! Now you have some Rust features in your toolbox that you likely won’t use\noften, but you’ll know they’re available in very particular circumstances.\nWe’ve introduced several complex topics so that when you encounter them in\nerror message suggestions or in other peoples’ code, you’ll be able to\nrecognize these concepts and syntax. Use this chapter as a reference to guide\nyou to solutions.\n\nNext, we’ll put everything we’ve discussed throughout the book into practice\nand do one more project!\n\n[ref]: ../reference/macros-by-example.html\n[tlborm]: https://veykril.github.io/tlborm/\n[`syn`]: https://crates.io/crates/syn\n[`quote`]: https://crates.io/crates/quote\n[syn-docs]: https://docs.rs/syn/1.0/syn/struct.DeriveInput.html\n[quote-docs]: https://docs.rs/quote\n[decl]: #declarative-macros-with-macro_rules-for-general-metaprogramming\n",
          "document_id": 13
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What are the two main protocols involved in web servers?",
              "id": 101,
              "answers": [
                {
                  "answer_id": 107,
                  "document_id": 15,
                  "question_id": 101,
                  "text": "The two main protocols involved in web servers are *Hypertext Transfer\nProtocol* *(HTTP)* and *Transmission Control Protocol* *(TCP)*. Both protocols\nare *request-response* protocols, meaning a *client* initiates requests and a\n*server* listens to the requests and provides a response to the client. The\ncontents of those requests and responses are defined by the protocols.",
                  "answer_start": 330,
                  "answer_end": 704,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is TCP protocol?",
              "id": 102,
              "answers": [
                {
                  "answer_id": 108,
                  "document_id": 15,
                  "question_id": 102,
                  "text": "TCP is the lower-level protocol that describes the details of how information\ngets from one server to another but doesn’t specify what that information is.",
                  "answer_start": 706,
                  "answer_end": 861,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is HTTP protocol?",
              "id": 103,
              "answers": [
                {
                  "answer_id": 109,
                  "document_id": 15,
                  "question_id": 103,
                  "text": "HTTP builds on top of TCP by defining the contents of the requests and\nresponses. It’s technically possible to use HTTP with other protocols, but in\nthe vast majority of cases, HTTP sends its data over TCP. ",
                  "answer_start": 862,
                  "answer_end": 1069,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How does function 'bind' works?",
              "id": 104,
              "answers": [
                {
                  "answer_id": 110,
                  "document_id": 15,
                  "question_id": 104,
                  "text": "The `bind` function in this scenario works like the `new` function in that it\nwill return a new `TcpListener` instance. The function is called `bind`\nbecause, in networking, connecting to a port to listen to is known as “binding\nto a port.”\n\nThe `bind` function returns a `Result‹T, E>`, which indicates that it’s\npossible for binding to fail.",
                  "answer_start": 2500,
                  "answer_end": 2843,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to start Rust application from terminal?",
              "id": 105,
              "answers": [
                {
                  "answer_id": 111,
                  "document_id": 15,
                  "question_id": 105,
                  "text": "Invoke `cargo run` in the terminal",
                  "answer_start": 4867,
                  "answer_end": 4901,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to stop running Rust application from terminal?",
              "id": 106,
              "answers": [
                {
                  "answer_id": 112,
                  "document_id": 15,
                  "question_id": 106,
                  "text": "stop the program by pressing ‹span class=\"keystroke\">ctrl-c‹/span>",
                  "answer_start": 6038,
                  "answer_end": 6104,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What format must have an http request?",
              "id": 107,
              "answers": [
                {
                  "answer_id": 113,
                  "document_id": 15,
                  "question_id": 107,
                  "text": "HTTP is a text-based protocol, and a request takes this format:\n\n```text\nMethod Request-URI HTTP-Version CRLF\nheaders CRLF\nmessage-body\n```",
                  "answer_start": 10175,
                  "answer_end": 10314,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to interprete each line of http request?",
              "id": 108,
              "answers": [
                {
                  "answer_id": 114,
                  "document_id": 15,
                  "question_id": 108,
                  "text": "The first line is the *request line* that holds information about what the\nclient is requesting. The first part of the request line indicates the *method*\nbeing used, such as `GET` or `POST`, which describes how the client is making\nthis request. Our client used a `GET` request, which means it is asking for\ninformation.\n\nThe next part of the request line is */*, which indicates the *Uniform Resource\nIdentifier* *(URI)* the client is requesting: a URI is almost, but not quite,\nthe same as a *Uniform Resource Locator* *(URL)*. The difference between URIs\nand URLs isn’t important for our purposes in this chapter, but the HTTP spec\nuses the term URI, so we can just mentally substitute URL for URI here.\n\nThe last part is the HTTP version the client uses, and then the request line\nends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line feed*,\nwhich are terms from the typewriter days!) The CRLF sequence can also be\nwritten as `\\r\\n`, where `\\r` is a carriage return and `\\n` is a line feed. The\nCRLF sequence separates the request line from the rest of the request data.\nNote that when the CRLF is printed, we see a new line start rather than `\\r\\n`.",
                  "answer_start": 10316,
                  "answer_end": 11489,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What format must have http responses?",
              "id": 109,
              "answers": [
                {
                  "answer_id": 115,
                  "document_id": 15,
                  "question_id": 109,
                  "text": "Responses have the following format:\n\n```text\nHTTP-Version Status-Code Reason-Phrase CRLF\nheaders CRLF\nmessage-body\n```",
                  "answer_start": 12096,
                  "answer_end": 12215,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does status code 200 means?",
              "id": 110,
              "answers": [
                {
                  "answer_id": 116,
                  "document_id": 15,
                  "question_id": 110,
                  "text": "The status code 200 is the standard success response. ",
                  "answer_start": 12703,
                  "answer_end": 12757,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does status code 404 means?",
              "id": 111,
              "answers": [
                {
                  "answer_id": 117,
                  "document_id": 15,
                  "question_id": 111,
                  "text": "a response\nwith the status code 404, which signals that the content for the request was\nnot found.",
                  "answer_start": 18069,
                  "answer_end": 18167,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Building a Single-Threaded Web Server\n\nWe’ll start by getting a single-threaded web server working. Before we begin,\nlet’s look at a quick overview of the protocols involved in building web\nservers. The details of these protocols are beyond the scope of this book, but\na brief overview will give you the information you need.\n\nThe two main protocols involved in web servers are *Hypertext Transfer\nProtocol* *(HTTP)* and *Transmission Control Protocol* *(TCP)*. Both protocols\nare *request-response* protocols, meaning a *client* initiates requests and a\n*server* listens to the requests and provides a response to the client. The\ncontents of those requests and responses are defined by the protocols.\n\nTCP is the lower-level protocol that describes the details of how information\ngets from one server to another but doesn’t specify what that information is.\nHTTP builds on top of TCP by defining the contents of the requests and\nresponses. It’s technically possible to use HTTP with other protocols, but in\nthe vast majority of cases, HTTP sends its data over TCP. We’ll work with the\nraw bytes of TCP and HTTP requests and responses.\n\n### Listening to the TCP Connection\n\nOur web server needs to listen to a TCP connection, so that’s the first part\nwe’ll work on. The standard library offers a `std::net` module that lets us do\nthis. Let’s make a new project in the usual fashion:\n\n```console\n$ cargo new hello\n     Created binary (application) `hello` project\n$ cd hello\n```\n\nNow enter the code in Listing 20-1 in *src/main.rs* to start. This code will\nlisten at the local address `127.0.0.1:7878` for incoming TCP streams. When it\ngets an incoming stream, it will print `Connection established!`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-01/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 20-1: Listening for incoming streams and printing\na message when we receive a stream</span>\n\nUsing `TcpListener`, we can listen for TCP connections at the address\n`127.0.0.1:7878`. In the address, the section before the colon is an IP address\nrepresenting your computer (this is the same on every computer and doesn’t\nrepresent the authors’ computer specifically), and `7878` is the port. We’ve\nchosen this port for two reasons: HTTP isn’t normally accepted on this port so\nour server is unlikely to conflict with any other web server you might have\nrunning on your machine, and 7878 is *rust* typed on a telephone.\n\nThe `bind` function in this scenario works like the `new` function in that it\nwill return a new `TcpListener` instance. The function is called `bind`\nbecause, in networking, connecting to a port to listen to is known as “binding\nto a port.”\n\nThe `bind` function returns a `Result<T, E>`, which indicates that it’s\npossible for binding to fail. For example, connecting to port 80 requires\nadministrator privileges (nonadministrators can listen only on ports higher\nthan 1023), so if we tried to connect to port 80 without being an\nadministrator, binding wouldn’t work. Binding also wouldn’t work, for example,\nif we ran two instances of our program and so had two programs listening to the\nsame port. Because we’re writing a basic server just for learning purposes, we\nwon’t worry about handling these kinds of errors; instead, we use `unwrap` to\nstop the program if errors happen.\n\nThe `incoming` method on `TcpListener` returns an iterator that gives us a\nsequence of streams (more specifically, streams of type `TcpStream`). A single\n*stream* represents an open connection between the client and the server. A\n*connection* is the name for the full request and response process in which a\nclient connects to the server, the server generates a response, and the server\ncloses the connection. As such, we will read from the `TcpStream` to see what\nthe client sent and then write our response to the stream to send data back to\nthe client. Overall, this `for` loop will process each connection in turn and\nproduce a series of streams for us to handle.\n\nFor now, our handling of the stream consists of calling `unwrap` to terminate\nour program if the stream has any errors; if there aren’t any errors, the\nprogram prints a message. We’ll add more functionality for the success case in\nthe next listing. The reason we might receive errors from the `incoming` method\nwhen a client connects to the server is that we’re not actually iterating over\nconnections. Instead, we’re iterating over *connection attempts*. The\nconnection might not be successful for a number of reasons, many of them\noperating system specific. For example, many operating systems have a limit to\nthe number of simultaneous open connections they can support; new connection\nattempts beyond that number will produce an error until some of the open\nconnections are closed.\n\nLet’s try running this code! Invoke `cargo run` in the terminal and then load\n*127.0.0.1:7878* in a web browser. The browser should show an error message\nlike “Connection reset,” because the server isn’t currently sending back any\ndata. But when you look at your terminal, you should see several messages that\nwere printed when the browser connected to the server!\n\n```text\n     Running `target/debug/hello`\nConnection established!\nConnection established!\nConnection established!\n```\n\nSometimes, you’ll see multiple messages printed for one browser request; the\nreason might be that the browser is making a request for the page as well as a\nrequest for other resources, like the *favicon.ico* icon that appears in the\nbrowser tab.\n\nIt could also be that the browser is trying to connect to the server multiple\ntimes because the server isn’t responding with any data. When `stream` goes out\nof scope and is dropped at the end of the loop, the connection is closed as\npart of the `drop` implementation. Browsers sometimes deal with closed\nconnections by retrying, because the problem might be temporary. The important\nfactor is that we’ve successfully gotten a handle to a TCP connection!\n\nRemember to stop the program by pressing <span class=\"keystroke\">ctrl-c</span>\nwhen you’re done running a particular version of the code. Then restart the\nprogram by invoking the `cargo run` command after you’ve made each set of code\nchanges to make sure you’re running the newest code.\n\n### Reading the Request\n\nLet’s implement the functionality to read the request from the browser! To\nseparate the concerns of first getting a connection and then taking some action\nwith the connection, we’ll start a new function for processing connections. In\nthis new `handle_connection` function, we’ll read data from the TCP stream and\nprint it so we can see the data being sent from the browser. Change the code to\nlook like Listing 20-2.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-02/src/main.rs}}\n```\n\n<span class=\"caption\">Listing 20-2: Reading from the `TcpStream` and printing\nthe data</span>\n\nWe bring `std::io::prelude` and `std::io::BufReader` into scope to get access\nto traits and types that let us read from and write to the stream. In the `for`\nloop in the `main` function, instead of printing a message that says we made a\nconnection, we now call the new `handle_connection` function and pass the\n`stream` to it.\n\nIn the `handle_connection` function, we create a new `BufReader` instance that\nwraps a mutable reference to the `stream`. `BufReader` adds buffering by\nmanaging calls to the `std::io::Read` trait methods for us.\n\nWe create a variable named `http_request` to collect the lines of the request\nthe browser sends to our server. We indicate that we want to collect these\nlines in a vector by adding the `Vec<_>` type annotation.\n\n`BufReader` implements the `std::io::BufRead` trait, which provides the `lines`\nmethod. The `lines` method returns an iterator of `Result<String,\nstd::io::Error>` by splitting the stream of data whenever it sees a newline\nbyte. To get each `String`, we map and `unwrap` each `Result`. The `Result`\nmight be an error if the data isn’t valid UTF-8 or if there was a problem\nreading from the stream. Again, a production program should handle these errors\nmore gracefully, but we’re choosing to stop the program in the error case for\nsimplicity.\n\nThe browser signals the end of an HTTP request by sending two newline\ncharacters in a row, so to get one request from the stream, we take lines until\nwe get a line that is the empty string. Once we’ve collected the lines into the\nvector, we’re printing them out using pretty debug formatting so we can take a\nlook at the instructions the web browser is sending to our server.\n\nLet’s try this code! Start the program and make a request in a web browser\nagain. Note that we’ll still get an error page in the browser, but our\nprogram’s output in the terminal will now look similar to this:\n\n```console\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running `target/debug/hello`\nRequest: [\n    \"GET / HTTP/1.1\",\n    \"Host: 127.0.0.1:7878\",\n    \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0\",\n    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n    \"Accept-Language: en-US,en;q=0.5\",\n    \"Accept-Encoding: gzip, deflate, br\",\n    \"DNT: 1\",\n    \"Connection: keep-alive\",\n    \"Upgrade-Insecure-Requests: 1\",\n    \"Sec-Fetch-Dest: document\",\n    \"Sec-Fetch-Mode: navigate\",\n    \"Sec-Fetch-Site: none\",\n    \"Sec-Fetch-User: ?1\",\n    \"Cache-Control: max-age=0\",\n]\n```\n\nDepending on your browser, you might get slightly different output. Now that\nwe’re printing the request data, we can see why we get multiple connections\nfrom one browser request by looking at the path after `GET` in the first line\nof the request. If the repeated connections are all requesting */*, we know the\nbrowser is trying to fetch */* repeatedly because it’s not getting a response\nfrom our program.\n\nLet’s break down this request data to understand what the browser is asking of\nour program.\n\n### A Closer Look at an HTTP Request\n\nHTTP is a text-based protocol, and a request takes this format:\n\n```text\nMethod Request-URI HTTP-Version CRLF\nheaders CRLF\nmessage-body\n```\n\nThe first line is the *request line* that holds information about what the\nclient is requesting. The first part of the request line indicates the *method*\nbeing used, such as `GET` or `POST`, which describes how the client is making\nthis request. Our client used a `GET` request, which means it is asking for\ninformation.\n\nThe next part of the request line is */*, which indicates the *Uniform Resource\nIdentifier* *(URI)* the client is requesting: a URI is almost, but not quite,\nthe same as a *Uniform Resource Locator* *(URL)*. The difference between URIs\nand URLs isn’t important for our purposes in this chapter, but the HTTP spec\nuses the term URI, so we can just mentally substitute URL for URI here.\n\nThe last part is the HTTP version the client uses, and then the request line\nends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line feed*,\nwhich are terms from the typewriter days!) The CRLF sequence can also be\nwritten as `\\r\\n`, where `\\r` is a carriage return and `\\n` is a line feed. The\nCRLF sequence separates the request line from the rest of the request data.\nNote that when the CRLF is printed, we see a new line start rather than `\\r\\n`.\n\nLooking at the request line data we received from running our program so far,\nwe see that `GET` is the method, */* is the request URI, and `HTTP/1.1` is the\nversion.\n\nAfter the request line, the remaining lines starting from `Host:` onward are\nheaders. `GET` requests have no body.\n\nTry making a request from a different browser or asking for a different\naddress, such as *127.0.0.1:7878/test*, to see how the request data changes.\n\nNow that we know what the browser is asking for, let’s send back some data!\n\n### Writing a Response\n\nWe’re going to implement sending data in response to a client request.\nResponses have the following format:\n\n```text\nHTTP-Version Status-Code Reason-Phrase CRLF\nheaders CRLF\nmessage-body\n```\n\nThe first line is a *status line* that contains the HTTP version used in the\nresponse, a numeric status code that summarizes the result of the request, and\na reason phrase that provides a text description of the status code. After the\nCRLF sequence are any headers, another CRLF sequence, and the body of the\nresponse.\n\nHere is an example response that uses HTTP version 1.1, has a status code of\n200, an OK reason phrase, no headers, and no body:\n\n```text\nHTTP/1.1 200 OK\\r\\n\\r\\n\n```\n\nThe status code 200 is the standard success response. The text is a tiny\nsuccessful HTTP response. Let’s write this to the stream as our response to a\nsuccessful request! From the `handle_connection` function, remove the\n`println!` that was printing the request data and replace it with the code in\nListing 20-3.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-03/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-3: Writing a tiny successful HTTP response to\nthe stream</span>\n\nThe first new line defines the `response` variable that holds the success\nmessage’s data. Then we call `as_bytes` on our `response` to convert the string\ndata to bytes. The `write_all` method on `stream` takes a `&[u8]` and sends\nthose bytes directly down the connection. Because the `write_all` operation\ncould fail, we use `unwrap` on any error result as before. Again, in a real\napplication you would add error handling here.\n\nWith these changes, let’s run our code and make a request. We’re no longer\nprinting any data to the terminal, so we won’t see any output other than the\noutput from Cargo. When you load *127.0.0.1:7878* in a web browser, you should\nget a blank page instead of an error. You’ve just hand-coded receiving an HTTP\nrequest and sending a response!\n\n### Returning Real HTML\n\nLet’s implement the functionality for returning more than a blank page. Create\nthe new file *hello.html* in the root of your project directory, not in the\n*src* directory. You can input any HTML you want; Listing 20-4 shows one\npossibility.\n\n<span class=\"filename\">Filename: hello.html</span>\n\n```html\n{{#include ../listings/ch20-web-server/listing-20-05/hello.html}}\n```\n\n<span class=\"caption\">Listing 20-4: A sample HTML file to return in a\nresponse</span>\n\nThis is a minimal HTML5 document with a heading and some text. To return this\nfrom the server when a request is received, we’ll modify `handle_connection` as\nshown in Listing 20-5 to read the HTML file, add it to the response as a body,\nand send it.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-05/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-5: Sending the contents of *hello.html* as the\nbody of the response</span>\n\nWe’ve added `fs` to the `use` statement to bring the standard library’s\nfilesystem module into scope. The code for reading the contents of a file to a\nstring should look familiar; we used it in Chapter 12 when we read the contents\nof a file for our I/O project in Listing 12-4.\n\nNext, we use `format!` to add the file’s contents as the body of the success\nresponse. To ensure a valid HTTP response, we add the `Content-Length` header\nwhich is set to the size of our response body, in this case the size of\n`hello.html`.\n\nRun this code with `cargo run` and load *127.0.0.1:7878* in your browser; you\nshould see your HTML rendered!\n\nCurrently, we’re ignoring the request data in `http_request` and just sending\nback the contents of the HTML file unconditionally. That means if you try\nrequesting *127.0.0.1:7878/something-else* in your browser, you’ll still get\nback this same HTML response. At the moment, our server is very limited and\ndoes not do what most web servers do. We want to customize our responses\ndepending on the request and only send back the HTML file for a well-formed\nrequest to */*.\n\n### Validating the Request and Selectively Responding\n\nRight now, our web server will return the HTML in the file no matter what the\nclient requested. Let’s add functionality to check that the browser is\nrequesting */* before returning the HTML file and return an error if the\nbrowser requests anything else. For this we need to modify `handle_connection`,\nas shown in Listing 20-6. This new code checks the content of the request\nreceived against what we know a request for */* looks like and adds `if` and\n`else` blocks to treat requests differently.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-06/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-6: Handling requests to */* differently from\nother requests</span>\n\nWe’re only going to be looking at the first line of the HTTP request, so rather\nthan reading the entire request into a vector, we’re calling `next` to get the\nfirst item from the iterator. The first `unwrap` takes care of the `Option` and\nstops the program if the iterator has no items. The second `unwrap` handles the\n`Result` and has the same effect as the `unwrap` that was in the `map` added in\nListing 20-2.\n\nNext, we check the `request_line` to see if it equals the request line of a GET\nrequest to the */* path. If it does, the `if` block returns the contents of our\nHTML file.\n\nIf the `request_line` does *not* equal the GET request to the */* path, it\nmeans we’ve received some other request. We’ll add code to the `else` block in\na moment to respond to all other requests.\n\nRun this code now and request *127.0.0.1:7878*; you should get the HTML in\n*hello.html*. If you make any other request, such as\n*127.0.0.1:7878/something-else*, you’ll get a connection error like those you\nsaw when running the code in Listing 20-1 and Listing 20-2.\n\nNow let’s add the code in Listing 20-7 to the `else` block to return a response\nwith the status code 404, which signals that the content for the request was\nnot found. We’ll also return some HTML for a page to render in the browser\nindicating the response to the end user.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-07/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-7: Responding with status code 404 and an\nerror page if anything other than */* was requested</span>\n\nHere, our response has a status line with status code 404 and the reason phrase\n`NOT FOUND`. The body of the response will be the HTML in the file *404.html*.\nYou’ll need to create a *404.html* file next to *hello.html* for the error\npage; again feel free to use any HTML you want or use the example HTML in\nListing 20-8.\n\n<span class=\"filename\">Filename: 404.html</span>\n\n```html\n{{#include ../listings/ch20-web-server/listing-20-07/404.html}}\n```\n\n<span class=\"caption\">Listing 20-8: Sample content for the page to send back\nwith any 404 response</span>\n\nWith these changes, run your server again. Requesting *127.0.0.1:7878* should\nreturn the contents of *hello.html*, and any other request, like\n*127.0.0.1:7878/foo*, should return the error HTML from *404.html*.\n\n### A Touch of Refactoring\n\nAt the moment the `if` and `else` blocks have a lot of repetition: they’re both\nreading files and writing the contents of the files to the stream. The only\ndifferences are the status line and the filename. Let’s make the code more\nconcise by pulling out those differences into separate `if` and `else` lines\nthat will assign the values of the status line and the filename to variables;\nwe can then use those variables unconditionally in the code to read the file\nand write the response. Listing 20-9 shows the resulting code after replacing\nthe large `if` and `else` blocks.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-09/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-9: Refactoring the `if` and `else` blocks to\ncontain only the code that differs between the two cases</span>\n\nNow the `if` and `else` blocks only return the appropriate values for the\nstatus line and filename in a tuple; we then use destructuring to assign these\ntwo values to `status_line` and `filename` using a pattern in the `let`\nstatement, as discussed in Chapter 18.\n\nThe previously duplicated code is now outside the `if` and `else` blocks and\nuses the `status_line` and `filename` variables. This makes it easier to see\nthe difference between the two cases, and it means we have only one place to\nupdate the code if we want to change how the file reading and response writing\nwork. The behavior of the code in Listing 20-9 will be the same as that in\nListing 20-8.\n\nAwesome! We now have a simple web server in approximately 40 lines of Rust code\nthat responds to one request with a page of content and responds to all other\nrequests with a 404 response.\n\nCurrently, our server runs in a single thread, meaning it can only serve one\nrequest at a time. Let’s examine how that can be a problem by simulating some\nslow requests. Then we’ll fix it so our server can handle multiple requests at\nonce.\n",
          "document_id": 15
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What is a thread pool?",
              "id": 112,
              "answers": [
                {
                  "answer_id": 118,
                  "document_id": 16,
                  "question_id": 112,
                  "text": "A *thread pool* is a group of spawned threads that are waiting and ready to\nhandle a task. When the program receives a new task, it assigns one of the\nthreads in the pool to the task, and that thread will process the task. The\nremaining threads in the pool are available to handle any other tasks that come\nin while the first thread is processing. When the first thread is done\nprocessing its task, it’s returned to the pool of idle threads, ready to handle\na new task. A thread pool allows you to process connections concurrently,\nincreasing the throughput of your server.",
                  "answer_start": 2394,
                  "answer_end": 2967,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to implement API?",
              "id": 113,
              "answers": [
                {
                  "answer_id": 119,
                  "document_id": 16,
                  "question_id": 113,
                  "text": "Write the API of the code so it’s\nstructured in the way you want to call it; then implement the functionality\nwithin that structure rather than implementing the functionality and then\ndesigning the public API.",
                  "answer_start": 4574,
                  "answer_end": 4783,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to create a new thread pool?",
              "id": 114,
              "answers": [
                {
                  "answer_id": 120,
                  "document_id": 16,
                  "question_id": 114,
                  "text": "We use `ThreadPool::new` to create a new thread pool with a configurable number\nof threads, in this case four.",
                  "answer_start": 7224,
                  "answer_end": 7334,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Turning Our Single-Threaded Server into a Multithreaded Server\n\nRight now, the server will process each request in turn, meaning it won’t\nprocess a second connection until the first is finished processing. If the\nserver received more and more requests, this serial execution would be less and\nless optimal. If the server receives a request that takes a long time to\nprocess, subsequent requests will have to wait until the long request is\nfinished, even if the new requests can be processed quickly. We’ll need to fix\nthis, but first, we’ll look at the problem in action.\n\n### Simulating a Slow Request in the Current Server Implementation\n\nWe’ll look at how a slow-processing request can affect other requests made to\nour current server implementation. Listing 20-10 implements handling a request\nto */sleep* with a simulated slow response that will cause the server to sleep\nfor 5 seconds before responding.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-10/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-10: Simulating a slow request by sleeping for\n5 seconds</span>\n\nWe switched from `if` to `match` now that we have three cases. We need to\nexplicitly match on a slice of `request_line` to pattern match against the\nstring literal values; `match` doesn’t do automatic referencing and\ndereferencing like the equality method does.\n\nThe first arm is the same as the `if` block from Listing 20-9. The second arm\nmatches a request to */sleep*. When that request is received, the server will\nsleep for 5 seconds before rendering the successful HTML page. The third arm is\nthe same as the `else` block from Listing 20-9.\n\nYou can see how primitive our server is: real libraries would handle the\nrecognition of multiple requests in a much less verbose way!\n\nStart the server using `cargo run`. Then open two browser windows: one for\n*http://127.0.0.1:7878/* and the other for *http://127.0.0.1:7878/sleep*. If\nyou enter the */* URI a few times, as before, you’ll see it respond quickly.\nBut if you enter */sleep* and then load */*, you’ll see that */* waits until\n`sleep` has slept for its full 5 seconds before loading.\n\nThere are multiple techniques we could use to avoid requests backing up behind\na slow request; the one we’ll implement is a thread pool.\n\n### Improving Throughput with a Thread Pool\n\nA *thread pool* is a group of spawned threads that are waiting and ready to\nhandle a task. When the program receives a new task, it assigns one of the\nthreads in the pool to the task, and that thread will process the task. The\nremaining threads in the pool are available to handle any other tasks that come\nin while the first thread is processing. When the first thread is done\nprocessing its task, it’s returned to the pool of idle threads, ready to handle\na new task. A thread pool allows you to process connections concurrently,\nincreasing the throughput of your server.\n\nWe’ll limit the number of threads in the pool to a small number to protect us\nfrom Denial of Service (DoS) attacks; if we had our program create a new thread\nfor each request as it came in, someone making 10 million requests to our\nserver could create havoc by using up all our server’s resources and grinding\nthe processing of requests to a halt.\n\nRather than spawning unlimited threads, then, we’ll have a fixed number of\nthreads waiting in the pool. Requests that come in are sent to the pool for\nprocessing. The pool will maintain a queue of incoming requests. Each of the\nthreads in the pool will pop off a request from this queue, handle the request,\nand then ask the queue for another request. With this design, we can process up\nto `N` requests concurrently, where `N` is the number of threads. If each\nthread is responding to a long-running request, subsequent requests can still\nback up in the queue, but we’ve increased the number of long-running requests\nwe can handle before reaching that point.\n\nThis technique is just one of many ways to improve the throughput of a web\nserver. Other options you might explore are the *fork/join model*, the\n*single-threaded async I/O model*, or the *multi-threaded async I/O model*. If\nyou’re interested in this topic, you can read more about other solutions and\ntry to implement them; with a low-level language like Rust, all of these\noptions are possible.\n\nBefore we begin implementing a thread pool, let’s talk about what using the\npool should look like. When you’re trying to design code, writing the client\ninterface first can help guide your design. Write the API of the code so it’s\nstructured in the way you want to call it; then implement the functionality\nwithin that structure rather than implementing the functionality and then\ndesigning the public API.\n\nSimilar to how we used test-driven development in the project in Chapter 12,\nwe’ll use compiler-driven development here. We’ll write the code that calls the\nfunctions we want, and then we’ll look at errors from the compiler to determine\nwhat we should change next to get the code to work. Before we do that, however,\nwe’ll explore the technique we’re not going to use as a starting point.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"code-structure-if-we-could-spawn-a-thread-for-each-request\"></a>\n\n#### Spawning a Thread for Each Request\n\nFirst, let’s explore how our code might look if it did create a new thread for\nevery connection. As mentioned earlier, this isn’t our final plan due to the\nproblems with potentially spawning an unlimited number of threads, but it is a\nstarting point to get a working multithreaded server first. Then we’ll add the\nthread pool as an improvement, and contrasting the two solutions will be\neasier. Listing 20-11 shows the changes to make to `main` to spawn a new thread\nto handle each stream within the `for` loop.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,no_run\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-11/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-11: Spawning a new thread for each\nstream</span>\n\nAs you learned in Chapter 16, `thread::spawn` will create a new thread and then\nrun the code in the closure in the new thread. If you run this code and load\n*/sleep* in your browser, then */* in two more browser tabs, you’ll indeed see\nthat the requests to */* don’t have to wait for */sleep* to finish. However, as\nwe mentioned, this will eventually overwhelm the system because you’d be making\nnew threads without any limit.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"creating-a-similar-interface-for-a-finite-number-of-threads\"></a>\n\n#### Creating a Finite Number of Threads\n\nWe want our thread pool to work in a similar, familiar way so switching from\nthreads to a thread pool doesn’t require large changes to the code that uses\nour API. Listing 20-12 shows the hypothetical interface for a `ThreadPool`\nstruct we want to use instead of `thread::spawn`.\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-12/src/main.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-12: Our ideal `ThreadPool` interface</span>\n\nWe use `ThreadPool::new` to create a new thread pool with a configurable number\nof threads, in this case four. Then, in the `for` loop, `pool.execute` has a\nsimilar interface as `thread::spawn` in that it takes a closure the pool should\nrun for each stream. We need to implement `pool.execute` so it takes the\nclosure and gives it to a thread in the pool to run. This code won’t yet\ncompile, but we’ll try so the compiler can guide us in how to fix it.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"building-the-threadpool-struct-using-compiler-driven-development\"></a>\n\n#### Building `ThreadPool` Using Compiler Driven Development\n\nMake the changes in Listing 20-12 to *src/main.rs*, and then let’s use the\ncompiler errors from `cargo check` to drive our development. Here is the first\nerror we get:\n\n```console\n{{#include ../listings/ch20-web-server/listing-20-12/output.txt}}\n```\n\nGreat! This error tells us we need a `ThreadPool` type or module, so we’ll\nbuild one now. Our `ThreadPool` implementation will be independent of the kind\nof work our web server is doing. So, let’s switch the `hello` crate from a\nbinary crate to a library crate to hold our `ThreadPool` implementation. After\nwe change to a library crate, we could also use the separate thread pool\nlibrary for any work we want to do using a thread pool, not just for serving\nweb requests.\n\nCreate a *src/lib.rs* that contains the following, which is the simplest\ndefinition of a `ThreadPool` struct that we can have for now:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/src/lib.rs}}\n```\n\nThen edit *main.rs* file to bring `ThreadPool` into scope from the library\ncrate by adding the following code to the top of *src/main.rs*:\n\n<span class=\"filename\">Filename: src/main.rs</span>\n\n```rust,ignore\n{{#rustdoc_include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/src/main.rs:here}}\n```\n\nThis code still won’t work, but let’s check it again to get the next error that\nwe need to address:\n\n```console\n{{#include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/output.txt}}\n```\n\nThis error indicates that next we need to create an associated function named\n`new` for `ThreadPool`. We also know that `new` needs to have one parameter\nthat can accept `4` as an argument and should return a `ThreadPool` instance.\nLet’s implement the simplest `new` function that will have those\ncharacteristics:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/no-listing-02-impl-threadpool-new/src/lib.rs}}\n```\n\nWe chose `usize` as the type of the `size` parameter, because we know that a\nnegative number of threads doesn’t make any sense. We also know we’ll use this\n4 as the number of elements in a collection of threads, which is what the\n`usize` type is for, as discussed in the [“Integer Types”][integer-types]<!--\nignore --> section of Chapter 3.\n\nLet’s check the code again:\n\n```console\n{{#include ../listings/ch20-web-server/no-listing-02-impl-threadpool-new/output.txt}}\n```\n\nNow the error occurs because we don’t have an `execute` method on `ThreadPool`.\nRecall from the [“Creating a Finite Number of\nThreads”](#creating-a-finite-number-of-threads)<!-- ignore --> section that we\ndecided our thread pool should have an interface similar to `thread::spawn`. In\naddition, we’ll implement the `execute` function so it takes the closure it’s\ngiven and gives it to an idle thread in the pool to run.\n\nWe’ll define the `execute` method on `ThreadPool` to take a closure as a\nparameter. Recall from the [“Moving Captured Values Out of the Closure and the\n`Fn` Traits”][fn-traits]<!-- ignore --> section in Chapter 13 that we can take\nclosures as parameters with three different traits: `Fn`, `FnMut`, and\n`FnOnce`. We need to decide which kind of closure to use here. We know we’ll\nend up doing something similar to the standard library `thread::spawn`\nimplementation, so we can look at what bounds the signature of `thread::spawn`\nhas on its parameter. The documentation shows us the following:\n\n```rust,ignore\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send + 'static,\n```\n\nThe `F` type parameter is the one we’re concerned with here; the `T` type\nparameter is related to the return value, and we’re not concerned with that. We\ncan see that `spawn` uses `FnOnce` as the trait bound on `F`. This is probably\nwhat we want as well, because we’ll eventually pass the argument we get in\n`execute` to `spawn`. We can be further confident that `FnOnce` is the trait we\nwant to use because the thread for running a request will only execute that\nrequest’s closure one time, which matches the `Once` in `FnOnce`.\n\nThe `F` type parameter also has the trait bound `Send` and the lifetime bound\n`'static`, which are useful in our situation: we need `Send` to transfer the\nclosure from one thread to another and `'static` because we don’t know how long\nthe thread will take to execute. Let’s create an `execute` method on\n`ThreadPool` that will take a generic parameter of type `F` with these bounds:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/no-listing-03-define-execute/src/lib.rs:here}}\n```\n\nWe still use the `()` after `FnOnce` because this `FnOnce` represents a closure\nthat takes no parameters and returns the unit type `()`. Just like function\ndefinitions, the return type can be omitted from the signature, but even if we\nhave no parameters, we still need the parentheses.\n\nAgain, this is the simplest implementation of the `execute` method: it does\nnothing, but we’re trying only to make our code compile. Let’s check it again:\n\n```console\n{{#include ../listings/ch20-web-server/no-listing-03-define-execute/output.txt}}\n```\n\nIt compiles! But note that if you try `cargo run` and make a request in the\nbrowser, you’ll see the errors in the browser that we saw at the beginning of\nthe chapter. Our library isn’t actually calling the closure passed to `execute`\nyet!\n\n> Note: A saying you might hear about languages with strict compilers, such as\n> Haskell and Rust, is “if the code compiles, it works.” But this saying is not\n> universally true. Our project compiles, but it does absolutely nothing! If we\n> were building a real, complete project, this would be a good time to start\n> writing unit tests to check that the code compiles *and* has the behavior we\n> want.\n\n#### Validating the Number of Threads in `new`\n\nWe aren’t doing anything with the parameters to `new` and `execute`. Let’s\nimplement the bodies of these functions with the behavior we want. To start,\nlet’s think about `new`. Earlier we chose an unsigned type for the `size`\nparameter, because a pool with a negative number of threads makes no sense.\nHowever, a pool with zero threads also makes no sense, yet zero is a perfectly\nvalid `usize`. We’ll add code to check that `size` is greater than zero before\nwe return a `ThreadPool` instance and have the program panic if it receives a\nzero by using the `assert!` macro, as shown in Listing 20-13.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-13/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-13: Implementing `ThreadPool::new` to panic if\n`size` is zero</span>\n\nWe’ve also added some documentation for our `ThreadPool` with doc comments.\nNote that we followed good documentation practices by adding a section that\ncalls out the situations in which our function can panic, as discussed in\nChapter 14. Try running `cargo doc --open` and clicking the `ThreadPool` struct\nto see what the generated docs for `new` look like!\n\nInstead of adding the `assert!` macro as we’ve done here, we could change `new`\ninto `build` and return a `Result` like we did with `Config::build` in the I/O\nproject in Listing 12-9. But we’ve decided in this case that trying to create a\nthread pool without any threads should be an unrecoverable error. If you’re\nfeeling ambitious, try to write a function named `build` with the following\nsignature to compare with the `new` function:\n\n```rust,ignore\npub fn build(size: usize) -> Result<ThreadPool, PoolCreationError> {\n```\n\n#### Creating Space to Store the Threads\n\nNow that we have a way to know we have a valid number of threads to store in\nthe pool, we can create those threads and store them in the `ThreadPool` struct\nbefore returning the struct. But how do we “store” a thread? Let’s take another\nlook at the `thread::spawn` signature:\n\n```rust,ignore\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send + 'static,\n```\n\nThe `spawn` function returns a `JoinHandle<T>`, where `T` is the type that the\nclosure returns. Let’s try using `JoinHandle` too and see what happens. In our\ncase, the closures we’re passing to the thread pool will handle the connection\nand not return anything, so `T` will be the unit type `()`.\n\nThe code in Listing 20-14 will compile but doesn’t create any threads yet.\nWe’ve changed the definition of `ThreadPool` to hold a vector of\n`thread::JoinHandle<()>` instances, initialized the vector with a capacity of\n`size`, set up a `for` loop that will run some code to create the threads, and\nreturned a `ThreadPool` instance containing them.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,not_desired_behavior\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-14/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-14: Creating a vector for `ThreadPool` to hold\nthe threads</span>\n\nWe’ve brought `std::thread` into scope in the library crate, because we’re\nusing `thread::JoinHandle` as the type of the items in the vector in\n`ThreadPool`.\n\nOnce a valid size is received, our `ThreadPool` creates a new vector that can\nhold `size` items. The `with_capacity` function performs the same task as\n`Vec::new` but with an important difference: it preallocates space in the\nvector. Because we know we need to store `size` elements in the vector, doing\nthis allocation up front is slightly more efficient than using `Vec::new`,\nwhich resizes itself as elements are inserted.\n\nWhen you run `cargo check` again, it should succeed.\n\n#### A `Worker` Struct Responsible for Sending Code from the `ThreadPool` to a Thread\n\nWe left a comment in the `for` loop in Listing 20-14 regarding the creation of\nthreads. Here, we’ll look at how we actually create threads. The standard\nlibrary provides `thread::spawn` as a way to create threads, and\n`thread::spawn` expects to get some code the thread should run as soon as the\nthread is created. However, in our case, we want to create the threads and have\nthem *wait* for code that we’ll send later. The standard library’s\nimplementation of threads doesn’t include any way to do that; we have to\nimplement it manually.\n\nWe’ll implement this behavior by introducing a new data structure between the\n`ThreadPool` and the threads that will manage this new behavior. We’ll call\nthis data structure *Worker*, which is a common term in pooling\nimplementations. The Worker picks up code that needs to be run and runs the\ncode in the Worker’s thread. Think of people working in the kitchen at a\nrestaurant: the workers wait until orders come in from customers, and then\nthey’re responsible for taking those orders and fulfilling them.\n\nInstead of storing a vector of `JoinHandle<()>` instances in the thread pool,\nwe’ll store instances of the `Worker` struct. Each `Worker` will store a single\n`JoinHandle<()>` instance. Then we’ll implement a method on `Worker` that will\ntake a closure of code to run and send it to the already running thread for\nexecution. We’ll also give each worker an `id` so we can distinguish between\nthe different workers in the pool when logging or debugging.\n\nHere is the new process that will happen when we create a `ThreadPool`. We’ll\nimplement the code that sends the closure to the thread after we have `Worker`\nset up in this way:\n\n1. Define a `Worker` struct that holds an `id` and a `JoinHandle<()>`.\n2. Change `ThreadPool` to hold a vector of `Worker` instances.\n3. Define a `Worker::new` function that takes an `id` number and returns a\n   `Worker` instance that holds the `id` and a thread spawned with an empty\n   closure.\n4. In `ThreadPool::new`, use the `for` loop counter to generate an `id`, create\n   a new `Worker` with that `id`, and store the worker in the vector.\n\nIf you’re up for a challenge, try implementing these changes on your own before\nlooking at the code in Listing 20-15.\n\nReady? Here is Listing 20-15 with one way to make the preceding modifications.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-15/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-15: Modifying `ThreadPool` to hold `Worker`\ninstances instead of holding threads directly</span>\n\nWe’ve changed the name of the field on `ThreadPool` from `threads` to `workers`\nbecause it’s now holding `Worker` instances instead of `JoinHandle<()>`\ninstances. We use the counter in the `for` loop as an argument to\n`Worker::new`, and we store each new `Worker` in the vector named `workers`.\n\nExternal code (like our server in *src/main.rs*) doesn’t need to know the\nimplementation details regarding using a `Worker` struct within `ThreadPool`,\nso we make the `Worker` struct and its `new` function private. The\n`Worker::new` function uses the `id` we give it and stores a `JoinHandle<()>`\ninstance that is created by spawning a new thread using an empty closure.\n\n> Note: If the operating system can’t create a thread because there aren’t\n> enough system resources, `thread::spawn` will panic. That will cause our\n> whole server to panic, even though the creation of some threads might\n> succeed. For simplicity’s sake, this behavior is fine, but in a production\n> thread pool implementation, you’d likely want to use\n> [`std::thread::Builder`][builder]<!-- ignore --> and its\n> [`spawn`][builder-spawn]<!-- ignore --> method that returns `Result` instead.\n\nThis code will compile and will store the number of `Worker` instances we\nspecified as an argument to `ThreadPool::new`. But we’re *still* not processing\nthe closure that we get in `execute`. Let’s look at how to do that next.\n\n#### Sending Requests to Threads via Channels\n\nThe next problem we’ll tackle is that the closures given to `thread::spawn` do\nabsolutely nothing. Currently, we get the closure we want to execute in the\n`execute` method. But we need to give `thread::spawn` a closure to run when we\ncreate each `Worker` during the creation of the `ThreadPool`.\n\nWe want the `Worker` structs that we just created to fetch the code to run from\na queue held in the `ThreadPool` and send that code to its thread to run.\n\nThe channels we learned about in Chapter 16—a simple way to communicate between\ntwo threads—would be perfect for this use case. We’ll use a channel to function\nas the queue of jobs, and `execute` will send a job from the `ThreadPool` to\nthe `Worker` instances, which will send the job to its thread. Here is the plan:\n\n1. The `ThreadPool` will create a channel and hold on to the sender.\n2. Each `Worker` will hold on to the receiver.\n3. We’ll create a new `Job` struct that will hold the closures we want to send\n   down the channel.\n4. The `execute` method will send the job it wants to execute through the\n   sender.\n5. In its thread, the `Worker` will loop over its receiver and execute the\n   closures of any jobs it receives.\n\nLet’s start by creating a channel in `ThreadPool::new` and holding the sender\nin the `ThreadPool` instance, as shown in Listing 20-16. The `Job` struct\ndoesn’t hold anything for now but will be the type of item we’re sending down\nthe channel.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-16/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-16: Modifying `ThreadPool` to store the\nsender of a channel that transmits `Job` instances</span>\n\nIn `ThreadPool::new`, we create our new channel and have the pool hold the\nsender. This will successfully compile.\n\nLet’s try passing a receiver of the channel into each worker as the thread pool\ncreates the channel. We know we want to use the receiver in the thread that the\nworkers spawn, so we’ll reference the `receiver` parameter in the closure. The\ncode in Listing 20-17 won’t quite compile yet.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,does_not_compile\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-17/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-17: Passing the receiver to the workers</span>\n\nWe’ve made some small and straightforward changes: we pass the receiver into\n`Worker::new`, and then we use it inside the closure.\n\nWhen we try to check this code, we get this error:\n\n```console\n{{#include ../listings/ch20-web-server/listing-20-17/output.txt}}\n```\n\nThe code is trying to pass `receiver` to multiple `Worker` instances. This\nwon’t work, as you’ll recall from Chapter 16: the channel implementation that\nRust provides is multiple *producer*, single *consumer*. This means we can’t\njust clone the consuming end of the channel to fix this code. We also don’t\nwant to send a message multiple times to multiple consumers; we want one list\nof messages with multiple workers such that each message gets processed once.\n\nAdditionally, taking a job off the channel queue involves mutating the\n`receiver`, so the threads need a safe way to share and modify `receiver`;\notherwise, we might get race conditions (as covered in Chapter 16).\n\nRecall the thread-safe smart pointers discussed in Chapter 16: to share\nownership across multiple threads and allow the threads to mutate the value, we\nneed to use `Arc<Mutex<T>>`. The `Arc` type will let multiple workers own the\nreceiver, and `Mutex` will ensure that only one worker gets a job from the\nreceiver at a time. Listing 20-18 shows the changes we need to make.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-18/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-18: Sharing the receiver among the workers\nusing `Arc` and `Mutex`</span>\n\nIn `ThreadPool::new`, we put the receiver in an `Arc` and a `Mutex`. For each\nnew worker, we clone the `Arc` to bump the reference count so the workers can\nshare ownership of the receiver.\n\nWith these changes, the code compiles! We’re getting there!\n\n#### Implementing the `execute` Method\n\nLet’s finally implement the `execute` method on `ThreadPool`. We’ll also change\n`Job` from a struct to a type alias for a trait object that holds the type of\nclosure that `execute` receives. As discussed in the [“Creating Type Synonyms\nwith Type Aliases”][creating-type-synonyms-with-type-aliases]<!-- ignore -->\nsection of Chapter 19, type aliases allow us to make long types shorter for\nease of use. Look at Listing 20-19.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-19/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-19: Creating a `Job` type alias for a `Box`\nthat holds each closure and then sending the job down the channel</span>\n\nAfter creating a new `Job` instance using the closure we get in `execute`, we\nsend that job down the sending end of the channel. We’re calling `unwrap` on\n`send` for the case that sending fails. This might happen if, for example, we\nstop all our threads from executing, meaning the receiving end has stopped\nreceiving new messages. At the moment, we can’t stop our threads from\nexecuting: our threads continue executing as long as the pool exists. The\nreason we use `unwrap` is that we know the failure case won’t happen, but the\ncompiler doesn’t know that.\n\nBut we’re not quite done yet! In the worker, our closure being passed to\n`thread::spawn` still only *references* the receiving end of the channel.\nInstead, we need the closure to loop forever, asking the receiving end of the\nchannel for a job and running the job when it gets one. Let’s make the change\nshown in Listing 20-20 to `Worker::new`.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-20/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-20: Receiving and executing the jobs in the\nworker’s thread</span>\n\nHere, we first call `lock` on the `receiver` to acquire the mutex, and then we\ncall `unwrap` to panic on any errors. Acquiring a lock might fail if the mutex\nis in a *poisoned* state, which can happen if some other thread panicked while\nholding the lock rather than releasing the lock. In this situation, calling\n`unwrap` to have this thread panic is the correct action to take. Feel free to\nchange this `unwrap` to an `expect` with an error message that is meaningful to\nyou.\n\nIf we get the lock on the mutex, we call `recv` to receive a `Job` from the\nchannel. A final `unwrap` moves past any errors here as well, which might occur\nif the thread holding the sender has shut down, similar to how the `send`\nmethod returns `Err` if the receiver shuts down.\n\nThe call to `recv` blocks, so if there is no job yet, the current thread will\nwait until a job becomes available. The `Mutex<T>` ensures that only one\n`Worker` thread at a time is trying to request a job.\n\nOur thread pool is now in a working state! Give it a `cargo run` and make some\nrequests:\n\n<!-- manual-regeneration\ncd listings/ch20-web-server/listing-20-20\ncargo run\nmake some requests to 127.0.0.1:7878\nCan't automate because the output depends on making requests\n-->\n\n```console\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\nwarning: field is never read: `workers`\n --> src/lib.rs:7:5\n  |\n7 |     workers: Vec<Worker>,\n  |     ^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(dead_code)]` on by default\n\nwarning: field is never read: `id`\n  --> src/lib.rs:48:5\n   |\n48 |     id: usize,\n   |     ^^^^^^^^^\n\nwarning: field is never read: `thread`\n  --> src/lib.rs:49:5\n   |\n49 |     thread: thread::JoinHandle<()>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: `hello` (lib) generated 3 warnings\n    Finished dev [unoptimized + debuginfo] target(s) in 1.40s\n     Running `target/debug/hello`\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\n```\n\nSuccess! We now have a thread pool that executes connections asynchronously.\nThere are never more than four threads created, so our system won’t get\noverloaded if the server receives a lot of requests. If we make a request to\n*/sleep*, the server will be able to serve other requests by having another\nthread run them.\n\n> Note: if you open */sleep* in multiple browser windows simultaneously, they\n> might load one at a time in 5 second intervals. Some web browsers execute\n> multiple instances of the same request sequentially for caching reasons. This\n> limitation is not caused by our web server.\n\nAfter learning about the `while let` loop in Chapter 18, you might be wondering\nwhy we didn’t write the worker thread code as shown in Listing 20-21.\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,ignore,not_desired_behavior\n{{#rustdoc_include ../listings/ch20-web-server/listing-20-21/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 20-21: An alternative implementation of\n`Worker::new` using `while let`</span>\n\nThis code compiles and runs but doesn’t result in the desired threading\nbehavior: a slow request will still cause other requests to wait to be\nprocessed. The reason is somewhat subtle: the `Mutex` struct has no public\n`unlock` method because the ownership of the lock is based on the lifetime of\nthe `MutexGuard<T>` within the `LockResult<MutexGuard<T>>` that the `lock`\nmethod returns. At compile time, the borrow checker can then enforce the rule\nthat a resource guarded by a `Mutex` cannot be accessed unless we hold the\nlock. However, this implementation can also result in the lock being held\nlonger than intended if we aren’t mindful of the lifetime of the\n`MutexGuard<T>`.\n\nThe code in Listing 20-20 that uses `let job =\nreceiver.lock().unwrap().recv().unwrap();` works because with `let`, any\ntemporary values used in the expression on the right hand side of the equals\nsign are immediately dropped when the `let` statement ends. However, `while\nlet` (and `if let` and `match`) does not drop temporary values until the end of\nthe associated block. In Listing 20-21, the lock remains held for the duration\nof the call to `job()`, meaning other workers cannot receive jobs.\n\n[creating-type-synonyms-with-type-aliases]:\nch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases\n[integer-types]: ch03-02-data-types.html#integer-types\n[fn-traits]:\nch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits\n[builder]: ../std/thread/struct.Builder.html\n[builder-spawn]: ../std/thread/struct.Builder.html#method.spawn\n",
          "document_id": 16
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "For whom might be Rust?",
              "id": 115,
              "answers": [
                {
                  "answer_id": 121,
                  "document_id": 18,
                  "question_id": 115,
                  "text": "Programmers who are already working with low-level code can use Rust to raise\ntheir ambitions. For example, introducing parallelism in Rust is a relatively\nlow-risk operation: the compiler will catch the classical mistakes for you. And\nyou can tackle more aggressive optimizations in your code with the confidence\nthat you won’t accidentally introduce crashes or vulnerabilities.",
                  "answer_start": 1183,
                  "answer_end": 1562,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is Rust limited to low-level systems programming?",
              "id": 116,
              "answers": [
                {
                  "answer_id": 122,
                  "document_id": 18,
                  "question_id": 116,
                  "text": "But Rust isn’t limited to low-level systems programming. It’s expressive and\nergonomic enough to make CLI apps, web servers, and many other kinds of code\nquite pleasant to write",
                  "answer_start": 1564,
                  "answer_end": 1741,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Where else I could use Rust?",
              "id": 117,
              "answers": [
                {
                  "answer_id": 123,
                  "document_id": 18,
                  "question_id": 117,
                  "text": "Working with Rust allows you to build skills that transfer from one\ndomain to another; you can learn Rust by writing a web app, then apply those\nsame skills to target your Raspberry Pi.",
                  "answer_start": 1799,
                  "answer_end": 1984,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "# Foreword\n\nIt wasn’t always so clear, but the Rust programming language is fundamentally\nabout *empowerment*: no matter what kind of code you are writing now, Rust\nempowers you to reach farther, to program with confidence in a wider variety of\ndomains than you did before.\n\nTake, for example, “systems-level” work that deals with low-level details of\nmemory management, data representation, and concurrency. Traditionally, this\nrealm of programming is seen as arcane, accessible only to a select few who\nhave devoted the necessary years learning to avoid its infamous pitfalls. And\neven those who practice it do so with caution, lest their code be open to\nexploits, crashes, or corruption.\n\nRust breaks down these barriers by eliminating the old pitfalls and providing a\nfriendly, polished set of tools to help you along the way. Programmers who need\nto “dip down” into lower-level control can do so with Rust, without taking on\nthe customary risk of crashes or security holes, and without having to learn\nthe fine points of a fickle toolchain. Better yet, the language is designed to\nguide you naturally towards reliable code that is efficient in terms of speed\nand memory usage.\n\nProgrammers who are already working with low-level code can use Rust to raise\ntheir ambitions. For example, introducing parallelism in Rust is a relatively\nlow-risk operation: the compiler will catch the classical mistakes for you. And\nyou can tackle more aggressive optimizations in your code with the confidence\nthat you won’t accidentally introduce crashes or vulnerabilities.\n\nBut Rust isn’t limited to low-level systems programming. It’s expressive and\nergonomic enough to make CLI apps, web servers, and many other kinds of code\nquite pleasant to write — you’ll find simple examples of both later in the\nbook. Working with Rust allows you to build skills that transfer from one\ndomain to another; you can learn Rust by writing a web app, then apply those\nsame skills to target your Raspberry Pi.\n\nThis book fully embraces the potential of Rust to empower its users. It’s a\nfriendly and approachable text intended to help you level up not just your\nknowledge of Rust, but also your reach and confidence as a programmer in\ngeneral. So dive in, get ready to learn—and welcome to the Rust community!\n\n— Nicholas Matsakis and Aaron Turon\n",
          "document_id": 18
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "How does book 'Gang of four' define object orientated programming?",
              "id": 1,
              "answers": [
                {
                  "answer_id": 1,
                  "document_id": 1,
                  "question_id": 1,
                  "text": "> Object-oriented programs are made up of objects. An *object* packages both\n> data and the procedures that operate on that data. The procedures are\n> typically called *methods* or *operations*.",
                  "answer_start": 869,
                  "answer_end": 1063,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is Rust object-oriented language",
              "id": 2,
              "answers": [
                {
                  "answer_id": 2,
                  "document_id": 1,
                  "question_id": 2,
                  "text": "Rust is object-oriented: structs and enums have data,\nand `impl` blocks provide methods on structs and enums. Even though structs and\nenums with methods aren’t *called* objects, they provide the same\nfunctionality",
                  "answer_start": 1088,
                  "answer_end": 1301,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What does encapsulation regarding OOP means?",
              "id": 3,
              "answers": [
                {
                  "answer_id": 3,
                  "document_id": 1,
                  "question_id": 3,
                  "text": " implementation details of an object aren’t accessible to\ncode using that object. Therefore, the only way to interact with an object is\nthrough its public API; code using the object shouldn’t be able to reach into\nthe object’s internals and change data or behavior directly.",
                  "answer_start": 1508,
                  "answer_end": 1782,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Which keyword should I use to mark modules, types, functions or methods in my code as public?",
              "id": 4,
              "answers": [
                {
                  "answer_id": 4,
                  "document_id": 1,
                  "question_id": 4,
                  "text": "we can use the `pub`\nkeyword",
                  "answer_start": 1970,
                  "answer_end": 1998,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What access modifier have by default all methods or fields?",
              "id": 5,
              "answers": [
                {
                  "answer_id": 5,
                  "document_id": 1,
                  "question_id": 5,
                  "text": "by default everything else is private",
                  "answer_start": 2088,
                  "answer_end": 2125,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is inheritance?",
              "id": 6,
              "answers": [
                {
                  "answer_id": 6,
                  "document_id": 1,
                  "question_id": 6,
                  "text": "*Inheritance* is a mechanism whereby an object can inherit elements from\nanother object’s definition, thus gaining the parent object’s data and behavior\nwithout you having to define them again.",
                  "answer_start": 5140,
                  "answer_end": 5333,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Is there an easy way to implement inheritance in rust?",
              "id": 7,
              "answers": [
                {
                  "answer_id": 7,
                  "document_id": 1,
                  "question_id": 7,
                  "text": "There is no way to define a struct that inherits the parent\nstruct’s fields and method implementations without using a macro.",
                  "answer_start": 5428,
                  "answer_end": 5553,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why is inheritance important?",
              "id": 8,
              "answers": [
                {
                  "answer_id": 8,
                  "document_id": 1,
                  "question_id": 8,
                  "text": "for reuse of code:\nyou can implement particular behavior for one type, and inheritance enables you\nto reuse that implementation for a different type.",
                  "answer_start": 5800,
                  "answer_end": 5949,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why is inheritance important?",
              "id": 9,
              "answers": [
                {
                  "answer_id": 9,
                  "document_id": 1,
                  "question_id": 9,
                  "text": "to use inheritance relates to the type system: to enable a\nchild type to be used in the same places as the parent type.",
                  "answer_start": 6663,
                  "answer_end": 6782,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is polymorphism?",
              "id": 10,
              "answers": [
                {
                  "answer_id": 10,
                  "document_id": 1,
                  "question_id": 10,
                  "text": "which means that you can substitute multiple objects for\neach other at runtime if they share certain characteristics.",
                  "answer_start": 6819,
                  "answer_end": 6936,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is polymorphism?",
              "id": 11,
              "answers": [
                {
                  "answer_id": 11,
                  "document_id": 1,
                  "question_id": 11,
                  "text": "code that can work with data\n> of multiple types.",
                  "answer_start": 7080,
                  "answer_end": 7129,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "What is bounded parametric polymorphism?",
              "id": 12,
              "answers": [
                {
                  "answer_id": 12,
                  "document_id": 1,
                  "question_id": 12,
                  "text": " Rust instead uses generics to abstract over different possible types and\n> trait bounds to impose constraints on what those types must provide.",
                  "answer_start": 7188,
                  "answer_end": 7332,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why has inheritance recently fallen out of favor as a programming design solution in many programming languages?",
              "id": 13,
              "answers": [
                {
                  "answer_id": 13,
                  "document_id": 1,
                  "question_id": 13,
                  "text": "because it’s often at risk of sharing more code\nthan necessary. Subclasses shouldn’t always share all characteristics of their\nparent class but will do so with inheritance. This can make a program’s design\nless flexible. It also introduces the possibility of calling methods on\nsubclasses that don’t make sense or that cause errors because the methods don’t\napply to the subclass. In addition, some languages will only allow single\ninheritance (meaning a subclass can only inherit from one class), further\nrestricting the flexibility of a program’s design.",
                  "answer_start": 7504,
                  "answer_end": 8060,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "Why subclasses shouldn’t always share all characteristics of their parent class?",
              "id": 118,
              "answers": [
                {
                  "answer_id": 124,
                  "document_id": 1,
                  "question_id": 118,
                  "text": "Subclasses shouldn’t always share all characteristics of their\nparent class but will do so with inheritance. This can make a program’s design\nless flexible. It also introduces the possibility of calling methods on\nsubclasses that don’t make sense or that cause errors because the methods don’t\napply to the subclass. In addition, some languages will only allow single\ninheritance (meaning a subclass can only inherit from one class), further\nrestricting the flexibility of a program’s design.",
                  "answer_start": 7568,
                  "answer_end": 8060,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "## Characteristics of Object-Oriented Languages\n\nThere is no consensus in the programming community about what features a\nlanguage must have to be considered object-oriented. Rust is influenced by many\nprogramming paradigms, including OOP; for example, we explored the features\nthat came from functional programming in Chapter 13. Arguably, OOP languages\nshare certain common characteristics, namely objects, encapsulation, and\ninheritance. Let’s look at what each of those characteristics means and whether\nRust supports it.\n\n### Objects Contain Data and Behavior\n\nThe book *Design Patterns: Elements of Reusable Object-Oriented Software* by\nErich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley\nProfessional, 1994), colloquially referred to as *The Gang of Four* book, is a\ncatalog of object-oriented design patterns. It defines OOP this way:\n\n> Object-oriented programs are made up of objects. An *object* packages both\n> data and the procedures that operate on that data. The procedures are\n> typically called *methods* or *operations*.\n\nUsing this definition, Rust is object-oriented: structs and enums have data,\nand `impl` blocks provide methods on structs and enums. Even though structs and\nenums with methods aren’t *called* objects, they provide the same\nfunctionality, according to the Gang of Four’s definition of objects.\n\n### Encapsulation that Hides Implementation Details\n\nAnother aspect commonly associated with OOP is the idea of *encapsulation*,\nwhich means that the implementation details of an object aren’t accessible to\ncode using that object. Therefore, the only way to interact with an object is\nthrough its public API; code using the object shouldn’t be able to reach into\nthe object’s internals and change data or behavior directly. This enables the\nprogrammer to change and refactor an object’s internals without needing to\nchange the code that uses the object.\n\nWe discussed how to control encapsulation in Chapter 7: we can use the `pub`\nkeyword to decide which modules, types, functions, and methods in our code\nshould be public, and by default everything else is private. For example, we\ncan define a struct `AveragedCollection` that has a field containing a vector\nof `i32` values. The struct can also have a field that contains the average of\nthe values in the vector, meaning the average doesn’t have to be computed\non demand whenever anyone needs it. In other words, `AveragedCollection` will\ncache the calculated average for us. Listing 17-1 has the definition of the\n`AveragedCollection` struct:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-01/src/lib.rs}}\n```\n\n<span class=\"caption\">Listing 17-1: An `AveragedCollection` struct that\nmaintains a list of integers and the average of the items in the\ncollection</span>\n\nThe struct is marked `pub` so that other code can use it, but the fields within\nthe struct remain private. This is important in this case because we want to\nensure that whenever a value is added or removed from the list, the average is\nalso updated. We do this by implementing `add`, `remove`, and `average` methods\non the struct, as shown in Listing 17-2:\n\n<span class=\"filename\">Filename: src/lib.rs</span>\n\n```rust,noplayground\n{{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:here}}\n```\n\n<span class=\"caption\">Listing 17-2: Implementations of the public methods\n`add`, `remove`, and `average` on `AveragedCollection`</span>\n\nThe public methods `add`, `remove`, and `average` are the only ways to access\nor modify data in an instance of `AveragedCollection`. When an item is added\nto `list` using the `add` method or removed using the `remove` method, the\nimplementations of each call the private `update_average` method that handles\nupdating the `average` field as well.\n\nWe leave the `list` and `average` fields private so there is no way for\nexternal code to add or remove items to or from the `list` field directly;\notherwise, the `average` field might become out of sync when the `list`\nchanges. The `average` method returns the value in the `average` field,\nallowing external code to read the `average` but not modify it.\n\nBecause we’ve encapsulated the implementation details of the struct\n`AveragedCollection`, we can easily change aspects, such as the data structure,\nin the future. For instance, we could use a `HashSet<i32>` instead of a\n`Vec<i32>` for the `list` field. As long as the signatures of the `add`,\n`remove`, and `average` public methods stay the same, code using\n`AveragedCollection` wouldn’t need to change. If we made `list` public instead,\nthis wouldn’t necessarily be the case: `HashSet<i32>` and `Vec<i32>` have\ndifferent methods for adding and removing items, so the external code would\nlikely have to change if it were modifying `list` directly.\n\nIf encapsulation is a required aspect for a language to be considered\nobject-oriented, then Rust meets that requirement. The option to use `pub` or\nnot for different parts of code enables encapsulation of implementation details.\n\n### Inheritance as a Type System and as Code Sharing\n\n*Inheritance* is a mechanism whereby an object can inherit elements from\nanother object’s definition, thus gaining the parent object’s data and behavior\nwithout you having to define them again.\n\nIf a language must have inheritance to be an object-oriented language, then\nRust is not one. There is no way to define a struct that inherits the parent\nstruct’s fields and method implementations without using a macro.\n\nHowever, if you’re used to having inheritance in your programming toolbox, you\ncan use other solutions in Rust, depending on your reason for reaching for\ninheritance in the first place.\n\nYou would choose inheritance for two main reasons. One is for reuse of code:\nyou can implement particular behavior for one type, and inheritance enables you\nto reuse that implementation for a different type. You can do this in a limited\nway in Rust code using default trait method implementations, which you saw in\nListing 10-14 when we added a default implementation of the `summarize` method\non the `Summary` trait. Any type implementing the `Summary` trait would have\nthe `summarize` method available on it without any further code. This is\nsimilar to a parent class having an implementation of a method and an\ninheriting child class also having the implementation of the method. We can\nalso override the default implementation of the `summarize` method when we\nimplement the `Summary` trait, which is similar to a child class overriding the\nimplementation of a method inherited from a parent class.\n\nThe other reason to use inheritance relates to the type system: to enable a\nchild type to be used in the same places as the parent type. This is also\ncalled *polymorphism*, which means that you can substitute multiple objects for\neach other at runtime if they share certain characteristics.\n\n> ### Polymorphism\n>\n> To many people, polymorphism is synonymous with inheritance. But it’s\n> actually a more general concept that refers to code that can work with data\n> of multiple types. For inheritance, those types are generally subclasses.\n>\n> Rust instead uses generics to abstract over different possible types and\n> trait bounds to impose constraints on what those types must provide. This is\n> sometimes called *bounded parametric polymorphism*.\n\nInheritance has recently fallen out of favor as a programming design solution\nin many programming languages because it’s often at risk of sharing more code\nthan necessary. Subclasses shouldn’t always share all characteristics of their\nparent class but will do so with inheritance. This can make a program’s design\nless flexible. It also introduces the possibility of calling methods on\nsubclasses that don’t make sense or that cause errors because the methods don’t\napply to the subclass. In addition, some languages will only allow single\ninheritance (meaning a subclass can only inherit from one class), further\nrestricting the flexibility of a program’s design.\n\nFor these reasons, Rust takes the different approach of using trait objects\ninstead of inheritance. Let’s look at how trait objects enable polymorphism in\nRust.\n",
          "document_id": 1
        }
      ]
    },
    {
      "paragraphs": [
        {
          "qas": [
            {
              "question": "What are Patterns in Rust?",
              "id": 28,
              "answers": [
                {
                  "answer_id": 29,
                  "document_id": 4,
                  "question_id": 28,
                  "text": "*Patterns* are a special syntax in Rust for matching against the structure of\ntypes, both complex and simple. Using patterns in conjunction with `match`\nexpressions and other constructs gives you more control over a program’s\ncontrol flow. A pattern consists of some combination of the following:\n\n* Literals\n* Destructured arrays, enums, structs, or tuples\n* Variables\n* Wildcards\n* Placeholders",
                  "answer_start": 25,
                  "answer_end": 421,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            },
            {
              "question": "How to use a pattern?",
              "id": 29,
              "answers": [
                {
                  "answer_id": 30,
                  "document_id": 4,
                  "question_id": 29,
                  "text": "To use a pattern, we compare it to some value. If the pattern matches the\nvalue, we use the value parts in our code. ",
                  "answer_start": 738,
                  "answer_end": 855,
                  "answer_category": null
                }
              ],
              "is_impossible": false
            }
          ],
          "context": "# Patterns and Matching\n\n*Patterns* are a special syntax in Rust for matching against the structure of\ntypes, both complex and simple. Using patterns in conjunction with `match`\nexpressions and other constructs gives you more control over a program’s\ncontrol flow. A pattern consists of some combination of the following:\n\n* Literals\n* Destructured arrays, enums, structs, or tuples\n* Variables\n* Wildcards\n* Placeholders\n\nSome example patterns include `x`, `(a, 3)`, and `Some(Color::Red)`. In the\ncontexts in which patterns are valid, these components describe the shape of\ndata. Our program then matches values against the patterns to determine whether\nit has the correct shape of data to continue running a particular piece of code.\n\nTo use a pattern, we compare it to some value. If the pattern matches the\nvalue, we use the value parts in our code. Recall the `match` expressions in\nChapter 6 that used patterns, such as the coin-sorting machine example. If the\nvalue fits the shape of the pattern, we can use the named pieces. If it\ndoesn’t, the code associated with the pattern won’t run.\n\nThis chapter is a reference on all things related to patterns. We’ll cover the\nvalid places to use patterns, the difference between refutable and irrefutable\npatterns, and the different kinds of pattern syntax that you might see. By the\nend of the chapter, you’ll know how to use patterns to express many concepts in\na clear way.\n",
          "document_id": 4
        }
      ]
    }
  ]
}